---
abbrlink: 2ddfe1fd
---
## 自我介绍

面试官好，非常荣幸能参加这次面试，我叫陈景山，是广东工业大学计算机科学与技术专业2021届的本科生，在大学期间我担任了班级团支书，获得过优秀学生干部称号，在学习上每一年都获得了优秀学生奖学金。在大一下学期就加入了学校的实验室，开始学习java后台开发，在校期间参与多个项目的开发和维护，有已经上线的中山大学附属第一医院技能评估平台，负责项目的前后端设计和实现，除了基本的多角色权限管理，考试安排，成绩分析之外，也设计了完善的日记信息记录和异常告警模块，项目上线至今已经开展过多场百人千人的考试，提供了正确可靠的服务。之后基于SpringCloud和Vue搭建了在线视频课程系统，设计实现了支持断点续传、分片上传、极速妙传的文件模块，同时基于RBAC实现了细粒度的权限管理。课余时间也保持学习，维护了个人的技术博客记录成长，在好未来实习期间参与的是小猴英语项目的开发和维护，基于xxl-job任务调度框架实现了续报发短信功能，设计并实现了批量发放优惠券，日常工作是协助处理小猴英语的客诉问题，梳理APP和后台的接口，个人对于后端开发有兴趣和热爱，也有团队开发和独立开发的经验，希望可以通过面试，进入到公司继续深入学习和进步，做出贡献。

## 技能评估平台介绍

这个项目是用于中山大学附属第一医院的医生技能评估，我负责项目前后端的设计和实现，采用shiro框架实现多角色的登录认证和权限管理，应用spring的schedule定时清理无用数据，使用了poi等实现了成绩导出，支持pdf和excel格式，echarts做成绩等数据的可视化图表和分析，并有完善的日志信息记录和异常告警模块。项目上线至今已经经过了多场百人甚至千人的考试，体现出了无纸化考试的优点，提高了医院医师的工作效率，减少了资源的浪费。



### 定时任务的应用

#### 为什么选Spring自带的

针对业务较简单，所以选用轻量级的易用的，因为Schedule使用简单，在方法上使用注解scheduled加cron表达式即可。

缺点：不适用于任务多，间隔短的情况，因为第一个任务执行未完成时将会导致第二个任务延迟执行。

cron表达式：秒分时日月周(年) 允许取值分别为该时间下的可选值(如秒为0-59) 

特殊取值：*任意，10-12：10秒到12秒，MON,FRI:表示星期一和五，5/15：从5开始每15执行一次。

quartz：非spring自带，主要组件有job任务，trigger触发器，schedule定时器；可装配多个触发器，需要经过配置注入到spring容器中，并且支持分布式事务。

#### springschedule实现原理

ScheduledTaskRegistrar 定时任务注册器，在bean初始化后，会将所有带Schedule注解的方法注册到注册器中

Schedule注解属性：cron-表达式，fixDelay-固定延迟、本次执行开始和上次执行结束之间延迟的毫秒，fixRate-固定频率、以固定的时间间隔执行，initialDelay-延迟任务的初始延迟毫秒数

localExecutor：使用ScheduledThreadPoolExecutor实现，单线程执行，内部采用的是延迟队列DelayQueue。由于是单线程执行，因此不适用于任务多，间隔短的情况，因为第一个任务执行未完成时将会导致第二个任务延迟执行。

### 登录认证权限框架

#### 为什么选shiro

登录认证权限管理主要都是通过过滤器来实现对应的逻辑，shiro在设计上比springSecurity简单许多，不需要繁杂的配置，再加上SpringSecurity功能更加丰富，因此其设计上会更加复杂，上手起来会比较困难，由于只需要认证和鉴权两个核心功能，因此选择了更加轻量级的shiro。

RBAC:基于角色的权限管理，通过用户的角色与其对应的权限实现权限安全管理。

####  JWTtoken和其他认证的比较

jwt是一种身份认证的机制，使用jwt可以在客户端和服务端建立起可靠的通信。

##### 组成

1. header头部-jwt和加密算法
2. payload-设置token信息主题 用户id以及其他信息签发时间签发者过期时间等
3. signature-使用非对称加密算法将base64加密过的头部和payload再次通过密钥加密后就可以生成token。解析时也是一样，只需要验证token即可判断是否登录

#### 单点登录：在不同的系统之间，只需要登录一次，就能访问其他相互信任的系统。

同域：通过cookie的顶域，和session共享实现

不同域：用户访问a系统时，a服务端发现未登录，重定向到单点登录系统，在单点登录系统中完成登录后，会有全局的状态保存，再生成一个凭据回发给a系统，a系统将再发送请求验证凭据的有效性，验证通过后，登陆系统会记录a系统的地址和sessionid，通过则将登陆信息保存在自己的服务端，完成登录。用户访问b系统时，b服务端发现未登录，重定向到单点登录系统，发现已登录，单点登录也生成一个凭据给b系统，b系统记录登录信息。

注销时，在子系统退出通过凭据到登陆系统删除全局session和子系统和sessionid进行删除



## 在线视频课程介绍

这个项目是当时做了技能评估平台，说到一些实操的考试场景比如心肺复苏，可以用视频的方式来考核，但是后面医院那边又搁置了，所以我当时做了一些视频管理相关的实践，后来自己想着不能浪费了就结合了SpringCloud和Vue将它做成一个视频课程系统，在后台管理部分可以管理课程、讲师、文件、权限等，在视频平台提供了登陆注册、单点登录、视频点播等功能。



### 垂直分表的应用

课程内容的大文本字段，切分为新表，提高效率

在大字段/频繁更新的字段，可以应用垂直分表

### 文件分片上传

分片文件key标识属于哪个文件，key通过md5文件信息得到

通过转成10进制，再改成62进制得到更短的key

通过key也可以判断文件是否已经被上传实现极速上传，并通过已传输的分片实现断点续传

选择文件->校验文件->生成唯一标识->组装文件数据->调用文件上传校验接口查询文件记录->1.不存在，开始上传，递归直到所有分片上传完成 2. 存在，上传下一分片直到所有分片上传完成 3.存在，所有分片上传完成，显示极速上传成功 -> 1，2之后，合并分片，删除分片

#### 为什么要使用base64编码传输文件？

计算机存储和操作时都是二进制序列，由于不同的设备对于字符的处理不同，有些二进制值在具体设备上代表不同的含义，因此传输二进制文本可能会导致某些不可见字符被错误传输，因此才有base64编码，因为经过BASE64编码后的字符串，全部都是由标准键盘上面的常规字符组成，这样编码后的字符串在传输过程中不会发生UNICODE字符串不能识别或者丢失的现象。在编码之后也可以用字符串形式对文件进行存储。

#### base64编码原理

将原字符对应的ASCII码值组成的二进制序列，每六位为转为64个字符中的一个。（2^6=64）

#### 数据库的存储

表中使用字段shardIndex标识当前已上传到第几分片，当shardIndex为分配总数shardTotal时，进行合并分片操作。具体通过读取所有临时分片文件，写出到一个文件中。



### 登录注册

#### 登录

1. 生成验证码token，存放验证码字符串以及token到缓存，返回验证码图片
2. 输入用户名、密码、验证码
3. 前端密码加密。调用登录
4. 后端加密密码
5. 获取验证码判断是否正确
6. 正确验证码后，清除redis数据
7. 查询用户是否存在
8. 用户存在则比较密码是否正确
9. 密码正确得到用户信息，生成token，存放到缓存（单点登录）
10. 返回用户信息，不返回密码
11. 保存用户信息到前端session
12. 记住我？是保存到localsession，否则清空local缓存

#### 注册

发送短信验证码，60s不重发功能

### 权限管理

用户->角色，角色->资源

表设计：用户表、角色表、资源表、用户-角色表、角色-资源表

读取权限：登陆时加载所有权限

拦截：根绝资源所需的权限 判断当前是否拥有权限

1. 前端：菜单、路由、按钮、
2. 后端：接口、gateway过滤

权限初始化：以json形式记录所有资源

### 代码生成器

主要是基于FreeMarker模板引擎，它工作过程就是完成一些指定变量的替换，比如说类名、字段名这些。应用在我们开发的时候比如和数据表对应的Java对象，因为来源肯定是数据表，所以可以读取出所有的字段，然后将它们通过freemarker的for标签，循环写出到文件里

分布式部署：保证统一不重复任务