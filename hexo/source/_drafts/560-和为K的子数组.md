---
title: 560. 和为K的子数组
tags:
  - Leetcode
  - 数组
  - 哈希
categories:
  - Leetcode
abbrlink: a146f8fa
---

> 给定一个整数数组和一个整数 k ，你需要找到该数组中和为 k 的连续的子数组的个数。
>
> 示例 1：
>
> ```java
> 输入:nums = [1,1,1], k = 2
> 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
> ```

<!-- more -->

### 💡 思路

这题一开始没什么思路，只想到了暴力解法，两层for循环，遍历以每一个位置为开头的数字其连续子数组的和，当和为k时，记录结果。

可能容易出现一步错误的优化，就是当和大于k时跳出内层循环，但是需要注意的是：这里数组中可能出现负数，因此和并不是一直增加的。

### 🧾 代码

编码上没有什么注意的点，考虑代码的鲁棒性。

```java
public int subarraySum(int[] nums, int k) {
    //暴力-double for
    if(nums == null || nums.length == 0){
        return 0;
    }
    int n = nums.length;
    int res = 0;
    for(int i = 0; i < n; i++){
        int sum = 0;
        for(int j = i; j < n; j++){
            sum += nums[j];
            if(sum == k){
                res ++;
            }
        }
    }
    return res;
}
```

神奇的是暴力的解法居然也可以在Leetcode上获得一个accept😂。

### 📈 优化

暴力解中每一次都要重新计算从i开始往后的子数组的和，存在大量的重复计算。其实优化的思路并不好想，需要将子数组的和转化为“前缀和”的差，什么是“前缀和”呢？举个例子，对于数组nums` [3,1,-2,5] `，前缀和pre为` [3,4,2,7] ` 。子数组的和转化为“前缀和”的差，同样举个例子，子数组` [1,-2] `的和为` 2-3=-1 `，即` nums[1]+nums[2]=pre[2]-pre[0] `。

有了上面的基础之后，我们将问题转化为，

