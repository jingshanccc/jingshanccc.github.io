---
abbrlink: 63f01be3
---
1. 两数之和

  使用map存放元素和下标，遍历过程中，查看是否map中是否存在key：target-nums[i]，有则找到了两数和为target，返回其下标和当前下标

2. 两数相加

  处理进位。

3. 无重复字符的最长子串

  利用set和滑动窗口，右侧从0向右移动过程中，如果当前字符以存在set中，则表示遇到了重复，记录此时right-left，并将元素移除，left++；否则继续right++

4. 最长回文子串

  动态规划，如果S[i+1...j-1]是回文串，则当S[i]=S[j]时，S[i...j]也为回文串。因此状态转移方程为dp[i] [j] = dp[i+1] [j-1] && S[i]==S[j]，如果S[i...j]也为回文串，并且长度大于之前的回文串，则更新长度

5. 整数反转

  通过不断对10取模获取到数字的最后一位，然后/10继续下一位，获取到最后一位时，在拼接成新数字时，判断是否溢出。因为我们通过ans*10 + pop的方式得到拼接后的数字，则根据ans *10 + pop > Integer.MAX_VALUE，和 ans *10 + pop < Integer.MIN_VALUE可以得到溢出的条件，在拼接之前做出判断。` ans > Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 && pop > 7)`，7是整型最大值的个位数。

6. 回文数

  同样使用第5题的方法，逆序构造的数字如果不等于原值则返回false。由于不需要判断溢出，因此采用long来记录构造的数字

7. 盛最多水的容器

  双指针，从左右边界向中间移动，每次移动较小的一个，记录最大值作为结果。正确性来自面积S=min(height[left], height[right]) * (right-left)，由于总是取较小的高，而在移动过程中right-left会一直变小，因此移动较高的一侧不可能产生更大的面积

8. 最长公共前缀

  暴力：以一个字符串为模板，对其每一个字符，遍历其他所有字符串，当全部相等时则添加到结果字符串中，出现不等则结束返回结果字符串

  字典树：

9. 三数之和

  普通：外层for循环，内层使用两数之和做法，去重难搞

  排序双指针：排序后，外层循环可去重，在内层循环，通过左右双指针，由于排序过，因此可通过三数之和与0的大小关系，确定左/右指针移动

10. 最接近的三数之和

  与上一题相同做法，在记录结果时需要通过绝对值比较，更新结果。


11. 电话号码的字母组合

    回溯：从第一个数字开始，遍历数字对应的字母，将当前字母添加到生成的字符串后面，再输入下一个数字，当没有数字要被输入时，则一个字母组合产生。

12. 四数之和

    思想同10，共三层循环。先对数组排序，可以根据和的大小情况，让最内层循环的左右指针移动，并且可以提前break和continue。

13. 删除链表的倒数第N个节点

    普通：先遍历得到个数，再进行删除，共扫描两趟

    双指针：q先走n步，然后p、q同时向后走，直到q为空，此时p则在倒数第n个位置。

14. 有效的括号

    栈：遇到左括号入栈，遇到匹配的右括号出栈，最终返回栈是否为空

15. 合并两个有序链表

    归并排序子过程：比较当前两节点，小的则成为结果链表的下一个节点，然后所在链表跳到下一个节点，直到一方为空，接下来将另一方的剩余节点添加到结果链表

16. 括号生成

    回溯：总长度2*n，每个位置有两种选择，左括号必须在前，因此当左括号数量小于右时，则不满足要求，否则的话继续添加左右括号，并进行下一步搜索。

17. 两两交换链表中的节点

    迭代：拿到连续的三个节点，将前两个节点node1、node2完成交换，并将第三个节点连接在node1（后）上，然后虚拟头节点连上node2（前），当前p前进到node1

    递归：终止条件为当前为空或当前没有下一节点；返回值为完成交换的子链表；单个f(x)完成两个节点的交换，head和next，head连接完成了交换的子链表，next连接head。

18. 删除排序数组中的重复项

    双指针：遍历时慢指针和快指针值相等则让快指针前进以跳过重复项，不等时将这个不等的值放到慢指针的位置，然后让慢指针前进，准备存放下一个不重复的值

19. 下一个排列

    逆向遍历，如果当前比前一个大，从当前开始向后找到一个比前一个大的**最小数**，调换顺序，然后对当前到数组结束位置的部分排序为升序。最差遍历两次数组，复杂度O（n）

20. 搜索旋转排序数组

    时间复杂度O（logN），考虑二分。数组被分为两个有序的部分，因此在找到**分界点**（最大值/最小值）后，问题转变为在有序数组中的查找问题，采用二分查找。

21. 在排序数组中查找元素的第一个和最后一个位置

    与上一题异曲同工，区别在于

22. 搜索插入位置

23. 外观数列

24. 组合总和

25. 组合总和 II

26. 全排列

27. 旋转图像

28. 字母异位词分组

29. Pow(x,n)

30. 最大子序和

31. 螺旋矩阵

32. 跳跃游戏

33. 合并区间

34. 旋转链表

35. 不同路径

36. 最小路径和

37. 加一

38. x的平方根

39. 爬楼梯

40. 颜色分类

41. 子集

42. 单词搜索

43. 删除排序链表中的重复元素

44. 分隔链表

45. 合并两个有序数组

46. 子集 II

47. 解码方法

48. 反转链表 II

49. 二叉树的中序遍历

50. 不同的二叉搜索树 II

51. 不同的二叉搜索树

52. 验证二叉搜索树

53. 对称二叉树

54. 二叉树的层序遍历

55. 二叉树的锯齿形层次遍历

56. 二叉树的最大深度

57. 从前序与中序遍历序列构造二叉树

58. 将有序数组转换为二叉搜索树

59. 有序链表转换二叉搜索树

60. 路径总和 II

61. 二叉树展开为链表

62. 杨辉三角

63. 买卖股票的最佳时机

64. 买卖股票的最佳时机 II

65. 验证回文串

66. 只出现一次的数字

67. 只出现一次的数字 II

68. 单词拆分

69. 环形链表

70. 环形链表 II

71. 重排链表

72. 二叉树的前序遍历
    73 .LRU缓存机制

73. 排序链表

74. 逆波兰表达式求值

75. 乘积最大子数组

76. 最小栈

77. 相交链表

78. 寻找峰值

79. 多数元素

80. Excel表列序号

81. 阶乘后的零

82. 最大数

83. 重复的DNA序列

84. 旋转数组

85. 打家劫舍

86. 二叉树的右视图

87. 岛屿数量

88. 快乐数

89. 移除链表元素

90. 反转链表

91. 数组中的第K个最大元素

92. 存在重复元素

93. 最大正方形

94. 用队列实现栈

95. 翻转二叉树

96. 基本计算器 II

97. 二叉搜索树中第K小的元素

98. 用栈实现队列

99. 回文链表

100. 二叉搜索树的最近公共祖先

101. 二叉树的最近公共祖先

102. 删除链表中的节点

103. 除自身以外数组的乘积

104. 搜索二维矩阵 II

105. 有效的字母异位词

106. 各位相加

107. 缺失数字

108. 完全平方数

109. 移动零

110. 寻找重复数

111. Nim 游戏

112. 最长上升子序列

113. 超级丑数

114. 零钱兑换

115. 3 的幂

116. 奇偶链表

117. 递增的三元子序列

118. 打家劫舍 III

119. 比特位计数

120. 反转字符串

121. 前K 个高频元素

122. 两个数组的交集

123. 两整数之和

124. 有序矩阵中第K小的元素

125. 字符串解码

126. 移掉K位数字

127. 根据身高重建队列

128. 最长回文串

129. FizzBuzz

130. 字符串相加

131. 分割等和子集

132. 找到所有数组中消失的数字

133. 四数相加 II

134. 分发饼干

135. 汉明距离

136. 数字的补数

137. 把二叉搜索树转换为累加树

138. 二叉树的直径

139. 和为K的子数组

140. 分糖果

141. 最短无序连续子数组

142. 合并二叉树

143. 回文子串

144. 最大二叉树

145. 1 比特与 2 比特字符

146. 最长重复子数组

147. 自除数

148. 每日温度

149. 划分字母区间

150. 重构字符串

151. 宝石与石头

152. 用两个栈实现队列

153. 斐波那契数列

154. 数组中重复的数字

155. 二维数组中的查找

156. 青蛙跳台阶问题

157. 旋转数组的最小数字

158. 替换空格

159. 从尾到头打印链表

160. 重建二叉树

161. 剪绳子

162. 合并两个排序的链表

163. 树的子结构

164. 二叉树的镜像

165. 对称的二叉树

166. 调整数组顺序使奇数位于偶数前面

167. 二进制中 1 的个数

168. 顺时针打印矩阵

169. 链表中倒数第k个节点

170. 数值的整数次方

171. 反转链表

172. 删除链表的节点

173. 最小的k个数

174. 包含min函数的栈

175. 连续子数组的最大和

176. 二叉搜索树与双向链表

177. 栈的压入、弹出序列

178. 字符串的排列

179. 数组中出现次数超过一半的数字

180. 从上到下打印二叉树

181. 从上到下打印二叉树II

182. 从上到下打印二叉树III

183. 二叉搜索树的后序遍历序列

184. 第一个只出现一次的字符

185. 二叉树中和为某一值的路径

186. 二叉树的深度

187. 数组中数字出现的次数

188. 数组中数字出现的次数 II

189. 和为s的两个数字

190. 把数组排成最小的数

191. 和为s的连续正数序列

192. 两个链表的第一个公共节点

193. 礼物的最大价值

194. 翻转单词顺序

195. 在排序数组中查找数字 I

196. 左旋转字符串

197. 0 ～n- 1 中缺失的数字

198. 最长不含重复字符的子字符串

199. 二叉搜索树的第k大节点

200. 丑数

201. 不用加减乘除做加法

202. 滑动窗口的最大值

203. 构建乘积数组

204. 扑克牌中的顺子

205. 平衡二叉树

206. 股票的最大利润

207. 求 1 + 2 +...+n

208. 二叉搜索树的最近公共祖先

209. 二叉树的最近公共祖先