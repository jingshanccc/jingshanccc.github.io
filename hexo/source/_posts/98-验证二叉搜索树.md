---
title: 98. 验证二叉搜索树
tags:
  - Leetcode
  - 二叉搜索树
  - 递归
categoires:
  - Leetcode
abbrlink: 5e0c5aa8
---

> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。假定一个二叉搜索树有以下特征：
>
> - 节点的左子树只包含**小于**当前节点的数
> - 节点的右子树只包含**大于**当前节点的数
> - 所有左子树和右子树自身必须也是二叉搜索树

<!-- more -->

{% note info %}

示例 1:

```
输入:
    2
   / \
  1   3
输出: true
```


示例 2:

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

{% endnote %}

### 💡 思路

二叉树由于天然的具有递归结构，因此大多数问题都可以通过**递归**来解决。本题需要判断当前树是否为二叉搜索树，则当当前节点为二叉搜索树、其左子树为二叉搜索树、其右子树为二叉搜索树时返回 `true ` 。需要注意的是，作为一棵二叉搜索树，它左子树的所有节点都必须小于它，因此不能仅仅判断它和它的左子节点，这样只能判断父子关系而没有判断爷孙关系。

### 🧾 代码

```java
public boolean isValidBST(TreeNode root) {
    return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);
}
public boolean valid(TreeNode node, long min , long max){
    if(node == null){
        return true;
    }
    if(node.val < min || node.val > max){
        return false;
    }
    return valid(node.left, min, node.val) && valid(node.right, node.val, max);
}
```

### ✍️ 中序遍历

对于一颗二叉搜索树，它的中序遍历序列是递增的。根据这个特征，我们在中序遍历的时候判断当前值是否大于上一个值即可。如果对树的遍历还不熟悉，可以查看这篇文章 {% post_link 二叉树的遍历 %}

```java
private long pre = Long.MIN_VALUE;
public boolean isValidBST(TreeNode root) {
    //递归版
    if(root == null){
        return true;
    }
    if(!isValidBST(root.left)){
        return false;
    }
    if(pre >= root.val){
        return false;
    }
    pre = root.val;
    
    return isValidBST(root.right);
    
    //非递归版
    if(root == null){
        return true;
    }
    Stack<Node> stack = new Stack<>();
    while(!stack.isEmpty() || root != null){
        if(root != null){
            stack.push(root);
            root = root.left;
        }else{
            root = stack.pop();
            if(root.val <= pre){
                return false;
            }
            pre = root.val;
            root = root.right;
        }
    }
    return true;
}
```

