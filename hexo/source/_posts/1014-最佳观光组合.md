---
title: 1014. 最佳观光组合
tags:
  - 数组
categories:
  - Leetcode
abbrlink: 6cc1ef4f
---

> 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。
>
> 一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。
>
> 返回一对观光景点能取得的最高分。
>

<!-- more -->

```java
示例：
    输入：[8,1,5,2,6]
    输出：11
    解释：i=0,j=2,A[i]+A[j]+i-j=8+5+0-2=11
```

### 💡 思路

在数组中寻找的问题通常最直观的思路是暴力的遍历，这道题同样可以使用这种方法，从前往后枚举每一个元素，并对该元素遍历除了本身之外的其他所有元素，在这个过程中更新最大值`max`。由于数据规模是`50000`，因此这种`o(n²)`的做法是会超时的。

{% fold 代码 %}

```java
public int maxScoreSightseeingPair(int[] A) {
    if(A==null || A.length==0){
        return -1;
    }
    int n = A.length;
    int max = Integer.MIN_VALUE;
    //暴力-超时
    for(int i = 0; i < n; i++){
        for(int j = 0 ; j < n; j++){
            if(j != i){
                max = Math.max(max, A[i]+A[j]-Math.abs(i-j));
            }

        }
    }
    return max;
}
```



{% endfold %}

### 📈 优化

在暴力做法中，对于得分公式`A[i] + A[j] + i - j`，我们将其划分成了`A[i] + i`和`A[j]-j`两部分，在外层循环确定一个`A[i]+i`，在内层循环中枚举所有`A[j]-j`，以此找到最大值。这导致了时间复杂度是`O(n²)`的，那么我们如何将这两层循环减为一层呢？答案是从这两部分出发，只要两部分都是最大值，那么组合结果一定是最大值。我们可以在遍历过程中，同时维护原本外层循环的`A[i]+i`始终为最大值即可通过一层循环求出结果。

### 🧾 代码

```java
public int maxScoreSightseeingPair(int[] A) {
    if(A==null || A.length==0){
        return -1;
    }
    int n = A.length;
    int max = Integer.MIN_VALUE;

    //遍历的同时维护a始终为最大的A[i]+i值
    int a = A[0] + 0;
    for (int i = 1; i < n; i++) {
        max = Integer.max(max, a + A[i] - i);
        a = Integer.max(a, A[i] + i);
    }
    return max;
}
```

