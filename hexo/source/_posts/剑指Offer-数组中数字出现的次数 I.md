---
title: 剑指Offer-数组中数字出现的次数 I
date: '2020-04-29 15:23'
tags:
  - 剑指Offer
  - 数组
  - 位运算
categories:
  - 剑指Offer
abbrlink: 1f1789a9
---

> 一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

<!-- more -->

#### ⛔不符合要求的两种思路

1. 数组中的次数问题，我们很容易联想到使用额外的数组记录次数来解决，但这里数组中的元素没有范围，并且由于空间复杂度的要求是O(1)，因此需要考虑其他思路。

2. 首先从数组的特征出发，除两个数字之外，其他每个数字都出现了两次，那么我们可以先排序，然后遍历数组找到只出现一次的两个数字。由于排序的时间复杂度为O(NlogN)，因此也无法满足要求。

{% note primary%}

那么这道题考察什么呢？

{% endnote %}

这是一道非常经典的题目，通过位运算**异或**来解决

#### ☑️正确操作

先来看看异或的性质

{% note default no-icon %}

1. 交换律：p⊕q=q⊕p 
2. 结合律：(p⊕q)⊕r = p⊕(q⊕r)
3. 恒等率：p⊕0 = p
4. 归零率：p⊕p = 0

{% endnote %}

假设数组中不相同的两个数字是p，q。对数组中的数字进行异或操作，根据交换律，我们让每两个相同的数字异或得到0，最后剩下p，q，因为两个数不同，至少存在一个位不同。异或之后得到的结果肯定存在**某个二进制位为1**。根据这个位，将数组分为两份，由于相同的数字会分到同一组，分别为p和其他相同的数字、q和其他相同的数字。再进行异或，则可以得到p，q。

{% note info %}

举个例子：nums=[1,2,10,4,1,4,3,3]

- 异或和sum = 1⊕2⊕10⊕4⊕1⊕4⊕3⊕3 = 1⊕1⊕3⊕3⊕4⊕4⊕2⊕10 = 2⊕10 = 0010 ⊕ 1010 = 1000
- 得到二进制为1的位index，sum每次右移一位，当最低位为1`sum & 1 == 1`，index则为右移次数也即该位在sum中的位置。1000中右移三位0001&1=1，index = 3。<u>此处理论上上使用任何一个为1的位都可以正确得到结果，但是在代码实现上求最右的1是最方便的。</u>
- 根据index划分两组，在划分过程中同时执行异或和计算。对于数组中的所有数字，要么index位为1，要么index位为0 `( i >> index ) & 1`，如数字1在第三位为0，数字2在第三位为0，数字10在第三位为1，以此划分。

{% endnote %}

```java
public int[] singleNumbers(int[] nums) {
	//1.得到异或和
    int sum = 0;
    for(int i : nums){
        sum ^= i;
    }
    //2.找到二进制位为1的位
    int index = 0;
    while(sum & 1 == 0){
        index+=1;
        sum >>= 1;
    }
    //3.分组
    int p, q;
    for(int i : nums){
        if( (i >> index) & 1 == 0 ){
            p ^= i;
        }else{
            q ^= i;
        }
    }
    return new int[]{p,q};
}
```

{% note info %}

当你理解了上述的算法过程之后，如果你知道负数在机器中采用数值的**补码**来表示，那么第二步中的求异或和sum中为1的二进制位就可以使用` sum & -sum `来得到，补码是原码按位取反+1，-8 使用 8 的补码表示为 1000，那么结果将是1000，接下来第三步操作也相应的有一些小小的改动。

{% endnote %}

```java
public int[] singleNumbers(int[] nums) {
    //1.得到异或和
    int sum = 0;
    for(int i : nums){
        sum ^= i;
    }
    //2.找到二进制位为1的位
    sum &= -sum;
	//3.分组并求和
    int p, q;
    for(int i : nums){
        if((sum&i) == 0){
            p^=i;
        }else {
            q^=i;
        }
    }
    return new int[]{p,q};
 }
```





