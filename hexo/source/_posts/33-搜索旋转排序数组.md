---
title: 33. 搜索旋转排序数组
tags:
  - Leetcode
  - 二分查找
categories:
  - Leetcode
abbrlink: 3abd6d1e
date: 2020-05-01 16:25:32
---

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
> 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
>
> 你可以假设数组中不存在重复的元素。
>
> 你的算法时间复杂度必须是 O(log n) 级别。
>

<!-- more -->

{% note info %}

示例 1:

``` 
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

{% endnote %}

### 💡 思路

题目要求时间复杂度为O(logn)，因此考虑使用二分查找的方法。二分查找要在有序的数组中进行，往这个方向思考，我们可以发现虽然给定的数组整体并不是有序的，但是它被分为两部分有序的数组，分界点在最大值/最小值。想到了这一点，整个问题转变为在两个有序数组中查找目标值，是一个简单的二分查找过程。而求分界点的方法和Leetcode {% post_link 153-寻找旋转排序数组中的最小值 %} 问题相同。

### 🧾 代码

```java
public int search(int[] nums, int target) {
    if(nums == null || nums.length == 0){
        return -1;
    }
    //先找到最高点，然后就可以划分为在有序数组中的查找问题
    int left = 0, right = nums.length-1;
    while(left < right){
        int mid = left + (right-left+1)/2;//因为mid可能一直取left导致死循环,因此+1向上取整 防止死循环
        if(nums[mid] < nums[left]){
            right = mid - 1;
        }else{
            left = mid;
        }
    }
    if(target < nums[0]){//在右有序数组
        return binarySearch(nums,target,left+1,nums.length-1);
    }else{//在左有序数组
        return binarySearch(nums,target,0,left);
    }
}
public int binarySearch(int[] nums, int target, int left , int right){
    while(left <= right){
        int mid = left + (right-left)/2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid+1;
        }else{
            right = mid-1;
        }
    }
    return -1;
}
```

