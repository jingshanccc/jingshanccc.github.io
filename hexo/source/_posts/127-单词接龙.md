---
title: 127. 单词接龙
tags:
  - 广度优先搜索
categories:
  - Leetcode
abbrlink: 527f7711
---

> 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
>
> 1. 每次转换只能改变一个字母。
> 2. 转换过程中的中间单词必须是字典中的单词。
>
> 说明:
>
> - 如果不存在这样的转换序列，返回 0。
> - 所有单词具有相同的长度。
> - 所有单词只由小写字母组成。
> - 字典中不存在重复的单词。

<!-- more-->

### 💡 思路

算法的主要过程是对`beginWord `每次替换一个字母，成为一个新的单词，判断是否是` endWord ` 。题目要求找到最短转换序列的长度，也就是最少的转换次数，因此可以考虑采用广度优先搜索。因为每次替换一个位置的字母，有25种选择，新的单词必须存在于给出的`wordList`种，共有单词的长度`len`个位置。

整个算法其实是在构建一张无向图，假设`beginWord `为`hit `，` endWord `为`hot `，`wordList `为` [hat,bat,hot]`。从`beginWord `开始，对于第一个位置`h `，有25种替换选择，但其中只有选择`b `所生成的新单词`bat `在`wordList`中，因此需要往队列`queue` 中添加`bat `，第二个位置`i `，同样有25种选择，其中只有选择`a`和`o` 所生成的新单词在`wordList`中，因此需要将`hat,hot`放入queue中。但在这里我们发现新生成的单词`hot` 即为`endWord `，此时即是最少的转换次数为1次。

理解上述过程需要你对广度优先搜索有一定的熟悉度，比如所用的队列、何时更新转换次数等。

### 🧾 代码

代码的整个框架还是比较常规的广度优先搜索，主要是其中进行替换时需要替换`len`个位置，以及每个位置可从`a`到`z`。

```java
 public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
     HashSet<String> words = new HashSet<>(wordList);
     if(words.size()== 0 || !words.contains(endWord)){//不存在endword
         return 0;
     }
     words.remove(beginWord);

     Queue<String> queue = new LinkedList<>();
     queue.offer(beginWord);
     HashSet<String> visited = new HashSet<>();//存放已经使用过的
     visited.add(beginWord);
     int len = beginWord.length();
     int step = 1;
     while(!queue.isEmpty()){
         int size = queue.size();
         for(int i = 0 ; i < size; i++){
             String curWord = queue.poll();
             char[] chars = curWord.toCharArray();
             for(int j = 0; j < len; j++){//当前单词的每个位置
                 char oldChar = chars[j];

                 for(char m = 'a'; m <= 'z'; m++){//从a-z依次替换
                     if(m == oldChar){
                         continue;
                     }
                     chars[j] = m;//替换当前位置
                     String newWord = String.valueOf(chars);
                     if(words.contains(newWord)){//新单词存在于wordList中
                         if(newWord.equals(endWord)){//找到了
                             return step+1;
                         }
                         if(!visited.contains(newWord)){//未使用过
                             queue.add(newWord);
                             visited.add(newWord);
                         }
                     }
                 }
                 chars[j] = oldChar;//还原当前位置
             }
         }
         step ++;//此时更新step-在上面整个循环中完成的是将一次替换的所有结果存放到了queue中
     }
     return 0;
 }
```

