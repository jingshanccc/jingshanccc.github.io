---
title: 53. 最大子序和
tags:
  - Leetcode
  - 分治算法
  - 动态规划
categories:
  - Leetcode
abbrlink: a42162e0
---

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 示例:
>
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

<!-- more -->

### 👊 暴力解法

具有最大和的连续子数组一定是以数组中的某个元素开头的，因此我们只要求得每个位置的最长连续子数组自然也可以得到结果。稍加分析之后，信心满满的写下了这样的代码。{% fold 展开 %}

``` java
public int maxSubArray(int[] nums){
    if(nums == null || nums.length == 0){
        return 0;
    }
    int res = 0;
    for(int i = 0; i < nums.length; i++){
        int sum = nums[i];
        for(int j = i+1; j < nums.length; j++){
            if(nums[j] < 0){
                break;
            }else{
                sum += nums[j];
            }
        }
        res = Math.max(res, sum);
    }
    return res;
}
```

{% endfold %}

跑一下发现连测试用例都过不了。错误的原因在于：当下一个数为负时并**不能跳出循环**，因为可能后面还会有更大的正数，即使加上这个负数，但是由于后面正数更大，自然应该继续累加。

> 对于 ` [1,-3,4] `，即使 ` 1 ` 后面是 ` -3 `，但是如果就此跳出循环，则求得的最大和为` 1 `，但是正确的最大和是 ` 1 + -3 + 4 = 2 `。

于是我们尝试修改代码，由于我们只需要求得最大和是多少，因此在内层循环累加的过程中不断更新结果，那么最大值一定能够被找到。{% fold 改正之后的代码 %}

```java
public int maxSubArray(int[] nums) {
    if(nums == null || nums.length == 0){
        return 0;
    }
    int res = Integer.MIN_VALUE;
    for(int i = 0; i < nums.length; i++){
        int sum = 0;
        for(int j = i; j < nums.length; j++){
            res = Math.max(res, sum+=nums[j]);
        }
    }
    return res;
}
```

{% endfold %}

### 📈 优化

上述的思路，为了知道以某个位置的元素为开头的最大和，我们遍历了后续的所有元素，通过**枚举**来求得最大值，而这仅仅能求得这一个位置。这也导致算法的时间复杂度是O(N²)的。于是我们换个思路，当我们考虑以当前位置的元素作为结尾时的最大和，可以根据**前一个位置**求得的最大和 `sum ` 的**正负**，来决定当前位置是加在前一个元素之后，还是自己成为一个新的子数组。当 ` sum > 0 `，对于当前数，加上这个 ` sum `，有增加的效果；当 ` sum <= 0 ` ，对于当前数，加上这个 ` sum ` ，有减小的效果，因此可以丢弃之前的 ` sum ` ，重新开始计算。

{% note success %}

根据前一个位置的结果得到当前位置的结果，这是典型的**动态规划**思想。

{% endnote %}

### 🧾 代码

```java
public int maxSubArray(int[] nums) {
    if(nums == null || nums.length == 0){
        return 0;
    }
    int n = nums.length;
    int[] dp = new int[n];
    dp[0] = nums[0];
    int res = dp[0];
    for(int i = 1; i < n; i++){
        dp[i] = dp[i-1]>0 ? dp[i-1]+nums[i] : nums[i];
        res = Math.max(dp[i],res);
    }
    return res;
}
```

更进一步的，因为我们只需要知道前一个位置的结果，因此使用一个变量 ` sum ` 记录，优化空间复杂度。{% fold 查看 %}

```java
public int maxSubArray(int[] nums) {
    int res = nums[0];
    int sum = 0;
    for (int num : nums) {
        sum = sum > 0 ? sum+num : num;
        res = Math.max(res, sum);
    }
    return res;
}
```

{% endfold %}