---
title: 21. 合并两个有序链表
tags:
  - Leetcode
  - 归并排序
  - 链表
categories:
  - Leetcode
abbrlink: c8c06f39
---

> 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

<!-- more -->

{% note info %}

**示例：**

**输入：**1->2->4，1->3->4

**输出：**1->1->2->3->4->4

{% endnote %}

### 💡思路

这道题属于归并排序的应用，数组的归并过程是：使用两个索引` i , j `指向两个数组的左边界，每次根据两个数组中各自索引位置的元素大小来将一个元素放到结果数组中然后对应索引前进。当然了，我们还需要一个索引` k `来标识元素应该放到结果数组中的哪个位置。{% fold 点击此处查看数组的归并 %}

```java
public int[] merge(int[] arr1, int[] arr2){
    int[] result = new int[arr1.length+arr2.length];
    int i = 0, j = 0, k = 0;
    while(i < arr1.length && j < arr2.length){//终止条件是arr1用完或arr2用完
        if(arr1[i] < arr2[j]){
            result[k++] = arr1[i++];
        }else{
            result[k++] = arr2[j++];
        }
    }
    while(i < arr1.length){//arr2用完
        result[k++] = arr1[i++];
    }
    while(j < arr2.length){//arr1用完
        result[k++] = arr2[j++];
    }
    return result;
}
```

{% endfold %}

### 🧾代码

了解了数组的归并过程，做这道题也就非常简单了。由于链表不像数组那样通过索引来方便的获取/修改该位置的元素，因此我们需要通过链表的`next`指针来推进归并过程。对于链表操作需要注意的是指针之间的引用关系。

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    //本着不修改输入的原则,我们应该使用两个指针指向输入,避免对l1,l2直接修改
    ListNode h1 = l1, h2 = l2;
    //初始化一个虚拟头节点,作为结果链表
    ListNode dummyHead = new ListNode(0);
    ListNode cur = dummyHead;
    while(h1 != null && h2 != null){
        if(h1.val < h2.val){
            cur.next = new ListNode(h1.val);
            cur = cur.next;
            h1 = h1.next;
        }else{
            cur.next = new ListNode(h2.val);
            cur = cur.next;
            h2 = h2.next;
        }
    }
    if(h1 != null){
        cur.next = h1;
    }
    if(h2 != null){
        cur.next = h2;
    }
    return dummyHead.next;
}
```

