---
wtitle: 739. 每日温度
categories:
  - Leetcode
tags:
  - 单调栈
abbrlink: f2adbb58
---

> 请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
>
> 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
>
> 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
>

<!-- more -->

### 💡 思路

比较直观的做法就是对于每个位置，往后遍历，当遇到第一个比自身大的元素时就停下来，记录位置；如果直到最后都没有遇到，则表示气温在这之后都不会升高。

### 🧾 代码

```java
public int[] dailyTemperatures(int[] T) {
    if(T == null || T.length == 0) return T;
    int n = T.length;
    int[] res = new int[n];
    //暴力
    for(int i = 0 ; i < n; i++){
        for(int j = i + 1; j < n; j++){
            if(T[j] > T[i]){
                res[i] = j-i;
                break;
            }
        }
    }
    return res;
}
```



### 📈 优化

暴力遍历的方式虽然可以获得一个accept，但是效率是非常低的。因为每一次我们都是重新开始遍历，没有利用之前的结果。因此有了以下两种优化方式。

#### 单调栈

单调栈的含义是，一个栈中从栈顶到栈底一直保持着递增/递减的性质。当遇到新的元素入栈时，如果破坏了性质，则要通过出栈直到剩余的元素和新元素仍保持性质。

本题中，通过维护一个递减的单调栈，可以求出结果。将数组中元素（下标）逐个入栈，当**新元素比栈顶元素大**时，对于栈顶元素来说，即遇到了**第一个比它大**的元素，也就是气温升高，因此将栈顶出栈，并记录结果（下标差）。

```java
public int[] dailyTemperatures(int[] T) {
    if(T == null || T.length == 0) return T;
    int n = T.length;
    int[] res = new int[n];

    //单调栈
    Stack<Integer> stack = new Stack<>();
    for(int i = 0; i < n; i++){
        while(!stack.isEmpty() && T[i] > T[stack.peek()]){
            int index = stack.pop();
            res[index] = i - index;
        }
        stack.push(i);
    }
    
    return res;
}
```



#### 逆向+跳跃

对于数组的最后一个元素，由于其后面没有元素，因此该位置结果为0。基于最后一个位置，我们尝试不断地推出前一个元素的结果。先看一下代码

```java
public int[] dailyTemperatures(int[] T) {
    if(T == null || T.length == 0) return T;
    int n = T.length;
    int[] res = new int[n];
    
    //跳跃
    for(int i = n - 1; i >= 0; i--){
        int j = i + 1;
        while(j < n){
            if(T[j] > T[i]){
                res[i] = j - i;
                break;
            }else if(res[j] == 0){
                break;
            }else{
                j += res[j];
            }
        }
    }
    return res;
}
```

外层for循环从后往前遍历，对于每一个位置`i `，内层while循环起点是后一个元素`j `，如果`T[j] > T[i]`，即气温升高，则记录结果（下标差）；如果位置`j`不大于`i`，按照暴力的逻辑，我们会逐个往后遍历，而这里我们通过判断已求得的结果`res[j]`是否为0来进行“跳跃”。对于`res[j]`：

- `res[j] == 0`，即`j`之后气温不再升高，那么由于`T[i]>=T[j] `，可得`res[i] = 0`
- `res[j] > 0`，即`j`之后`res[j] `天气温升高，在`[j...j+res[j]]`间没有比`T[i]`大的值，可以进行跳跃，加快效率，在对新的`j`进行判断