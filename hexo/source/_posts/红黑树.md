---
title: 红黑树基础
categories:
  - 数据结构
image: 'https://gitee.com/jingshanccc/image/raw/master/image/20200722003354.png'
abbrlink: 75890e6e
---

<P></p>

<!-- more -->

## 从2-3树开始说起

### 🍉简介

我们知道二分搜索树在插入元素本身是有序的情况下，其将退化成一个链表，查询效率也由O(logN)退化到O(N)，为了提升效率，将二分搜索树优化为平衡二叉树，在插入删除过程中保证左右子树的高度差不超过1，让树的高度最小。但是维护平衡也需要带来更多更复杂的操作，因此引入了2-3树。

2-3树是一棵绝对平衡的树，它的结点可以有2个孩子或3个孩子，这也是其名字的由来，它满足二分搜索树的基本性质，其大小关系如下图

![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003409.png)

### 🍓插入操作

2-3树在插入结点时不能将结点插入到一个空结点上，因为要保证其绝对平衡的性质，新的结点只能通过分裂或者融合产生。

下面通过对上图的2-3树的构建过程，了解2-3树的插入操作。

依次插入16-15-13-12-11-10-8-6-5

1. 插入16-15-13

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003432.png)

   在插入13之后，形成了一个“4结点”，于是通过**分裂**将其转变为3个2结点

2. 插入12-11

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003503.png)

   在插入11之后，形成了一个“4结点”，于是通过**分裂**将其转变为3个2结点，但也因此出现了不平衡，所以需要通过**融合**保证树的绝对平衡。

3. 插入10-8

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003554.png)

   和前面的过程类似，需要通过多次的**分裂**和**融合**来保证平衡

4. 插入6->5

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003606.png)

   

{% note info %}

可以发现，在插入过程中，2-3树通过融合和分裂两个操作的多次使用，来保证树的绝对平衡。其情况可总结为以下4种

①插入一个2结点，**融合**

②插入一个3结点，且是根结点，先**融合**成一个4结点，再**分裂**成三个2结点

③插入一个3结点，其父亲结点是2结点，先**融合**成一个4结点，再**分裂**成三个2结点，再和父亲结点**融合**成一个3结点

④插入一个3结点，其父亲结点是3结点，先**融合**成一个4结点，再**分裂**成三个2结点，再和父亲结点**融合**成一个4结点，再**分裂**成三个2结点...

其实只要理解了**融合**和**分裂**两个过程，遇到具体情况再具体分析即可，不需要死记情况。

{% endnote %}

## 与2-3树等价的红黑树

### 😯从2-3树到红黑树

由于2-3树的结点并不统一，也就是2-3树的结点可能有1个元素或者2个元素，在实现上会比较复杂，于是尝试保持结点仍然只有1个元素，但是保持2-3树的思想，大体的做法是：对于2结点，不需要修改；对于3结点，将2个元素拆开，成为两个2结点；并以颜色区分2结点和3结点，2结点为黑色，3结点拆分出来的左侧（较小）的结点为红色，右侧的结点为黑色；这样实现出来的树称为红黑树。

![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003617.png)

### 🍉基本性质

在有了2-3树的基础之后，再来看《算法导论》这本书中对于红黑树的性质介绍，就比较容易理解了。

![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003626.png)

1. 所有的结点或者是红色，或者是黑色。这个是红黑树本身的定义
2. 根结点是黑色的。对于2-3树，它的根结点要么是2结点，要么是3结点，对于2结点，它本身就转化为黑色结点；对于3结点，我们将右侧作为父亲结点，左侧作为孩子结点，并且右侧为黑色，左侧为红色；因此根结点一定是黑色的
3. 所有叶子结点（**空结点**）都为黑色。此处的叶子结点是空结点，而不是左右子树为空的结点。当红黑树为空树时，由性质2，可知根结点为黑色，而此时根结点为空，因此也是性质3的体现
4. 红色结点的左右孩子结点都是黑色的。在2-3树中，从3结点分离出来的红色结点，它的子树根结点只能是2结点或3结点，而经过转化之后，这个子树的根结点只能变为黑色结点，参考性质2。因此红色结点的孩子结点都是黑色的
5. 从每一个结点到其叶子结点所经过的黑色结点数目是相同的。原因是2-3树是一棵绝对平衡的树，因此从一个结点到其叶子结点经过的结点数是相同的，而在转化成红黑树之后，无论是2结点还是3结点，都会转化出一个黑色结点

#### 题外问：为什么红黑树能保持O（logN）的复杂度？

因为红黑树的最大高度为2logN，出现在当有一条从根结点到叶子结点都是3结点的情况下，如果都是2结点，那么和平常的二叉树一样，都是logN，在全是3结点的时候，转化为红黑树时，一个3结点会成为一个红色结点和一个黑色结点，因此高度是2logN的，由于2是常数，在时间复杂度上仍然当作O（logN）级别。

### 🍓插入操作

红黑树也是一棵二分搜索树，因此插入操作的基本步骤是相同的，首先是查找要插入的位置，然后将新结点设置为红色，这一步的原因在于如果将新结点设置为黑色，就会导致从根到叶子的路径上多一个额外的黑色结点，难以调整，而连续的两个红色结点可以通过旋转和颜色翻转来调整。第三步是自下而上的调整树，使其仍为红黑树。

具体的调整分为以下几种情况：

1. 插入到黑色结点左侧：这种情况即相当于在2-3树中插入到2结点，融合形成3结点，而3结点转化成红黑树正好是左侧为红色、右侧为黑色，因此不需要调整

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003637.png)

2. 插入到黑色结点右侧：在2-3树中仍然是和2结点融合形成3结点，因此我们只需要考虑如何将其调整为3结点转化为红黑树之后的形态，而这一步调整根据我们在AVL树中的经验，可以使用**左旋转**来实现。

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003646.png)

   对应的代码为

   ```java
   private Node leftRotate(Node node){
       Node x = node.right; //42
       //左旋
       node.right = x.left;
       x.left = node;
       //颜色
       x.color = node.color; //当前子树的根结点从node变为x, 因此x的颜色需要变为node的颜色
       node.color = RED;//在2-3树中的3结点转化后,左侧的结点为红色结点
       
       return x;//返回子树新的根结点
   }
   ```

   

3. 插入到左孩子为红色结点的黑色结点右侧：左孩子为红色结点的结点对应于2-3树中的3结点，在其右侧插入新结点后，融合形成一个”4结点“，经过分裂成为3个2结点，也就是黑色结点，其中子树根结点需要保持原来的颜色(（红色）。因此整个过程等同于根结点和其孩子结点交换颜色，称为**颜色翻转**

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003656.png)

   ```java
   private void flipColors(Node node){
       node.color = RED;
       node.left.color = BLACK;
       node.right.color = BLACK;
   }
   ```

   

4. 插入到左孩子为红色结点的黑色结点左侧：相当于在2-3树中的3结点左侧插入一个新结点，为了构造出“4结点”分裂后的树，需要先经过一次**右旋**，由于根结点变为37，因此37需要保持原来根结点42的黑色，而42为了表示其作为“4结点”的一部分，需要变为红色。在经过右旋之后，就成为了情况3，因此之后需要经过一次**颜色翻转**

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003706.png)

   ```java
   private Node rightRotate(Node node){
       //node -> 42
       Node x = node.left; //37
       //右旋
       node.left = x.right;
       x.right = node;
       //颜色
       x.color = node.color;
       node.color = RED;
       
       return x;
   }
   ```

   

5. 插入到左孩子为红色结点的黑色结点中间：相当于在2-3树的3结点中间插入一个新结点，综合前面几种情况，可以比较快地构造出“4结点”分裂后的树，首先是先对37所在子树进行一次**左旋**，就得到了**情况4**，之后经过**右旋**，就得到了**情况3**，最后通过**颜色翻转**就可以调整为红黑树

   ![图片](https://gitee.com/jingshanccc/image/raw/master/image/20200722003716.png)

可以发现，情况4和5可以通过旋转转换为情况3，因此上述的5种情况，其处理的方式可以在统一的流程里实现，即总是经过左旋->右旋->颜色翻转就可以完成对树的调整。

{% note info %}

当前结点右孩子为红色结点，左孩子为黑色结点，需要左旋——对应情况2

{% endnote %}

{% note success %}

当前结点左右孩子都为红色结点，需要颜色翻转——对应情况3

{% endnote %}

{% note warning %}

当前结点左孩子为红色结点，左孩子的左孩子为红色结点，需要右旋——情况4

{% endnote %}

于是，在对红黑树进行插入操作的代码如下：

```java
public void add(K key, V value){
    root = add(root, key, value);
    root.color = BLACK; //保持根结点为黑色
}
private Node add(Node node, K key, V value){
    if(node == null){
        size ++; //维护结点数
        return new Node(key, value, RED);//新结点总是红色的
    }
    //二分搜索树的查找并插入
    if(key.compareTo(node.key) > 0){//插入到右子树
        node.right = add(node.right, key, value);
    }else if(key.compareTo(node.key) < 0){// 插入到左子树
        node.left = add(node.left, key, value);
    }else{
        node.value = value;
    }
    //维护红黑树
    if(isRed(node.right) && !isRed(node.left)){//右孩子为红色 左孩子为黑色
        leftRotate(node);
    }
    if(isRed(node.left) && isRed(node.left.left)){//左孩子和左孙子为红色
        rightRotate(node);
    }
    if(isRed(node.left) && isRed(node.right)){//左右都红
        filpColors(node);
    }
    
    return node;
}
```



## 参考文章

1. [数据结构之红黑树](http://dongxicheng.org/structure/red-black-tree/)
2. [liuyubobobo《算法和数据结构》](https://class.imooc.com/datastructure)
3. [算法导论](https://book.douban.com/subject/20432061/)

