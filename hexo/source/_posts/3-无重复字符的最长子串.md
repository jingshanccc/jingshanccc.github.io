---
title: 3. 无重复字符的最长子串
tags:
  - Leetcode
  - 滑动窗口
categories:
  - Leetcode
abbrlink: 4bff4329
---

> 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> **示例 1:**
>
> ```
> 输入: "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```

<!-- more -->

### 👊 暴力解法

只要我们知道了以每一个位置为开头的无重复最长子串，就可以求得整个字符串的无重复最长子串。这样的做法时间复杂度是O(n²)的。

过程：从一个位置开始，不断向后查找，当出现重复字符时，停下，记录子串长度。判断重复这里我使用一个HashSet来实现。

```java
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
        return 0;
    }
    //暴力的做法是：判断以每一个位置为起点的最长无重复字符
    int res = 0;
    for(int start = 0; start < s.length(); start++){
        HashSet<Character> set = new HashSet<>();
        set.add(s.charAt(start));
        for(int end = start+1; end < s.length(); end++ ){
            if(!set.contains(s.charAt(end))){
                set.add(s.charAt(end));
            }else{
                //res = Math.max(res,set.size());//由于可能只有一个字符，无法进入内层循环因此不能在这里更新
                break;
            }
        }
        res = Math.max(res,set.size());//在内层循环结束后更新
    }
    return res;
}
```

### ✍️ 优化

在上述的过程中，我们每次找完一个位置的子串之后就将之前的记录全部清除（` set = new HashSet<>(); `)，再次从起点 ` start ` 的下一个位置开始查找，导致时间复杂度是O(N²)级别的。其实当出现重复时，` [start...end) ` 左闭右开区间上，全都不是重复的，则` [start + 1...end) ` 也是不重复的，那么我们可以保留 ` end `位置，利用上一次记录的结果，不再从 ` start + 1 `的位置重新开始查找。这个过程我们就维护了一个**滑动窗口** ` [start...end) `.

```java
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
        return 0;
    }
    int n = s.length(), res = 0, right = 0, left = 0;
    Set<Character> set = new HashSet<>();
    while( left < n){
        if( right < n && !set.contains(s.charAt(right)) ){
            set.add(s.charAt(right));
            right ++;
        }else{
            res = Math.max(res, right - left);
            set.remove(s.charAt(left));
            left++;
        }
    }
    return res;
}
```

{% note success %}

更进一步的，当字符串中的出现字符的范围较小时，使用一个int数组来达到优化的效果。

{% fold 点击展开 %}

```java
public int lengthOfLongestSubstring(String s) {
    if(s == null || s.length() == 0){
        return 0;
    }
    int n = s.length(), res = 0, right = 0, left = 0;
    int[] record = new int[128];
    while( left < n){
        if( right < n && record[s.charAt(right)] == 0){//未重复,右移
            record[s.charAt(right++)] ++;
        }else{
            res = Math.max(res, right - left);
            record[s.charAt(left++)]--;
        }           
    }
    return res;
}
```

{% endfold %}

{% endnote %}

