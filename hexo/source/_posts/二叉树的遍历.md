---
title: 二叉树的遍历
tags:
  - 二叉树遍历
categories:
  - 笔记
image: 'https://gitee.com/jingshanccc/image/raw/master/image/20200722003318.png'
abbrlink: ea4681d0
---

<p/>

<!-- more -->

## 递归版

递归借用系统栈，在遍历时每个节点都会访问三次，因此只要在不同的时机打印出节点的值，即可完成三种遍历。

```java
public void recurTraversal(TreeNode node){
    if(node != null){
        System.out.print(node.val);//前序
        recurTraversal(node.left);
        System.out.print(node.val);//中序
        recurTraversal(node.right);
        System.out.print(node.val);//后序
    }
}
```

## 非递归版

1. 前序遍历：前序遍历的顺序是根-左-右，借助栈后进先出的特点，在压栈时先压右再压左，则出栈时先出左再出右。

   ```java
   public void preOrder(TreeNode node){
       if(node != null){
           Stack<TreeNode> stack = new Stack<>();
           stack.push(node); //根节点
           while(!stack,isEmpty()){
               node = stack.pop();
               System.out.print(node.val);
               if(node.right != null){
                   stack.push(node.right);
               }
               if(node.left != null){
                   stack.push(node.left);
               }
           }
       }
   }
   ```

2. 中序遍历：中序遍历的顺序是左-根-右。对于整个二叉树，最左的节点第一个被打印，因此我们从根节点开始，不断入栈左节点（第一次访问），当左节点为空时，说明走到了最左节点，出栈（第二次访问），将其右节点入栈。

   ```java
   public void inOrder(TreeNode node){
       if(node != null){
           Stack<TreeNode> stack = new Stack<>();
           while(!stack.isEmpty() || node != null){
               if(node != null){//还有左节点
                   stack.push(node);
                   node = node.left; //向左走
               }else{//没有左节点
                   node = stack.pop();
                   System.out.print(node.val);
                   node = node.right;
               }
           }
       }
   }
   ```

3. 后序遍历：后序遍历的顺序是左-右-根。前序遍历是根左右，我们将前序遍历中压栈顺序改为先压左再压右，则出栈顺序变为根右左，其逆序就是左右根。

   ```java
   public void postOrder(TreeNode node){
       if(node != null){
           Stack<Node> in = new Stack<>();
           Stack<Node> out = new Stack<>();
           stack.push(node);
           while(!stack.isEmpty()){
               node = in.pop();
               out.push(node);
               if(node.left != null){
                   in.push(node.left);
               }
               if(node.right != null){
                   in.push(node.right);
               }
           }
           while(!out.isEmpty()){
               System.out.print(out.pop().val);
           }
       }
   }
   ```

4. 层序遍历：逐层打印节点，借助队列实现。每个节点出队时将左右子节点入队，由于队列先进先出，将按入队顺序出队。

   ```java
   public void levelOrder(TreeNode node){
       if(node != null){
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(node);
           while(!queue.isEmpty()){
               node = queue.poll();
               System.out.print(node.val);
               if(node.left != null){
                   queue.offer(node.left);
               }
               if(node.right != null){
                   queue.offer(node.right);
               }
           }
       }
   }
   ```

   

