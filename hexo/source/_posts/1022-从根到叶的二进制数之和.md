---
title: 1022. 从根到叶的二进制数之和
tags:
  - Leetcode
  - 二叉树
  - 递归
  - 深度优先搜索
categories:
  - Leetcode
  - 二叉树
abbrlink: 39280e8c
---

> 给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。
>
> 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。
>
> 以 10^9 + 7 为模，返回这些数字之和。

<!-- more -->

{% note info %}

示例：

```java
输入：[1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```

{% endnote %}

### 💡 思路

树中的路径问题，可以使用深度优先搜索来解决。本题中，需要求每一从根节点到叶子路径组成的二进制数的和。深搜过程中，需要保存已经得到的当前路径，到达根节点的标志是左右子树都为空，将二进制转为十进制我最开始无耻地使用 ` Integer.parseInt(s,2) `，因为保存当前的路径直接用了字符串😂。

### 🧾 代码

```java
int sum;
public int sumRootToLeaf(TreeNode root) {
    dfs(root, "");
    return sum;
}
public void dfs(TreeNode root, String s){
    if(root == null){
        return;
    }
    s+=root.val;
    if(root.left == null && root.right == null){
        sum += (Integer.parseInt(s,2)%1000000007);
    }else{
        dfs(root.left, s);
        dfs(root.right, s);
    }
}
```

### 📈 优化

上面的方法，` Integer.parseInt `的方式本身耗时，并且每次都从头求，没有利用到之前的记录，因此效率较低。因此在二进制转十进制这一部分进行优化。

我们发现，每加上一个节点值，当前路径的二进制数左移一位，然后加上当前节点。举个例子：示例中，对于路径 `110 `，加入第一个节点值时当前节点二进制数为 ` 1 `，十进制为 1，第二个节点时，原来二进制数左移1位，对应于十进制乘2，为2，然后加上第二个节点值 1，得到 ` 11 `，十进制为3，第三个节点，左移1位，加上节点值，得到 ` 110 `，十进制为3*2+0.

```java
int sum;
public int sumRootToLeaf(TreeNode root) {
    dfs(root, 0);
    return sum;
}
public void dfs(TreeNode root, int cur){
    if(root == null){
        return;
    }
    cur = cur*2 + root.val;
    if(root.left == null && root.right == null){
        sum += cur;
    }else{
        dfs(root.left, cur);
        dfs(root.right, cur);
    }
}
```