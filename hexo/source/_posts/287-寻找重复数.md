---
title: 287. 寻找重复数
tags:
  - 数组
  - 二分查找
categories:
  - Leetcode
abbrlink: 25e6dcf4
---

> 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

{% note info %}

**示例 1:**

```java
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```java
输入: [3,1,3,4,2]
输出: 3
```

{% endnote %}

<!-- more -->

### 💡 思路

比较直接的想法有先排序再遍历（破坏输入）、hashSet去重（` O(n) `额外空间），都不是很好。

再仔细地分析题目，可以发现有两个重要的信息：数组长度为 ` n + 1 `、数字范围为` [1...n] `。应用排序的思路，数组的每一个位置上应该出现的数字为该位置下标+1，我们在遍历数组通过交换位置将数字放到应该在的位置的过程中，可以找出重复的元素，其具体表现为：当遍历到位置` i `时，如果当前位置的数字没有出现在应该在的位置（` nums[i] != i + 1 `），通过交换 `nums[i] `和 ` nums[nums[i] - 1] ` ，让数字出现在应该在的位置，而当位置（` nums[i] - 1 ` ）已经存放了正确的数字时，表示出现了重复。例如，对于数组` [1,1,2,2] `，当 ` i = 1 `时，` nums[1] = 1 != 1+1 `，需要交换位置，而此时，` nums[1] - 1 = 0 ` 位置上已经存放了正确的数字 ` 1 `，于是可以得到重复的数字为1。

### 🧾 代码

需要注意的是，在成功交换之后，需要重新判断位置` i `。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums == null || nums.length == 0){
            return -1;
        }
        //解法1：先sort再for
        // Arrays.sort(nums);
        // for(int i = 0 ; i < nums.length-1 ;i ++){
        //     if(nums[i] == nums[i + 1]){
        //         return nums[i];
        //     }
        // }
        
        //解法2：让元素去到其该去的位置
        for(int i = 0 ; i < nums.length; i++){
            if(nums[i] != i + 1){
                int temp = nums[nums[i]-1];
                if(temp == nums[i]){
                    return temp;
                }
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
                i--;//成功交换后需要重新判断位置i
            }
        }
        return -1;
    }
}
```

### 📈 二分法

（这道题能想到这个做法也是对二分查找运用得登峰造极了😂）

具体的做法是：左右边界分别为1和n。通过记录数组中小于等于中位数` mid ` 的个数，判断重复元素出现在左半部还是右半部，然后更新左右边界。例如：在数组` [3,1,2,2,4]`中`mid = 2 `，数组中<=2的有3个，因此重复的出现在` [1...2] `范围中；在数组` [3,1,2,3,4]` 中<=2的有2个,所以重复的出现在` [2+1,...4] `中。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums == null || nums.length == 0){
            return -1;
        }
        //二分-不断排除不会存在重复的一边
        int left = 1, right = nums.length-1;
        while(left < right){
            int mid = left + (right-left)/2;

            int count = 0; 
            for(int i : nums){
                if( i <= mid){
                    count ++;
                }
            }
            if(count > mid){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left;
    }
}
```

