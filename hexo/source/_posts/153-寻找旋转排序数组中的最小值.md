---
title: 153. 寻找旋转排序数组中的最小值
tags:
  - Leetcode
  - 数组
  - 二分查找
categories:
  - Leetcode
abbrlink: e3f3cf8a
---

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
> 请找出其中最小的元素。
>
> 你可以假设数组中不存在重复元素。

<!-- more -->

{% note info %}

**示例 1:**

```
输入: [3,4,5,1,2]
输出: 1
```

**示例 2:**

```
输入: [4,5,6,7,0,1,2]
输出: 0
```

{% endnote %}

### 👊 暴力解法

对数组进行遍历，找到比前一个位置元素小（**降序**）的位置，即为最小值。如果没有降序，意味着数组没有旋转，旋转点为最后一个位置。那么最小值将是第一个元素。

```java
public int findMin(int[] nums) {
    if(nums == null){
        return 0;
    }
    int min = nums[0];
    for(int i : nums){
        if(i < min){
            min = i;
            break;
        }
    }
    return min;
}
```

### ✍️ 二分查找

对于有序数组的查找问题，我们总是可以考虑采用二分来解决。二分的基本思路是：根据中间位置的元素和其他位置元素的大小关系，修改左右边界，达到减小区间（**减治**）的目的。在这个问题中，我开始的想法是让中间数和其左右位置比较，但很快就推翻了这个想法，因为这样的比较无法修改边界，也就无法达到减治的目的。~~其实数组中每个位置的元素，和其左右位置的关系都是相同的，都是大于其左边的小于其右边的。只有最小值的特征是相反的。~~（这是一段废话，人家本来就说是升序的数组）。不过解题的过程大多数时候是这样的，不断地试错，找到最正确的方法。

思考到这里，我们应该就可以想到让中间数和左右边界作比较。

{% note danger %}

中间数和左边界

- 当` nums[mid] < nums[left] `，能否确定最小值在左侧？——可以，此时说明区间` [left...mid] `出现了降序

- 当` nums[mid] > nums[left] `，能否确定最小值在右侧？——不能，当没有旋转的时候，最小值会在左侧

{% endnote %}

{% note success%}

中间数和右边界

- 当` nums[mid] < nums[right] `，能否确定最小值在左侧？——可以，此时说明区间` [mid...right] `保持升序

- 当` nums[mid] > nums[right] `，能否确定最小值在右侧？——可以，此时说明区间` [mid...right] `出现了降序

{% endnote %}

### 🧾 代码

经过上面的分析，我们可以尝试写出代码。二分法的代码过程，需要关注的点在循环终止条件以及最后返回什么。在这道题中，最小值一定在数组中，而我们一直在删去不可能存在最小值的区间，当区间只剩下一个元素，那么它一定是最小值。

```java
public int findMin(int[] nums) {
    if(nums == null){
        return 0;
    }
    int left = 0, right = nums.length - 1;
    while(left < right){//考虑终止条件
        int mid = left + (right-left) / 2;
        if(nums[mid] > nums[right]){
            left = mid + 1;// +1是因为mid一定不会是最小值
        }else{
            right = mid;
        }
    }
    return nums[left]; 
}
```

