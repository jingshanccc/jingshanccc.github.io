---
title: 572. 另一个树的子树
tags:
  - Leetcode
  - 二叉树
  - 递归
categories:
  - Leetcode
abbrlink: 689f55a9
---

> 给定两个非空二叉树 s 和 t ，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

<!-- more -->

{% note info %}

示例 1:

    给定的树 s:
    	 3
        / \
       4   5
      / \
     1   2
    给定的树 t：
    
       4 
      / \
     1   2
    返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
示例 2:

    给定的树 s：
    	 3
        / \
       4   5
      / \
     1   2
        /
       0
    给定的树 t：
       4
      / \
     1   2
    返回 false。
{% endnote %}

### 💡 思路

二叉树的问题，通常可以使用递归来求解，因为树本身具有天然的递归结构。通常的做法是，判断当前树/当前树的左子树/当前树的右子树是否符合条件。求解这类问题的时候，可以先不考虑具体的边界/递归终止问题，只需要先把框架写出来，用几个示例套入框架，可以较快地确定递归终止条件。

本题中，求一棵树是否为另一颗树的子树，根据上述的思路，可以先得到 ` return isSub(s, t) || isSubTree(s.left , t) || isSubTree(s.right, t); ` 这样的框架。然后我们需要写 ` isSub(s , t) ` 的逻辑，这个函数处理传入的两个树是否相等，需要满足以下三个条件：1. 节点值相等，即` s.val = t.val ` 2. 节点左子树相等，即` isSub(s.left, t.left) ` 3. 节点右子树相等，即` isSub(s.right, t.right) ` 。

### 🧾 代码

于是我们综合上面的过程，再套入示例（这个过程最好自己实操一下），确定边界和终止条件。可以写出如下的代码。

```java
 public boolean isSubtree(TreeNode s, TreeNode t) {
     //s当前节点-t, s.left-t, s.right-t
     if(t == null){
         return true;
     }
     if(s == null){
         return false;
     }
     return isSub(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}
public boolean isSub(TreeNode s, TreeNode t){
    if(t == null && s == null){
        return true;
    }
    if(s == null || t == null){
        return false;
    }
    if(s.val == t.val){
        return isSub(s.left , t.left) && isSub(s.right, t.right);
    }
    return false;
}
```

