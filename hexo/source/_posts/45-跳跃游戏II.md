---
title: 45. 跳跃游戏 II
tags:
  - Leetcode
  - 贪心算法
categories:
  - Leetcode
abbrlink: f579176b
---

>给定一个非负整数数组，你最初位于数组的第一个位置。
>
>数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>

<!-- more -->

{% note info %}

示例:

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

{% endnote %}

### 💡 思路

采用广度优先遍历的方式，记录从当前位置可以到达的所有位置，当可以到达最后一个位置时，返回结果。同时需要使用记录下一位置是否已经使用过用于**剪枝**，查找可以到达的下一个位置时，使用从大到小查找的**贪心**策略。

```java
public int jump(int[] nums) {
    if(nums == null || nums.length < 2){
        return 0;
    }
    int n = nums.length;
    //bfs找到最快到达n-1的
    Queue<Integer> queue = new LinkedList<>();
    queue.add(0);
    boolean[] used = new boolean[n];//记录是否使用过
    used[0] = true;
    int res = 0;
    while(!queue.isEmpty()){
        int size = queue.size();
        res ++;
        for(int i =0 ; i < size; i++){
            int index = queue.poll();
            for(int j = nums[index]; j > 0; j--){//从大到小,一种贪心,一定程度提高效率,没有这个策略会超时
                if(j + index >= n-1){
                    return res;
                }
                if(!used[j + index]){
                    queue.add(j + index);
                    used[j+index] = true;
                }
            }
        }
    }
    return 0;
}
```

### 📈 优化

上述过程中，每一次都把接下来可以到达的、未使用过的**所有**位置放入队列，因此我们可以考虑如何在所有位置中选出最优的位置，最优的依据是：当前位置的能够到达的所有位置中，能够到达最远的位置。听起来有点绕，看个例子：

> 对于示例 ` [2,3,1,1,4] `，从下标 0 开始，可以到达的所有位置是：下标 1 ，2。在1和2中，最优的位置是 1，原因是：` nums[1] = 3 `，即从下标 1 可以到达最远位置是 ` 1 + 3 = 4 ` ，而从下标 2 可以到达的最远位置是 ` 2 + 1 = 3 `。

根据这样的思路，其实很容易写成复杂度更高的，如果把找出最优位置的过程写成内层循环那就得不偿失了。那么还能通过什么方式来知道最优位置呢？答案是需要换个思路。我们的终止条件是到达数组**最后一个位置**，因此在查找过程中维护当前所能到达的最右边界，而最右边界的选取则采用上述的贪心策略。

` maxRight ` 记录位置 ` cur ` 能到达的最远位置,  ` [cur...end] `是所有能到达的下一位置，在这个区间内表示的是同一次跳跃，而当 ` cur ` 超过 ` end `时，表示这次跳跃能够到达的所有位置已经查找结束，因此 `step + 1 ` ，同时将 ` end ` 更新为 ` [cur...end] ` 所能到达的最远位置。

```java
public int jump(int[] nums) {
    if(nums == null || nums.length < 2){
        return 0;
    }
    int n = nums.length-1;//遍历到最后一个位置的前一个位置
    //贪心 
    int end = 0, maxRight = 0, step = 0 , cur = 0;
    while( end < n){
        maxRight = Math.max(maxRight, cur + nums[cur]);
        if(cur == end){
            end = maxRight;
            step++;
        }
        cur ++;
    }
    return step;
}
```

