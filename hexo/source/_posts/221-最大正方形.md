---
title: 221. 最大正方形
tags:
  - Leetcode
  - 动态规划
categories:
  - Leetcode
abbrlink: 37cbfc16
---

> 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
>
> 示例：
>
> ```java
> 输入：
> 1 0 1 0 0
> 1 0 1 1 1
> 1 1 1 1 1
> 1 0 0 1 0
> 
> 输出: 4
> ```

<!-- more -->

### 💡 思路

在二维数组求解比较容易想到**动态规划**的思想，可能主要是机器人运动范围和岛屿数量这类问题的原因。于是开始考虑 ` dp[i][j] `代表什么，由于题目求只包含 1 的最大正方形，因此可以考虑让 ` dp[i][j] `代表以该位置为**右下角**的最大正方形**边长**。右下角是由于动态规划思想从之前的结果推得这次的结果，那么右下角就是最后离开这个正方形的地方。边长是由于可以通过边长求得面积。

接下来考虑递推关系式，当当前位置为 0 时，` dp[i][j] ` 也为0，因为没有以这个位置为右下角的正方形。当当前位置为 1 时，就比较复杂，需要一波分析。分析也不是毫无头绪和方向的，在二维数组的动态规划问题中，一般只有三个位置需要考虑，左侧、上方、左上角。

## 🧾 代码

```java
public int maximalSquare(char[][] matrix) {
    if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
        return 0;
    }
    int max = 0;
    int n = matrix.length, m = matrix[0].length;
    int[][] dp = new int[n][m];
    for(int i = 0; i < m; i++){
        dp[0][i] = matrix[0][i] == '1' ? 1 : 0;
        max = Math.max(max, dp[0][i]);
    }
    for(int i = 0; i < n; i++){
        dp[i][0] = matrix[i][0] == '1' ? 1 : 0;
        max = Math.max(max, dp[i][0]);
    }
    for(int i = 1; i < n; i++){
        for(int j = 1; j < m; j++){
            if(matrix[i][j] == '0'){
                dp[i][j] = 0;
            }else{
                dp[i][j] = Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]))+1;
                max = Math.max(max, dp[i][j]);
            }
        }
    }
    return max*max;
}
```

