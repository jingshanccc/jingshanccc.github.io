---
title: 704. 二分查找
date: '2020-04-30 19:50'
tags:
  - Leetcode
  - 二分查找
categories:
  - Leetcode
abbrlink: 41f30363
---

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

<!-- more -->

{% note default %}

示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1

{% endnote %}

### 💡 思路

 ~~不用什么思路，直接二分就完了~~😝

##### 二分基本步骤

1. 确定左右边界，考虑开闭区间。这里我的左右边界分别是 ` left = 0 `，` right = nums.length - 1 `，形成一个` [left ... right] `的左闭右闭区间。你也可以使用其他的边界类似 ` right = nums.length `等，**最重要的是**你要知道你所定义的这些变量，在运行过程中代表什么，如何变化。
2. 确定循环终止条件，考虑跳出循环的时候，` left ` 和 ` right ` 的关系，返回时的处理。
3. 通过中间位置的数 `nums[mid] ` 与 `target ` 的大小关系，修改边界，缩小区间，达到**减治**的目的。这里介绍下 `mid` 的几种求法。

{% note info %}

` int mid = (left + right) / 2 `：当` left ` 和 ` right ` 值太大时，`left + right ` 会溢出，导致结果不正确

` int mid = left + (right - left) / 2 `：通常使用这种。

` int mid = left + (right - left) >> 1 ` ：有一种说法是位运算比四则运算更快，但是其实优秀的编译器会帮我们做这步优化，因此使用第二种即可。

` int mid = (left + right) >>> 1 `：即使产生溢出，无符号右移也可以返回正确的结果。但是不够直观，影响代码的可读性。

{% endnote %}

### 🧾 代码

```java
public int binarySearch(int[] nums, int target){
    if(nums == null || nums.length == 0){
        return -1;
    }
    int left = 0, right = nums.length - 1;
    while(left <= right){//循环终止条件left>right,区间长度<0,表示不存在target
        int mid = left + (right-left) / 2;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] < target){
            left = mid + 1; //±1 -- 因为mid已经被排除
        }else {
            right = mid - 1;
        }
    }
    return -1;
}
```

