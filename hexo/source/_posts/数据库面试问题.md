---
title: 数据库面试问题
tags:
  - Java后端面试
  - 数据库
  - Mysql
categories:
  - Java后端面试
abbrlink: 1f02b5ce
image: 'https://gitee.com/jingshanccc/image/raw/master/image/20200722004639.jpg'
---

<p/>

<!-- more -->

## 事务的概念和特性？

概念：事务是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。

特性

1. 原子性：事务中的所有操作，要么全部成功提交，要么全部失败回滚。逻辑上是不可分割的操作单元。事务的回滚通过回滚日志undolog实现。
2. 一致性：事务的执行必须使数据库保持一致性的状态。在一致性状态下，所有事务对同一数据的读取结果相同。
3. 隔离性：事务在提交之前对数据所做的修改对其他事务是不可见的。并发执行的事务互不影响。
4. 持久性：成功提交的事务对数据所作的修改是永久的。

### 如何保证原子性和持久性？

通过引入undo log来实现事务的原子性。undo log记录数据被修改前的值，通常是逻辑日志，记录每一行的修改记录。当事务执行过程中出现宕机/需要回滚，则通过undo log将数据恢复。当事务结束时，undo log不会立刻清除，而是放入待清理的链表，由purge线程判断是否有其他事务正在使用undo log中记录的表的上一个事务之前的版本信息，决定是否删除。

由于undo log会被删除，因此引入redo log来保证事务的持久性。

redo log记录修改后的数据，通常是物理日志，记录发生修改的数据页。在事务提交之前写入磁盘，即使事务提交过程中宕机，也可以通过redo log将事务执行结果刷新到数据库。未提交/回滚的事务也会记录在redo log中。

## 会发生哪些并发一致性问题？

1. 丢失修改：一个事务对数据做了修改，在事务提交之前，另一个事务也对同一个数据做了修改，则第一个事务的修改丢失了。
2. 脏读：一个事务读到另一个事务未提交/回滚的修改。
3. 不可重复读：在同一个事务中，某个查询语句读取某行数据和之后再次读取该行数据得到不同的结果，数据已经发生修改。
4. 幻读：当同一查询执行多次，由于其他事务在这个范围内执行了插入操作，导致每次返回不同的结果集。

## 数据库的四种隔离级别？

1. 读未提交：在一个事务提交之前，它的执行结果对其他事务是可见的，会出现脏读、不可重复读、幻读。
2. 读已提交：一个事务只能看见已经提交的事务的执行结果。解决脏读，会出现不可重复读、幻读。
3. 可重复读：可以确保同一个事务在多次读取某一数据返回相同的结果。解决脏读、不可重复读，会出现幻读。
4. 串行化：强制事务串行执行，使事务之间不可能相互冲突，解决幻读问题。

## 什么是乐观锁和悲观锁？

1. 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会对数据上锁，防止其他事务读取和修改数据。应用于数据更新频繁的场景

2. 乐观锁：操作数据时不会上所，但是更新时会判断在此期间有没有其他事务修改了数据，若被修改过，则失败重试。适用于读多写少的场景。

   {% note info %}

   1. 加一个版本号或时间戳字段，在数据更新时同时更新这个字段
   2. 先读取想要更新的字段或者所有字段，只有在字段没有变化才执行更新

   {% endnote %}

## 常见的封锁类型

> **封锁**：是指事务对某个数据操作之前，先向系统发出请求，对其加锁。加锁之后事务就对该数据有了一定的控制。

1. 排它锁：又称写锁。在事务对数据加上排它锁后，只允许该事务读取和修改数据，并且其他事务不能再对数据加任何锁

2. 共享锁：又称读锁。事务对数据加上共享锁后，拥有了读取数据的权限，但是不能修改数据。其他的事务可以再对数据加共享锁不能加排它锁

3. 意向锁：分为意向排它锁和意向共享锁。

   {% note info %}

   一个事务在获取某个数据行的共享锁之前，必须先获得整个表的意向共享锁或者更强的锁。

   一个事务在获得某个数据行的排它锁之前，必须先获得整个表的意向排它锁。

   优点：如果一个事务想要对整个表加排它锁，需要先检测有没有其他事务已经获取了表的排它锁，再检测每一行有没有被加上排它锁，整个过程非常耗时。有了意向锁之后，只需要检测整个表是否被加上意向排它锁即可。

   {% endnote %}

### 封锁粒度

{% fold 查看 %}

Mysql提供了两种封锁粒度：行级锁和表级锁。

封锁力度小表示锁定的数据单元越少，发生锁竞争的可能就越小，系统支持的并发程度越高，但是会增加系统开销，加解锁、检查锁都需要消耗资源。

InnoDB在查询时如果where子句不走索引的话，就会进行全盘扫描，此时将使用表级锁，保证查询结果的正确。

{% endfold %}

### 什么是三级封锁协议？

1. 一级封锁协议：事务在修改数据之前必须先对其加排它锁，直到事务结束才能释放。解决了丢失修改问题（如果一个数据正在被修改，那么其他事务无法修改该数据，因此原事务的执行结果不会被覆盖）
2. 二级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，读完即可释放。可以解决脏读问题（如果一个数据正在被修改，此时其他事务无法读取该数据，所以在修改事务提交之前修改结果不可见）
3. 三级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，直到事务结束才能释放。可以解决不可重复读问题（如果读取事务读取数据后就释放，在事务未结束时其他事务可以加排它锁来对数据进行修改，读取事务再次读取数据时，则会读到被修改的数据。三级封锁协议可以保证在整个读取事务期间数据不会被修改）

### 什么是两段锁协议？

> 事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。在事务释放锁之后，就不能再申请加锁。

两段锁协议可以保证事务满足可串行化调度，也就是并发执行的事务结果与某个串行执行的事务结果相同。

## 什么是MVCC？

MVCC是指多版本并发控制，INNODB的MVCC，通过在每行记录后保存两个隐藏的列来实现，记录了创建时间和删除时间。这里并不是记录时间戳，而是记录事务版本号。每开启一个事务，系统的版本号就会递增。创建时间的列记录了创建时的事务版本号，删除时间的列记录了删除时的事务版本号。

执行插入操作时，在新创建的行中记录创建版本号；删除操作时记录删除版本号；更新时先在原数据行记录删除版本号，再新增一行并记录创建版本号；在进行查询的时候，只查找创建版本号小于当前事务版本号以及未定义删除版本号和删除版本号大于当前事务版本号的行，这样可以保证已被创建和未被删除。

### 如何实现读已提交和可重复读？

读已提交，每次查询都会重新生成readview，readview中有尚未提交的版本号，根据查询的记录的版本号，找到可见的版本号。由于每次查询都会重新生成readview，因此在事务执行过程中，如果有其他的事务完成了提交，再次查询，就会读到不同的数据，也就出现了不可重复读。

可重复读，只会在事务的第一次查询生成一个readview，沿用到事务结束，因此可以解决不可重复读。

## 数据库的范式

1. 第一范式：属性是不可分的。
2. 第二范式：非主属性**完全依赖**于主属性。消除非主属性对主属性的部份依赖。B完全依赖于A表示A中的所有属性唯一确定B。
3. 第三范式：非主属性**直接依赖**于主属性，消除传递依赖。
4. 第四范式：在第三的基础上，每个列不允许有多值，比如移动电话列不允许该用户有两个手机号。
5. 第五范式：#。
6. BCNF：修正的第三范式，消除主属性之间的传递依赖。

{% fold 不符合范式会出现哪些问题？ %}

数据冗余：相同的数据重复出现。

插入异常：无法插入一个还没有课程信息的学生

修改异常：修改了一个记录中的信息，相同的信息却没有被修改

删除异常：删除一个信息，丢失其他信息，删除一个课程，将课程的学生也删除了。

{% endfold %}

## 主键、超键、候选键、外键分别是什么？

1. 超键：在关系中能唯一标识元组的属性集称为关系模式的超键
2. 候选键：不含有多余属性的超键称为候选键，也就是候选键中不能再删除任何一个属性
3. 主键：用户选作元组标识的候选键
4. 外键：在关系模式R中的属性K是其他关系模式的主键，则K是R的外键

> 主键是候选键的子集，候选键是超键的子集。

## 列举几种表连接的方式？

1. 内连接：` [inner] join ` ，只查询出两表中符合查询条件的行信息。

2. 外连接

   {% note info %}

   左外连接：` left [outer] join `，左边的表不加限制，将所有行信息都显示，右表没有匹配的用null补上。

   右外连接：和左外连接相反。

   全外连接：` full [outer] join `，左右两表都不加限制，将两表所有记录都显示，不匹配的用null补上。

   {% endnote %}

3. 交叉连接：` cross join ` ，不带` where ` 子句时，返回笛卡尔积。带` where ` 子句先生成笛卡尔积，再在其中找满足条件的。

## delete/drop/truncate的区别

1. delete是DML语句，逐行的删除数据，并会记录日志，事务提交之后才真正执行。执行速度较低。
2. truncate是DDL语句，删除整个表的数据，不会记录事务日志，隐式提交。通过释放数据页的内存来删除数据。
3. drop是DDL语句，将删除整个表的结构和数据，隐式提交

如果删除和事务有关，则要使用delete，如果和事务无关，则选择truncate，如果要删除整个表，就使用drop

## 存储过程、触发器、视图、约束

1. 存储过程是一段事先经过编译并存储在数据库的sql语句，类似于函数，通过调用这个函数获得输出结果。

   {% note info %}

   优点：

   预先编译，提高了执行效率。

   封装了一系列操作，对于数据交互比较多的操作，可以减少网络通信量。

   可复用，安全性高。

   {% endnote %}

2. 触发器是由插入/删除/更新操作触发的操作，不能被直接调用，没有参数，用于保证数据的完整性。

3. 视图是从数据库基本表中通过查询选出数据组成的虚拟表。对视图的修改不影响基本表。

4. 约束有多种类型，主键约束、唯一约束、非空约束、外键约束

## 为什么要使用索引？使用索引的好处？

1. 加快数据的检索速度，避免全盘扫描。
2. 可以显著减少查询中分组和排序的时间，因为如果order by的字段本身就是索引，那么它已经是有序的。
3. 通过创建唯一性索引，可以保证数据表中每一行的唯一性
4. 将随机I/O变为顺序I/O，B+树索引会把相邻的数据存储在一起

**缺点**：建立和维护索引耗费空间和时间

## B+树索引的优势

和**B树**相比：

1. m阶B+树所有非叶子节点都有m个子树指针，B树最多有m个子树指针，因此B+树的高度会更低。并且B+树的非叶子节点只存放关键字，B树还会存放数据，因此B+树I/O次数更少。
2. 在进行范围查询时，由于B+树的所有数据都在叶子节点，并且叶子节点之间有指针，因此直接遍历叶子节点即可，而B树需要中序遍历整棵树
3. B+树的查询效率更加稳定，每次都需要从根节点到叶子节点

和**hash索引**相比：

1. 哈希索引虽然可以以O(1)时间进行查找，但是只支持精确查找，并且在大量哈希值相等的情况下，查询效率会降低

## 哪些情况下索引会失效？

1. 以“%”开头的LIKE语句
2. OR语句前后没有同时使用索引
3. 数据类型出现隐式转化
4. 对于复合索引，必须满足最左匹配原则
5. 在数据量小的表中，Mysql可能判断全盘扫描更快。

### IN、运算、IS NULL等会不会走索引？

1. IN：会，但是范围大就不会走索引，会全盘扫描，not in不走索引
2. 运算：不会，因为太复杂，如果要实现那么数据库需要维护非常多复杂的计算之后的比较信息
3. IS NOT NULL不管什么情况下都不会走索引，IS NULL在字段允许为空时会使用索引

## 哪些地方适合创建索引？

经常被查询、作为表连接、ORDER BY、GROUP BY的字段。数据量小的字段、非空的字段。

## 索引分类

1. 功能类：普通索引、唯一索引、主键索引、覆盖索引（索引包含了要返回的值因此不用回表）
2. 按列分：单列索引、符合索引
3. 聚集索引和非聚集索引：聚集索引的顺序决定了数据的物理顺序，因此一张表只有一个聚集索引。非聚集索引只存放数据的逻辑地址。

## 存储引擎InnoDB和MyISAM的区别

1. InnoDB支持事务、外键、行级锁和表级锁，MyISAM支持表级锁。
2. MyISAM支持压缩表，需要的内存空间更小，但是压缩后只读，更新操作需要解压后执行。
3. InnoDB支持在线热备份

### 应用场景

MyISAM管理非事务表，提供高速存储和检索，对于数据量小，或者只读数据，使用MyISAM效率更高。InnoDB支持事务，在并发下有更好的性能。

### 热备份和冷备份

热备份：在数据库运行期间完成快照备份。备份时数据库仍可提供服务

冷备份：数据库关闭后，将数据文件复制到另一位置的备份方式

## 如何优化数据库？

1. SQL优化

   {% note info %}

   分析慢查询日志，查看查询时间长、IO多的SQL语句，针对性的优化

   使用explain分析，查看表的读取顺序、使用了哪些索引、扫描行数。

   通过写出需要的列返回必要的列，避免使用select *

   通过limit限制返回的行数

   将一次大的复杂的多表查询分解成简单的单表查询

   {% endnote %}

2. 索引优化：避免索引失效、在合适的地方创建索引

3. 表结构优化：遵循三大范式来进行表设计。数据量大时可以进行表切分

### 垂直切分和水平切分

{% note info %}

垂直切分：按业务来切分数据库，相同的业务表存放在同一个数据库节点。垂直切分减少了单节点数据库的负载，原来只有一个数据库，所有业务读写请求都在同一个节点，负载太高。但是对于那些单表数据量就巨大的表（比如商品表、订单表），即使切分到一个数据库，仍然容易造成性能降低。

水平切分：按表中的字段的规则（主键求模、主键范围、日期）把数据切分到不同的数据表，达到缩表的目的。

先进行水平切分，因为水平切分不需要修改整个系统架构，做业务模块的拆分，工作量小。

{% endnote %}

## 什么是主从复制？实现原理是什么？

主从复制是指数据可以从一个Mysql数据库主服务器复制到其他的从服务器。

通过三个线程来实现：

1. 主服务器binary log dump 线程：将主服务器中的数据更改记录到bin log日志中
2. 从服务器I/O线程：负责从主服务器读取bin log，并写入本地的relay log
3. 从服务器SQL线程：负责读取relay log，解析出主服务器的数据更改，并在从服务器上重放，实现主从数据的一致性。

### 为什么要主从复制？

1. 读写分离：主服务器负责写，从服务器负责读。缓解锁竞争，即使主服务器的数据被加了锁，从服务器依然可以处理读请求。从服务器可以采用MyISAM提高查询性能，节省存储空间。
2. 提高系统的可用性，当某个节点出现故障，可以进行故障切换保证服务。
3. 数据实时备份
