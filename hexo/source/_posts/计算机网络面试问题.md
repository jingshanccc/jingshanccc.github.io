---
title: 计算机网络面试问题
tags:
  - Java后端面试
  - 计算机网络
categories:
  - Java后端面试
image: 'https://gitee.com/jingshanccc/image/raw/master/image/20200722003754.jpg'
abbrlink: f4828e27
---

<p>

<!-- more -->

## 计算机网络体系结构

{% note info %}

OSI标准是七层模型，TCP/IP中是四层模型

​    **物理层**：完成数模转换和模数转换。网卡

​    **数据链路层**：有错误检测和纠正机制。交换机，ARP协议

​    **网络层**：解决不同子网的通信问题。路由器，RIP协议

​    **传输层**：保证数据段有效到达对端。TCP,UDP协议

​    **会话层**：不同实体建立和使用连接（会话）。全双工、半双工、单工

​    **表示层**：数据的表示方式。编解码、加解密、压缩

​    **应用层**：为用户直接提供服务。FTP(21)、SSH(22)、SMTP和POP3、HTTP(80)、DNS(53)

{% endnote %}

### 什么是RIP协议？

RIP是距离矢量路由协议，每个路由器维护一张表，记录自己和其他路由器之间的距离，在进行路由的时候优先选择距离短的。通过和相邻路由器交换信息更新表。

### IP地址的分类

IP地址由网络号和主机号组成，共四个字节。根据网络号所占的字节数划分为ABCDE五类网。A类网网络号占一个字节，B类占两个字节，以此类推。

<details>
    <summary>子网划分</summary>
    从主机号借用若干位成为子网号，数据报仍根据网络号找到目的网络，由路由器根据网络号和子网号找到目的子网，通过子网掩码和目的地址逐位与操作，得到子网地址。
</details>


### 什么是ARP协议

ARP是地址解析协议，完成了IP地址到物理地址的映射。每一个主机都有一张高速缓存映射表，里面记录了所在局域网内的其他主机和路由器的IP地址和物理地址。当主机需要发送数据包时，将查找自己的ARP缓存，如果能找到目的主机的记录，则直接发送，否则将向所在局域网广播一个ARP请求包，包含自己和目的主机的IP和MAC地址。收到请求的主机将检查自己是不是目的主机，如果是则保存源主机的IP和MAC地址，然后向源主机发送ARP响应，包含自己的IP和MAC地址。如果源主机请求的目的地址不在当前网络，将通过路由器转发到其他局域网进行查找。

### 什么是NAT？

NAT是网络地址转换，由NAT路由器将内网中的本地主机IP转换为全球IP地址，让内网中的主机和因特网中的主机进行通信。

## 什么是三次握手？

{% note info %}

三次握手是遵循TCP协议的通信双方建立连接的过程。

第一次握手：客户端发起连接请求，发送SYN=1，初始化序列号为x的数据包给服务端，进入SYN_SENT状态。

第二次握手：服务端接收请求连接报文，并发送确认包，确认序列号为x+1，同时将SYN位置1，并初始化自己的序列号为y发送给客户端，进入SYN_RECV状态。

第三次握手：客户端接收到确认和请求连接报文，检查确认标志位ACK是否为1，确认序列号是否为x+1，检查正确后，发送确认报文，确认序列号为y+1，进入established状态。服务端接收到确认报文，检查ACK和ack number正确后，进入established状态。三次握手结束，连接建立。

{% endnote %}

### TCP建立连接可以两次握手吗？

{% fold 查看答案 %}

不可以，主要有以下两个原因。

- 两次握手容易造成服务端连接资源浪费的情况，当客户端发送的第一次握手消息由于网络等原因延迟了，客户端会重新发送握手消息，然后成功完成通信并释放连接。此时延迟的握手消息到达了服务端，如果只有两次握手，服务端再接收到这个消息时就会发送确认并建立连接等待接收客户端的数据，但此时客户端并没有想要建立连接，因此服务端的连接资源也就白白浪费了。采用三次握手则可以避免这种情况。

- 三次握手可以确保通信双方成功互换初始序列号，这是后续通信时确认应答和超时重传的基础，保证TCP的可靠性。

{% endfold %}

### 初始序列号是什么？

{% fold 查看答案 %}

发起连接的一方会生成一个32位的序列号作为初始序列号发送给对端，对端也会发送自己的初始序列号。初始序列号作为原点，对要传输的数据进行编号。根据发送序列号和确认序列号，发送方可以知道接收方已确认接收的数据，接收方可以验证哪些数据编号是合法的。

{% endfold %}

### 序列号回绕如何解决？

由于初始序列号是随机生成的，因此在传输过程中，可能出现序列号回到0的情况，称为回绕。因为TCP判断丢包和乱序是通过序列号大小来判断的，因此需要解决回绕问题。内核处理回绕的解决方案是` (__s32)(seq1-seq2) < 0;`，将相减结果转为有符号数，如果发生了回绕，转为的有符号数小于0。

### TCP建立连接可以四次握手吗？

{% fold 查看答案 %}

可以，其实三次握手中的第二次握手，服务端将确认和请求连接的消息放在一个报文里，将这个过程拆分成两次握手，就是四次握手。但是这样也浪费了资源

{% endfold %}

### 第三次握手中，如果客户端的ACK未到达服务端，会怎样？

{% fold 查看答案 %}

服务端如果没有接收到客户端的确认，则会重传第二次握手消息，默认可重传5次，如果都没有接收到确认，就进入CLOSED状态；如果接收到确认，就建立连接。

服务端进入CLOSED状态之后，再接收到客户端的数据，将会以RST包响应。

{% endfold %}

### 建立连接后，如果客户端出现故障，会怎样？

{% fold 查看答案 %}

服务端每接收到客户端一个报文之后，就会重置自己的计时器，通常是两小时，如果在这期间都没有接收到客户端的数据，则会发送一个探测报文，之后每隔75秒发送一次，如果发送了10次都没有响应，则判断客户端出现故障，就会关闭连接。

{% endfold %}

## 什么是四次挥手？

{% note info %}

四次挥手是遵循TCP协议的通信双方释放连接的过程

第一次挥手：客户端完成了数据的传输，发起释放连接请求，FIN=1，序列号为x，进入FIN_WAIT1状态。

第二次挥手：服务端接收到请求后，发送确认报文，进入CLOSE_WAIT状态。客户端接收到确认报文后，进入FIN_WAIT2状态。

第三次挥手：服务端也完成了数据的发送，发送释放连接报文，进入LAST_ACK状态。

第四次挥手：客户端接收到释放连接请求，发送确认报文，进入TIME_WAIT状态，等待2MSL时间后，释放连接，进入CLOSED状态。服务端接收到确认报文后，释放连接，进入CLOSED状态。

{% endnote %}

### 为什么不能三次挥手？服务端的CLOSE_WAIT状态有什么意义？

{% fold 查看答案 %}

客户端发起释放连接的请求只能确认客户端没有数据要进行传输了，但此时服务端可能还有未发送的数据，CLOSE_WAIT状态用来等待服务端数据也发送完毕再释放连接。

{% endfold %}

### TIME_WAIT状态的意义？

{% fold 查看答案 %}

第四次挥手，客户端的ACK可能会丢失，TIME_WAIT状态用来重发可能丢失的ACK。如果服务端没有接收到ACK，则会重发FIN报文。TIME_WAIT的时长是2MSL，MSL就是报文段在网络中的最长存活时间。客户端的ACK在一个MSL内没到达服务端，服务端就会重发FIN，这个重发的FIN最长存活时间也是MSL，那么在2MSL时间内都没有接收到服务端重发的FIN，则认为ACK已经成功到达服务端。

{% endfold %}

### 出现大量TIME_WAIT状态？

{% fold 查看答案 %}

在高并发短连接的TCP服务器上，由于业务处理和数据传输的时间**远小于**TIME_WAIT超时时间，因此当服务器处理完请求后立刻主动正常关闭连接，就会出现大量TIME_WAIT状态。这是会占用这服务器的资源，因为端口是**有限**的，所以并发高时会有部分客户端无法连接到服务器

{% endfold %}

## TCP如何进行流量控制？

{% note info %}

使用滑动窗口协议来实现流量控制。接收方根据自己缓冲区的情况，动态调整接收窗口大小，并将接收窗口大小放在ACK报文中发送给发送方。发送方的发送窗口大小不能超过接收窗口，防止发送速率太快，接收方缓冲区不够导致溢出。当发送方接收到确认之后，将窗口向右滑动。

{% endnote %}

### 什么是”零窗口“？

当接收方无法接受新数据时，就会将接收窗口大小设为0，发送方将会停止发送数据，并通过1字节大小的探测报文来检查接收窗口的变化，当接收窗口>0时，就恢复数据发送。

## TCP如何进行拥塞控制？

拥塞控制主要通过四个算法实现，分别是慢开始、拥塞避免、快重传、快恢复。

![拥塞控制](https://gitee.com/jingshanccc/image/raw/master/image/20200722003811.jpg)

{% note info %}

**慢开始**：刚开始发送数据时，将拥塞窗口大小设置为1MSS，最大报文段长度，之后每收到一个确认ACK，就将窗口增大1个MSS，这样窗口大小随着传输轮次呈指数增长。

**拥塞避免**：当慢开始执行到窗口大小等于慢开始门限时，将减缓窗口增大速度，每个传输轮次线性增长。

**快重传**：快重传要求接收方在接收到一个失序的报文段后立即发出重复确认。当发送方连续接收到三个重复确认，就要立即重传失序的报文段而不必等待为该报文段设置的重传计时器的超时。

**快恢复**：当发送方接收到三个重复确认时，就把慢开始门限减小为此时拥塞窗口的一半，然后执行拥塞避免算法。

出现**重传**的两种情况：

超时未接收到ACK：发送方在发送完一个报文段时，会启动一个计时器，当超时未接受到ACK时，则会重新传输该报文段。在这种情况下，发送方认为网络状况不佳，因此将慢开始门限设置为拥塞窗口的一半，拥塞窗口设置为初值，重新执行慢开始算法。

接收到3个重复确认：此时由于可以接收到3个重复确认，因此网络没有出现拥塞，此时将慢开始门限减小为拥塞窗口的一半，但可以适当增大拥塞窗口，然后执行拥塞避免算法。

{% endnote %}

## TCP和UDP的区别？

{% note info %}

TCP面向连接，UDP面向无连接，即UDP传输数据前不需要建立连接

TCP是可靠的，UDP是不可靠的，因为UDP接收方不需要发送确认，也就没有确认重传等机制

TCP有拥塞控制，在网络拥塞时控制发送速率，UDP不会因为网络的拥塞而减小发送速率，这在实时应用中是很重要的

TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多

TCP是面向字节流的，一个数据包可以以字节为单位拆分成多个组发送，UDP是面向数据报文的，一个报文只能一次发完。

TCP的报文首部20字节，比UDP8字节开销更大。

{% endnote %}

### 什么时候使用TCP，什么时候使用UDP？

在实时性要求高、可以容忍传输错误的应用中，如直播、游戏、即时通信，使用UDP。其他情况使用可靠的TCP。

### HTTP可以使用UDP吗？

以前来说不可以，HTTP需要可靠的传输协议，UDP不可靠。而新的HTTP/3基于QUIC协议（Quick UDP Internet Connection），不再使用TCP，在UDP的基础上增加拥塞控制和可靠性等。

## TCP如何保证传输的可靠性？

{% note info %}

奇偶校验和：检查数据包是否出错

乱序重排：正确接收数据

丢弃重复包：正确接收数据

确认应答机制：发送确认让发送方知道数据已被成功接收

超时重传机制：未被接收的数据重新发送

流量控制：控制发送速率避免接收方缓冲区发生溢出

{% endnote %}

## HTTP和HTTPS的区别？

{% note info %}

HTTP默认使用80端口，HTTPS使用443端口

HTTP使用明文传输，HTTPS运行于SSL协议之上，有加密和认证机制，更加安全

HTTPS加解密过程需要消耗更多的CPU和内存

HTTPS需要向证书颁发机构CA购买证书

{% endnote %}

### HTTPS建立连接的过程？

{% fold 查看答案 %}

- 浏览器向服务端发送连接请求，消息内容包含自己支持的加密规则（对称加密、非对称加密、摘要算法）
- 服务端接收到请求后，选择一套加密规则，生成非对称加密的公钥，和证书一起发送回浏览器
- 浏览器验证证书的有效性，随机生成用于对称加密的密钥，使用服务端的公钥加密生成密文，通过摘要算法生成摘要，一起发送给服务端
- 服务端使用私钥解密消息，通过摘要算法验证数据完整性，得到浏览器生成的密钥，然后使用密钥加密消息，并生成摘要发送给浏览器。
- 浏览器接受后使用密钥解密消息并验证完整性，成功之后，连接建立，接下来使用密钥加密数据传输保证安全性。

{% endfold %}

### 直接输入 www.baidu.com , 是如何转为HTTPS的？

{% fold 查看答案 %}

通过重定向和HSTS机制，实现从HTTP到HTTPS的转换。

打开浏览器的调试界面，可以看到直接使用 http://www.baidu.com 时，服务端会发回307响应，在响应头中的LOCATION指定重定向的地址为 https://www.baidu.com ，然后浏览器重新向该地址发起请求。服务端在响应头中携带Strict-Transport-Security字段，设置过期时间，在这段时间内，再次请求该地址，浏览器会自动转换为HTTPS。

{% endfold %}

## GET和POST的区别

{% note info %}

GET一般用于向服务端获取资源，POST可能会对服务端资源进行修改。因此GET具有幂等性，即每次请求相同的URL会获得相同的响应，POST不具有幂等性。

GET的请求参数附在URL上，在请求头中，POST的请求参数放在请求体中。

由于浏览器或服务器对URL长度限制，因此GET的请求参数不能过长，而POST则没有限制

{% endnote %}

## Cookie和Session的区别

{% note info %}

Session是服务端保存状态的方式，Cookie是客户端保存状态的方式

Cookie保存在客户端，发起请求时将cookie放在请求头一起提交；Session保存在服务端，通过sessionId检查状态。

sessionId可以保存在cookie中，如果禁用了cookie，可以将sessionId放在URL中。

{% endnote %}

## 输入URL到看到页面的过程

{% note info %}

浏览器通过DNS解析域名获取服务端IP地址。

三次握手建立TCP连接，之后浏览器发起HTTP请求

服务端根据请求URL找到对应的请求处理器，处理之后返回响应包含处理结果和视图

浏览器解析并渲染视图，可能会再次请求页面中引用的其他静态资源文件

渲染完成，请求结束。

{% endnote %}

## HTTP常见状态码

{% note info %}

200：请求成功

301：永久重定向，接下来的请求都应该使用新的URL. 302：临时重定向

400：错误的请求，可能是请求方法错误. 401：未认证. 403：禁止访问. 404：无法找到

500：内部错误. 502：错误网关. 503：由于超载或系统维护服务不可用

{% endnote %}
