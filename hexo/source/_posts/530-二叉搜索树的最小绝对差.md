---
title: 530. 二叉搜索树的最小绝对差
tags:
  - Leetcode
  - 二叉树
  - 递归
categories:
  - Leetcode
  - 二叉树
abbrlink: 56aa34eb
---

> 给你一棵所有节点非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

{% note info %}

示例：

```java
输入：
   1
    \
     3
    /
   2

输出：
1
解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

{% endnote %}

<!-- more -->

### 💡 思路

二叉树的问题通常使用递归来解决，需要考虑的是在递归过程中需要收集什么信息，足以判断是否符合题意条件。

对于以某一个节点为根的树，它任意两个节点差值的最小值在其左子树求得的最小值、右子树求得的最小值、其**前驱**和**后继**节点与根节点的差值中产生（因为这是一棵二分搜索树）。

**前驱节点**：位于左子树的最右位置。数值上是左子树的最大值。

**后继节点**：位于右子树的最左位置。数值上是右子树的最小值。

### 🧾 代码

当节点为空/没有前驱后继节点时，返回整型最大值以避免影响判断。

```java
public int getMinimumDifference(TreeNode root) {
    //二分搜索数, 前驱和后继是和根差值最小的
    //左子树上的和右子树上的和当前的求最小的
    return process(root);
}
private int process(TreeNode node){
    if(node == null){
        return Integer.MAX_VALUE;
    }
    int left = process(node.left);
    int right = process(node.right);

    int cur = Integer.MAX_VALUE;
    TreeNode precursor = pre(node.left);
    if(precursor != null){
        cur = Math.min( cur, Math.abs(node.val - precursor.val));
    }
    TreeNode successor = suc(node.right);
    if( successor != null){
        cur = Math.min( cur, Math.abs(node.val - successor.val));
    }

    return Math.min(left, Math.min(right, cur));
}
//求前驱
private TreeNode pre(TreeNode node){
    if(node == null){
        return null;
    }
    while (node.right != null){
        node = node.right;
    }
    return node;
}
//求后继
private TreeNode suc(TreeNode node){
    if(node == null){
        return null;
    }
    while (node.left != null){
        node = node.left;
    }
    return node;
}
```

### 📈 优化

二分搜索树还有一个重要性质是其中序遍历序列是递增的。于是这道题可以通过在中序遍历时计算当前和前一个节点的差值与上一次的差值比较更新结果。

```java
int min = Integer.MAX_VALUE;
TreeNode pre = null;
public int getMinimumDifference(TreeNode root) {
    inOrder(root);
    return min;
}
public void inOrder(TreeNode node){
    if(node != null){
        inOrder(node.left);
        if(pre != null){
            min = Math.min(min, Math.abs(node.val- pre.val));
        }
        pre = node;
        inOrder(node.right);
    }
}
```

