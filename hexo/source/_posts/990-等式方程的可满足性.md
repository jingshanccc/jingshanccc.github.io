---
title: 990. 等式方程的可满足性
tags:
  - 并查集
categories:
  - Leetcode
abbrlink: 19551cf1
---

> 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
>
> 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
>

<!-- more -->

### 💡 思路

看懂题目之后一顿狂喜，~~苦学已久的~~并查集终于要派上用场了。

题目的意思就是，给定的数组里每个字符串都是` a==b `或者`a!=b` ，其中a，b代表变量，要求赋值之后所有方程都成立。例如，`[a == b, b == c, c == d, a != d, e == f, b != e] `，所有等式要成立要求`[a=b=c=d ,e=f]`（如下图）

![UnionFindSet](https://gitee.com/jingshanccc/image/raw/master/image/20200722002913.jpg)

由于`b!=e`中`b`和`e`属于在形成的两条等式里（颜色不同），符合要求，但对于不等式`a!=d `，发现它在形成的同一条等式里（颜色相同），因此不满足要求。

#### 并查集

可以将并发集中的元素看作一棵树，像上图所示，满足相同性质（本题是相等）的节点在同一棵树上，拥有相同的根节点。有以下两个基本操作：

1. 并：将满足性质的节点（树）合并为同一棵树。
2. 查：查找某个节点的根节点，可以用来判断两个节点是否满足相同性质。

因此本题的解法是先将所有等式两边的节点添加到并查集中，然后判断不等式两边的节点是否在同一棵树上，如果在，则表示他们必须相等，因此不等式也就不成立了。

### 🧾 代码

并查集可以使用一个数组`parent`来实现，以0-25来代表26个小写字母，数组中每个位置存放该位置（字母）的父亲节点，如` [1,2,3,3,5,5] `，位置0值为1，表示a的父亲节点是b，位置1值为2，表示b的父亲节点是c，位置3值为3，表示d的父亲节点是d，则d为和d相等的节点形成的树的根节点。

```java
public boolean equationsPossible(String[] equations) {
    int[] parent = new int[26];
    for(int i = 0 ; i < 26; i++){
        parent[i] = i;//初始每个节点的父亲节点是自身
    }

    for(String s : equations){
        if(s.charAt(1) == '='){
            int a = s.charAt(0) - 'a';
            int b = s.charAt(3) - 'a';
            union(a,b, parent, rank);
        }
    }
    for(String s: equations){
        if(s.charAt(1) == '!'){
            int a = s.charAt(0) - 'a';
            int b = s.charAt(3) - 'a';
            if(find(a,parent) == find(b,parent)){
                return false;
            }
        }
    }
    return true;
}
public void union(int a, int b, int[] parent, int[] rank){
    parent[find(a, parent)] = find(b, parent);//合并a,b形成的树--a的根节点的父亲节点指向b的根节点
}
public int find(int index, int[] parent){
    while(parent[index] != index){//当父亲节点是自身时跳出循环
        parent[index] = parent[parent[index]];//让父亲节点指向爷爷节点
        index = parent[index];//此时index为爷爷节点
    }
    return index;//循环结束时index为根节点
}
```



### 📈 优化

优化是对于并查集的优化，通常有两种策略：加权合并规则法、路径压缩法。这里介绍基于树高度的路径压缩法。

增加`rank`数组记录每个节点所在树的高度，在进行合并时，将选择合并后树高度最低的方案。这样在进行查找操作时，迭代次数少（递归深度低），达到优化目的。这种优化在数据量大时优化效果明显。

```java
public boolean equationsPossible(String[] equations) {
    int[] parent = new int[26];
    int[] rank = new int[26];//基于rank的路径压缩
    for(int i = 0 ; i < 26; i++){
        parent[i] = i;
        rank[i] = 1;//初始化树高度为1
    }

    for(String s : equations){
        if(s.charAt(1) == '='){
            int a = s.charAt(0) - 'a';
            int b = s.charAt(3) - 'a';
            union(a,b, parent, rank);
        }
    }
    for(String s: equations){
        if(s.charAt(1) == '!'){
            int a = s.charAt(0) - 'a';
            int b = s.charAt(3) - 'a';
            if(find(a,parent) == find(b,parent)){
                return false;
            }
        }
    }
    return true;
}
public void union(int a, int b, int[] parent, int[] rank){
    // parent[find(a, parent)] = find(b, parent);
    int aRoot = find(a,parent);
    int bRoot = find(b,parent);
    if(aRoot == bRoot){
        return;
    }
    //让高度低的并到高度高的--高度越小 find越快
    if(rank[aRoot] < rank[bRoot]){
        parent[aRoot] = bRoot;
    }else if(rank[aRoot] > rank[bRoot]){
        parent[bRoot] = aRoot;
    }else{//高度相同
        parent[aRoot] = bRoot;
        rank[bRoot] ++;
    }
}
public int find(int index, int[] parent){
    while(parent[index] != index){
        parent[index] = parent[parent[index]];
        index = parent[index];
    }
    return index;
}
```

