---
title: 538. 把二叉搜索树转换为累加树
tags:
  - Leetcode
  - 二叉树
  - 递归
categories:
  - Leetcode
  - 二叉树
abbrlink: 7da63a80
---

> 给定一个二叉搜索树，把它转换为累加树，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

{% note info %}

示例：

```java
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

{% endnote %}

<!-- more -->

### 💡 思路

根据题意，需要求每个节点比它大的所有节点值的和，对于一棵二叉搜索树，当题目所求和大小关系有关时，应该想到**中序遍历**。在二叉搜索树的中序遍历序列中，每个节点比它大的所有节点都在它的右侧。

如示例中，中序遍历序列为 `[2,5,13] `，对于2，需要加上 `5+13` ，对于5，需要加上 `13 `。我们可以发现，第一个节点加上了整个序列之和减去自身的值，接下来的节点也是类似。因此最直接的思路是先求所有节点之和 `add `，然后根据中序遍历顺序，`add `作为所有大于当前节点的值的和，修改每个节点的值并更新`add `即可。

### 🧾 代码

```java
int add = 0;
public TreeNode convertBST(TreeNode root) {
    inOrderForAdd(root);//求和
    inOrderForConvert(root);//加值
    return root;
}
public void inOrderForAdd(TreeNode node){
    if(node != null){
        inOrderForAdd(node.left);
        add+=node.val;
        inOrderForAdd(node.right);
    }
}
public void inOrderForConvert(TreeNode node){
    if(node != null){
        inOrderForConvert(node.left);
        add-=node.val;
        node.val+=add;
        inOrderForConvert(node.right);
    }
}
```

### 📈 优化

上述思路虽然直接，但是有些迂回了。我们需要转换一下想法，中序遍历是递增的，因此我们遍历的时候第一个到达的节点是最小值，需要加上其他所有值，这也导致了我们需要先进行一次遍历求得所有和。反过来向，如果能将中序遍历改造成递减的，那么第一个到达的节点是最大值，不需要加其他值，下一个节点只需要加上前一个节点即可，于是我们只需要遍历一次即可。

```java
int add = 0;
public TreeNode convertBST(TreeNode root) {
    if(root != null){
        convertBST(root.right);// 反向中序遍历
        root.val += add;
        add = root.val;//更新add
        convertBST(root.left);
    }
    return root;
}
```