---
title: 202. 快乐数
date: '2020-04-30 22:14'
tags:
  - Leetcode
  - 快慢指针
categories:
  - Leetcode
abbrlink: 827e2fc4
---

> 编写一个算法来判断一个数 ` n ` 是不是快乐数。
>
> 快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。
>
> 如果 ` n `  是快乐数就返回True；不是，则返回False。

<!-- more -->

{% note info %}

示例：

输入： 19
输出： true
解释： 1²+9² = 82，8²+2² = 68，6²+8² = 100，1²+0²+0² = 1.

{% endnote %}

### 💡 思路

第一步是写一个求平方和的方法。

如何得到结果？——不断求平方和直到平方和为1的时候返回True。

可以推断的是，不断求平方和的过程中，数字不会一直变大到无穷大，每一个位置上数字的范围是0-9，平方和的最大值是每一个位置都取9的情况，以3位数为例，999的平方和为9² + 9² +9²  = 243，4位数时，9999的平方和为9² + 9² +9² +9²  = 325。再往下演算可以知道，数字不会一直变大。

可能出现的情况？

1. 在有穷步之后，得到1。如示例
2. 出现循环，也就是在求平方和过程中，回到了曾经到达过的某个值。

于是，我们找到了可以终止循环的条件——重复出现的平方和。

### 🧾 代码

经过上面的分析，这里我们使用一个set来判断是否重复出现。

```java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();
    set.add(n);
    while(n != 1){
		n = getSquare(n);
        if(set.contains(n)){
            return false;
        }else{
            set.add(n);
        }
    }
    return true;
}
//求平方和
public int getSquare(int n){
    int sum = 0;
    while(n > 0){
        int m = n % 10;
        n /= 10;
        sum += m * m;
    }
    return sum;
}
```

### 📈 进阶

当给定数字不是快乐数时，在不断求解下一个数的过程中会形成环，尽管我们没有保存到每一个平方数，但是依然可以将求解过程看成在一个链表找下一个节点的过程，那么问题可以转换为证明**链表存在环**问题，因此可以使用**快慢指针**来解决。**快慢指针**的过程为：快指针一次走两步，慢指针一次走一步，如果链表存在环，那么快慢指针最终会到达同一个节点。

当给定数字为快乐数时，快指针会更早到达1。

```java
public boolean isHappy(int n) {
	int slow = n, fast = getSquare(n);
    while(fast != 1 && slow != fast){
        fast = getSquare(fast);
        fast = getSquare(fast);
        slow = getSquare(slow);
    }
    return fast == 1;
}
```

