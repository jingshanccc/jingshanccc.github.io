<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1014. 最佳观光组合</title>
    <url>/posts/6cc1ef4f.html</url>
    <content><![CDATA[<blockquote>
<p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。</p>
<p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p>
<p>返回一对观光景点能取得的最高分。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">    输入：[<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">    输出：<span class="number">11</span></span><br><span class="line">    解释：i=<span class="number">0</span>,j=<span class="number">2</span>,A[i]+A[j]+i-j=<span class="number">8</span>+<span class="number">5</span>+<span class="number">0</span>-<span class="number">2</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>在数组中寻找的问题通常最直观的思路是暴力的遍历，这道题同样可以使用这种方法，从前往后枚举每一个元素，并对该元素遍历除了本身之外的其他所有元素，在这个过程中更新最大值<code>max</code>。由于数据规模是<code>50000</code>，因此这种<code>o(n²)</code>的做法是会超时的。</p>
<div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//暴力-超时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                max = Math.max(max, A[i]+A[j]-Math.abs(i-j));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>在暴力做法中，对于得分公式<code>A[i] + A[j] + i - j</code>，我们将其划分成了<code>A[i] + i</code>和<code>A[j]-j</code>两部分，在外层循环确定一个<code>A[i]+i</code>，在内层循环中枚举所有<code>A[j]-j</code>，以此找到最大值。这导致了时间复杂度是<code>O(n²)</code>的，那么我们如何将这两层循环减为一层呢？答案是从这两部分出发，只要两部分都是最大值，那么组合结果一定是最大值。我们可以在遍历过程中，同时维护原本外层循环的<code>A[i]+i</code>始终为最大值即可通过一层循环求出结果。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历的同时维护a始终为最大的A[i]+i值</span></span><br><span class="line">    <span class="keyword">int</span> a = A[<span class="number">0</span>] + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max = Integer.max(max, a + A[i] - i);</span><br><span class="line">        a = Integer.max(a, A[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1022. 从根到叶的二进制数之和</title>
    <url>/posts/39280e8c.html</url>
    <content><![CDATA[<blockquote>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>以 10^9 + 7 为模，返回这些数字之和。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：(<span class="number">100</span>) + (<span class="number">101</span>) + (<span class="number">110</span>) + (<span class="number">111</span>) = <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>树中的路径问题，可以使用深度优先搜索来解决。本题中，需要求每一从根节点到叶子路径组成的二进制数的和。深搜过程中，需要保存已经得到的当前路径，到达根节点的标志是左右子树都为空，将二进制转为十进制我最开始无耻地使用 <code>Integer.parseInt(s,2)</code>，因为保存当前的路径直接用了字符串😂。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s+=root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        sum += (Integer.parseInt(s,<span class="number">2</span>)%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(root.left, s);</span><br><span class="line">        dfs(root.right, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上面的方法，<code>Integer.parseInt</code>的方式本身耗时，并且每次都从头求，没有利用到之前的记录，因此效率较低。因此在二进制转十进制这一部分进行优化。</p>
<p>我们发现，每加上一个节点值，当前路径的二进制数左移一位，然后加上当前节点。举个例子：示例中，对于路径 <code>110</code>，加入第一个节点值时当前节点二进制数为 <code>1</code>，十进制为 1，第二个节点时，原来二进制数左移1位，对应于十进制乘2，为2，然后加上第二个节点值 1，得到 <code>11</code>，十进制为3，第三个节点，左移1位，加上节点值，得到 <code>110</code>，十进制为3*2+0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur*<span class="number">2</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        sum += cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(root.left, cur);</span><br><span class="line">        dfs(root.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>127. 单词接龙</title>
    <url>/posts/527f7711.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>算法的主要过程是对<code>beginWord</code>每次替换一个字母，成为一个新的单词，判断是否是<code>endWord</code> 。题目要求找到最短转换序列的长度，也就是最少的转换次数，因此可以考虑采用广度优先搜索。因为每次替换一个位置的字母，有25种选择，新的单词必须存在于给出的<code>wordList</code>种，共有单词的长度<code>len</code>个位置。</p>
<p>整个算法其实是在构建一张无向图，假设<code>beginWord</code>为<code>hit</code>，<code>endWord</code>为<code>hot</code>，<code>wordList</code>为<code>[hat,bat,hot]</code>。从<code>beginWord</code>开始，对于第一个位置<code>h</code>，有25种替换选择，但其中只有选择<code>b</code>所生成的新单词<code>bat</code>在<code>wordList</code>中，因此需要往队列<code>queue</code> 中添加<code>bat</code>，第二个位置<code>i</code>，同样有25种选择，其中只有选择<code>a</code>和<code>o</code> 所生成的新单词在<code>wordList</code>中，因此需要将<code>hat,hot</code>放入queue中。但在这里我们发现新生成的单词<code>hot</code> 即为<code>endWord</code>，此时即是最少的转换次数为1次。</p>
<p>理解上述过程需要你对广度优先搜索有一定的熟悉度，比如所用的队列、何时更新转换次数等。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>代码的整个框架还是比较常规的广度优先搜索，主要是其中进行替换时需要替换<code>len</code>个位置，以及每个位置可从<code>a</code>到<code>z</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    HashSet&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(words.size()== <span class="number">0</span> || !words.contains(endWord))&#123;<span class="comment">//不存在endword</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    words.remove(beginWord);</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//存放已经使用过的</span></span><br><span class="line">    visited.add(beginWord);</span><br><span class="line">    <span class="keyword">int</span> len = beginWord.length();</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">            String curWord = queue.poll();</span><br><span class="line">            <span class="keyword">char</span>[] chars = curWord.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;<span class="comment">//当前单词的每个位置</span></span><br><span class="line">                <span class="keyword">char</span> oldChar = chars[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> m = <span class="string">'a'</span>; m &lt;= <span class="string">'z'</span>; m++)&#123;<span class="comment">//从a-z依次替换</span></span><br><span class="line">                    <span class="keyword">if</span>(m == oldChar)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[j] = m;<span class="comment">//替换当前位置</span></span><br><span class="line">                    String newWord = String.valueOf(chars);</span><br><span class="line">                    <span class="keyword">if</span>(words.contains(newWord))&#123;<span class="comment">//新单词存在于wordList中</span></span><br><span class="line">                        <span class="keyword">if</span>(newWord.equals(endWord))&#123;<span class="comment">//找到了</span></span><br><span class="line">                            <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(newWord))&#123;<span class="comment">//未使用过</span></span><br><span class="line">                            queue.add(newWord);</span><br><span class="line">                            visited.add(newWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[j] = oldChar;<span class="comment">//还原当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step ++;<span class="comment">//此时更新step-在上面整个循环中完成的是将一次替换的所有结果存放到了queue中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>152. 乘积最大子数组</title>
    <url>/posts/27e1a968.html</url>
    <content><![CDATA[<blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [-<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [-<span class="number">2</span>,-<span class="number">1</span>] 不是子数组。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>153. 寻找旋转排序数组中的最小值</title>
    <url>/posts/e3f3cf8a.html</url>
    <content><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></div>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>对数组进行遍历，找到比前一个位置元素小（<strong>降序</strong>）的位置，即为最小值。如果没有降序，意味着数组没有旋转，旋转点为最后一个位置。那么最小值将是第一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; min)&#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-二分查找"><a href="#✍️-二分查找" class="headerlink" title="✍️ 二分查找"></a>✍️ 二分查找</h3><p>对于有序数组的查找问题，我们总是可以考虑采用二分来解决。二分的基本思路是：根据中间位置的元素和其他位置元素的大小关系，修改左右边界，达到减小区间（<strong>减治</strong>）的目的。在这个问题中，我开始的想法是让中间数和其左右位置比较，但很快就推翻了这个想法，因为这样的比较无法修改边界，也就无法达到减治的目的。<del>其实数组中每个位置的元素，和其左右位置的关系都是相同的，都是大于其左边的小于其右边的。只有最小值的特征是相反的。</del>（这是一段废话，人家本来就说是升序的数组）。不过解题的过程大多数时候是这样的，不断地试错，找到最正确的方法。</p>
<p>思考到这里，我们应该就可以想到让中间数和左右边界作比较。</p>
<div class="note danger"><p>中间数和左边界</p>
<ul>
<li><p>当<code>nums[mid] &lt; nums[left]</code>，能否确定最小值在左侧？——可以，此时说明区间<code>[left...mid]</code>出现了降序</p>
</li>
<li><p>当<code>nums[mid] &gt; nums[left]</code>，能否确定最小值在右侧？——不能，当没有旋转的时候，最小值会在左侧</p>
</li>
</ul></div>

<div class="note success"><p>中间数和右边界</p>
<ul>
<li><p>当<code>nums[mid] &lt; nums[right]</code>，能否确定最小值在左侧？——可以，此时说明区间<code>[mid...right]</code>保持升序</p>
</li>
<li><p>当<code>nums[mid] &gt; nums[right]</code>，能否确定最小值在右侧？——可以，此时说明区间<code>[mid...right]</code>出现了降序</p>
</li>
</ul></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>经过上面的分析，我们可以尝试写出代码。二分法的代码过程，需要关注的点在循环终止条件以及最后返回什么。在这道题中，最小值一定在数组中，而我们一直在删去不可能存在最小值的区间，当区间只剩下一个元素，那么它一定是最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;<span class="comment">//考虑终止条件</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">// +1是因为mid一定不会是最小值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>202. 快乐数</title>
    <url>/posts/827e2fc4.html</url>
    <content><![CDATA[<blockquote>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。</p>
<p>如果 <code>n</code>  是快乐数就返回True；不是，则返回False。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例：</p>
<p>输入： 19<br>输出： true<br>解释： 1²+9² = 82，8²+2² = 68，6²+8² = 100，1²+0²+0² = 1.</p></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>第一步是写一个求平方和的方法。</p>
<p>如何得到结果？——不断求平方和直到平方和为1的时候返回True。</p>
<p>可以推断的是，不断求平方和的过程中，数字不会一直变大到无穷大，每一个位置上数字的范围是0-9，平方和的最大值是每一个位置都取9的情况，以3位数为例，999的平方和为9² + 9² +9²  = 243，4位数时，9999的平方和为9² + 9² +9² +9²  = 325。再往下演算可以知道，数字不会一直变大。</p>
<p>可能出现的情况？</p>
<ol>
<li>在有穷步之后，得到1。如示例</li>
<li>出现循环，也就是在求平方和过程中，回到了曾经到达过的某个值。</li>
</ol>
<p>于是，我们找到了可以终止循环的条件——重复出现的平方和。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>经过上面的分析，这里我们使用一个set来判断是否重复出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(n);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">		n = getSquare(n);</span><br><span class="line">        <span class="keyword">if</span>(set.contains(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平方和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSquare</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        sum += m * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-进阶"><a href="#📈-进阶" class="headerlink" title="📈 进阶"></a>📈 进阶</h3><p>当给定数字不是快乐数时，在不断求解下一个数的过程中会形成环，尽管我们没有保存到每一个平方数，但是依然可以将求解过程看成在一个链表找下一个节点的过程，那么问题可以转换为证明<strong>链表存在环</strong>问题，因此可以使用<strong>快慢指针</strong>来解决。<strong>快慢指针</strong>的过程为：快指针一次走两步，慢指针一次走一步，如果链表存在环，那么快慢指针最终会到达同一个节点。</p>
<p>当给定数字为快乐数时，快指针会更早到达1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> slow = n, fast = getSquare(n);</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">        fast = getSquare(fast);</span><br><span class="line">        fast = getSquare(fast);</span><br><span class="line">        slow = getSquare(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/posts/c8c06f39.html</url>
    <content><![CDATA[<blockquote>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例：</strong></p>
<p><strong>输入：</strong>1-&gt;2-&gt;4，1-&gt;3-&gt;4</p>
<p><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div>

<h3 id="💡思路"><a href="#💡思路" class="headerlink" title="💡思路"></a>💡思路</h3><p>这道题属于归并排序的应用，数组的归并过程是：使用两个索引<code>i , j</code>指向两个数组的左边界，每次根据两个数组中各自索引位置的元素大小来将一个元素放到结果数组中然后对应索引前进。当然了，我们还需要一个索引<code>k</code>来标识元素应该放到结果数组中的哪个位置。<div><div class="fold_hider"><div class="close hider_title">点击此处查看数组的归并</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length+arr2.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;<span class="comment">//终止条件是arr1用完或arr2用完</span></span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt; arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;<span class="comment">//arr2用完</span></span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;<span class="comment">//arr1用完</span></span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="🧾代码"><a href="#🧾代码" class="headerlink" title="🧾代码"></a>🧾代码</h3><p>了解了数组的归并过程，做这道题也就非常简单了。由于链表不像数组那样通过索引来方便的获取/修改该位置的元素，因此我们需要通过链表的<code>next</code>指针来推进归并过程。对于链表操作需要注意的是指针之间的引用关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本着不修改输入的原则,我们应该使用两个指针指向输入,避免对l1,l2直接修改</span></span><br><span class="line">    ListNode h1 = l1, h2 = l2;</span><br><span class="line">    <span class="comment">//初始化一个虚拟头节点,作为结果链表</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.val &lt; h2.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(h1.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            h1 = h1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(h2.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            h2 = h2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur.next = h1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur.next = h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>归并排序</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>287. 寻找重复数</title>
    <url>/posts/25e6dcf4.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
</blockquote>
<div class="note info"><p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>比较直接的想法有先排序再遍历（破坏输入）、hashSet去重（<code>O(n)</code>额外空间），都不是很好。</p>
<p>再仔细地分析题目，可以发现有两个重要的信息：数组长度为 <code>n + 1</code>、数字范围为<code>[1...n]</code>。应用排序的思路，数组的每一个位置上应该出现的数字为该位置下标+1，我们在遍历数组通过交换位置将数字放到应该在的位置的过程中，可以找出重复的元素，其具体表现为：当遍历到位置<code>i</code>时，如果当前位置的数字没有出现在应该在的位置（<code>nums[i] != i + 1</code>），通过交换 <code>nums[i]</code>和 <code>nums[nums[i] - 1]</code> ，让数字出现在应该在的位置，而当位置（<code>nums[i] - 1</code> ）已经存放了正确的数字时，表示出现了重复。例如，对于数组<code>[1,1,2,2]</code>，当 <code>i = 1</code>时，<code>nums[1] = 1 != 1+1</code>，需要交换位置，而此时，<code>nums[1] - 1 = 0</code> 位置上已经存放了正确的数字 <code>1</code>，于是可以得到重复的数字为1。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>需要注意的是，在成功交换之后，需要重新判断位置<code>i</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解法1：先sort再for</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// for(int i = 0 ; i &lt; nums.length-1 ;i ++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[i] == nums[i + 1])&#123;</span></span><br><span class="line">        <span class="comment">//         return nums[i];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解法2：让元素去到其该去的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(temp == nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                i--;<span class="comment">//成功交换后需要重新判断位置i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-二分法"><a href="#📈-二分法" class="headerlink" title="📈 二分法"></a>📈 二分法</h3><p>（这道题能想到这个做法也是对二分查找运用得登峰造极了😂）</p>
<p>具体的做法是：左右边界分别为1和n。通过记录数组中小于等于中位数<code>mid</code> 的个数，判断重复元素出现在左半部还是右半部，然后更新左右边界。例如：在数组<code>[3,1,2,2,4]</code>中<code>mid = 2</code>，数组中&lt;=2的有3个，因此重复的出现在<code>[1...2]</code>范围中；在数组<code>[3,1,2,3,4]</code> 中&lt;=2的有2个,所以重复的出现在<code>[2+1,...4]</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分-不断排除不会存在重复的一边</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i &lt;= mid)&#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; mid)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>221. 最大正方形</title>
    <url>/posts/37cbfc16.html</url>
    <content><![CDATA[<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>在二维数组求解比较容易想到<strong>动态规划</strong>的思想，可能主要是机器人运动范围和岛屿数量这类问题的原因。于是开始考虑 <code>dp[i][j]</code>代表什么，由于题目求只包含 1 的最大正方形，因此可以考虑让 <code>dp[i][j]</code>代表以该位置为<strong>右下角</strong>的最大正方形<strong>边长</strong>。右下角是由于动态规划思想从之前的结果推得这次的结果，那么右下角就是最后离开这个正方形的地方。边长是由于可以通过边长求得面积。</p>
<p>接下来考虑递推关系式，当当前位置为 0 时，<code>dp[i][j]</code> 也为0，因为没有以这个位置为右下角的正方形。当当前位置为 1 时，就比较复杂，需要一波分析。分析也不是毫无头绪和方向的，在二维数组的动态规划问题中，一般只有三个位置需要考虑，左侧、上方、左上角。</p>
<h2 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        max = Math.max(max, dp[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        max = Math.max(max, dp[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                max = Math.max(max, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max*max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/posts/4bff4329.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>只要我们知道了以每一个位置为开头的无重复最长子串，就可以求得整个字符串的无重复最长子串。这样的做法时间复杂度是O(n²)的。</p>
<p>过程：从一个位置开始，不断向后查找，当出现重复字符时，停下，记录子串长度。判断重复这里我使用一个HashSet来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴力的做法是：判断以每一个位置为起点的最长无重复字符</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; s.length(); start++)&#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(s.charAt(start));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end = start+<span class="number">1</span>; end &lt; s.length(); end++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(end)))&#123;</span><br><span class="line">                set.add(s.charAt(end));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//res = Math.max(res,set.size());//由于可能只有一个字符，无法进入内层循环因此不能在这里更新</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,set.size());<span class="comment">//在内层循环结束后更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-优化"><a href="#✍️-优化" class="headerlink" title="✍️ 优化"></a>✍️ 优化</h3><p>在上述的过程中，我们每次找完一个位置的子串之后就将之前的记录全部清除（<code>set = new HashSet&lt;&gt;();</code>)，再次从起点 <code>start</code> 的下一个位置开始查找，导致时间复杂度是O(N²)级别的。其实当出现重复时，<code>[start...end)</code> 左闭右开区间上，全都不是重复的，则<code>[start + 1...end)</code> 也是不重复的，那么我们可以保留 <code>end</code>位置，利用上一次记录的结果，不再从 <code>start + 1</code>的位置重新开始查找。这个过程我们就维护了一个<strong>滑动窗口</strong> <code>[start...end)</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>( left &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; n &amp;&amp; !set.contains(s.charAt(right)) )&#123;</span><br><span class="line">            set.add(s.charAt(right));</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">            set.remove(s.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>更进一步的，当字符串中的出现字符的范围较小时，使用一个int数组来达到优化的效果。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>( left &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; n &amp;&amp; record[s.charAt(right)] == <span class="number">0</span>)&#123;<span class="comment">//未重复,右移</span></span><br><span class="line">            record[s.charAt(right++)] ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">            record[s.charAt(left++)]--;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></div>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/posts/3abd6d1e.html</url>
    <content><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>题目要求时间复杂度为O(logn)，因此考虑使用二分查找的方法。二分查找要在有序的数组中进行，往这个方向思考，我们可以发现虽然给定的数组整体并不是有序的，但是它被分为两部分有序的数组，分界点在最大值/最小值。想到了这一点，整个问题转变为在两个有序数组中查找目标值，是一个简单的二分查找过程。而求分界点的方法和Leetcode <a href="/posts/e3f3cf8a.html" title="153. 寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a> 问题相同。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先找到最高点，然后就可以划分为在有序数组中的查找问题</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//因为mid可能一直取left导致死循环,因此+1向上取整 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[left])&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123;<span class="comment">//在右有序数组</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,target,left+<span class="number">1</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//在左有序数组</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,target,<span class="number">0</span>,left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/posts/a8a97330.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="👊暴力解法"><a href="#👊暴力解法" class="headerlink" title="👊暴力解法"></a>👊暴力解法</h3><p>从数组的第一个位置开始遍历，如果当前位置的值等于目标值，返回其索引值。否则继续向后查找直到第一个大于目标值的元素，返回其索引值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️二分查找"><a href="#✍️二分查找" class="headerlink" title="✍️二分查找"></a>✍️二分查找</h3><p>对于有序数组的查找问题，通常可以使用二分来解决。如果你对二分查找并不熟悉，可以先看看Leetcode <a href="/posts/41f30363.html" title="704. 二分查找">704. 二分查找</a> 问题。二分法的整体思路是：根据设定的左边界 <code>left</code> 和右边界 <code>right</code> 计算出中间位置 <code>mid</code> ，然后通过 <code>mid</code> 位置的元素来修改 <code>left</code> 和 <code>right</code> 。</p>
<p>本题中，根据<code>mid</code> 位置元素和目标值 <code>target</code>的大小关系，分为一下三种情况：</p>
<ul>
<li>如果 <code>nums[mid] = target</code>，则直接返回<code>mid</code></li>
<li>如果 <code>nums[mid] &lt; target</code>，则区间<code>[left...mid]</code>都小于 <code>target</code>，因此左边界 <code>left = mid + 1</code></li>
<li>如果 <code>nums[mid] &gt; target</code>，则区间<code>[mid...right]</code>都大于 <code>target</code>，因此右边界 <code>right = mid - 1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//循环结束条件是left&gt; right</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 跳跃游戏 II</title>
    <url>/posts/f579176b.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>采用广度优先遍历的方式，记录从当前位置可以到达的所有位置，当可以到达最后一个位置时，返回结果。同时需要使用记录下一位置是否已经使用过用于<strong>剪枝</strong>，查找可以到达的下一个位置时，使用从大到小查找的<strong>贪心</strong>策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//bfs找到最快到达n-1的</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];<span class="comment">//记录是否使用过</span></span><br><span class="line">    used[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[index]; j &gt; <span class="number">0</span>; j--)&#123;<span class="comment">//从大到小,一种贪心,一定程度提高效率,没有这个策略会超时</span></span><br><span class="line">                <span class="keyword">if</span>(j + index &gt;= n-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!used[j + index])&#123;</span><br><span class="line">                    queue.add(j + index);</span><br><span class="line">                    used[j+index] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述过程中，每一次都把接下来可以到达的、未使用过的<strong>所有</strong>位置放入队列，因此我们可以考虑如何在所有位置中选出最优的位置，最优的依据是：当前位置的能够到达的所有位置中，能够到达最远的位置。听起来有点绕，看个例子：</p>
<blockquote>
<p>对于示例 <code>[2,3,1,1,4]</code>，从下标 0 开始，可以到达的所有位置是：下标 1 ，2。在1和2中，最优的位置是 1，原因是：<code>nums[1] = 3</code>，即从下标 1 可以到达最远位置是 <code>1 + 3 = 4</code> ，而从下标 2 可以到达的最远位置是 <code>2 + 1 = 3</code>。</p>
</blockquote>
<p>根据这样的思路，其实很容易写成复杂度更高的，如果把找出最优位置的过程写成内层循环那就得不偿失了。那么还能通过什么方式来知道最优位置呢？答案是需要换个思路。我们的终止条件是到达数组<strong>最后一个位置</strong>，因此在查找过程中维护当前所能到达的最右边界，而最右边界的选取则采用上述的贪心策略。</p>
<p><code>maxRight</code> 记录位置 <code>cur</code> 能到达的最远位置,  <code>[cur...end]</code>是所有能到达的下一位置，在这个区间内表示的是同一次跳跃，而当 <code>cur</code> 超过 <code>end</code>时，表示这次跳跃能够到达的所有位置已经查找结束，因此 <code>step + 1</code> ，同时将 <code>end</code> 更新为 <code>[cur...end]</code> 所能到达的最远位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length-<span class="number">1</span>;<span class="comment">//遍历到最后一个位置的前一个位置</span></span><br><span class="line">    <span class="comment">//贪心 </span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>, maxRight = <span class="number">0</span>, step = <span class="number">0</span> , cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( end &lt; n)&#123;</span><br><span class="line">        maxRight = Math.max(maxRight, cur + nums[cur]);</span><br><span class="line">        <span class="keyword">if</span>(cur == end)&#123;</span><br><span class="line">            end = maxRight;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>530. 二叉搜索树的最小绝对差</title>
    <url>/posts/56aa34eb.html</url>
    <content><![CDATA[<blockquote>
<p>给你一棵所有节点非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
</blockquote>
<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 <span class="number">1</span>，其中 <span class="number">2</span> 和 <span class="number">1</span> 的差的绝对值为 <span class="number">1</span>（或者 <span class="number">2</span> 和 <span class="number">3</span>）。</span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树的问题通常使用递归来解决，需要考虑的是在递归过程中需要收集什么信息，足以判断是否符合题意条件。</p>
<p>对于以某一个节点为根的树，它任意两个节点差值的最小值在其左子树求得的最小值、右子树求得的最小值、其<strong>前驱</strong>和<strong>后继</strong>节点与根节点的差值中产生（因为这是一棵二分搜索树）。</p>
<p><strong>前驱节点</strong>：位于左子树的最右位置。数值上是左子树的最大值。</p>
<p><strong>后继节点</strong>：位于右子树的最左位置。数值上是右子树的最小值。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>当节点为空/没有前驱后继节点时，返回整型最大值以避免影响判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分搜索数, 前驱和后继是和根差值最小的</span></span><br><span class="line">    <span class="comment">//左子树上的和右子树上的和当前的求最小的</span></span><br><span class="line">    <span class="keyword">return</span> process(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = process(node.left);</span><br><span class="line">    <span class="keyword">int</span> right = process(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = Integer.MAX_VALUE;</span><br><span class="line">    TreeNode precursor = pre(node.left);</span><br><span class="line">    <span class="keyword">if</span>(precursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = Math.min( cur, Math.abs(node.val - precursor.val));</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode successor = suc(node.right);</span><br><span class="line">    <span class="keyword">if</span>( successor != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = Math.min( cur, Math.abs(node.val - successor.val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(left, Math.min(right, cur));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前驱</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">pre</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求后继</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">suc</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>二分搜索树还有一个重要性质是其中序遍历序列是递增的。于是这道题可以通过在中序遍历时计算当前和前一个节点的差值与上一次的差值比较更新结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            min = Math.min(min, Math.abs(node.val- pre.val));</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和</title>
    <url>/posts/a42162e0.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>具有最大和的连续子数组一定是以数组中的某个元素开头的，因此我们只要求得每个位置的最长连续子数组自然也可以得到结果。稍加分析之后，信心满满的写下了这样的代码。<div><div class="fold_hider"><div class="close hider_title">展开</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>跑一下发现连测试用例都过不了。错误的原因在于：当下一个数为负时并<strong>不能跳出循环</strong>，因为可能后面还会有更大的正数，即使加上这个负数，但是由于后面正数更大，自然应该继续累加。</p>
<blockquote>
<p>对于 <code>[1,-3,4]</code>，即使 <code>1</code> 后面是 <code>-3</code>，但是如果就此跳出循环，则求得的最大和为<code>1</code>，但是正确的最大和是 <code>1 + -3 + 4 = 2</code>。</p>
</blockquote>
<p>于是我们尝试修改代码，由于我们只需要求得最大和是多少，因此在内层循环累加的过程中不断更新结果，那么最大值一定能够被找到。<div><div class="fold_hider"><div class="close hider_title">改正之后的代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            res = Math.max(res, sum+=nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述的思路，为了知道以某个位置的元素为开头的最大和，我们遍历了后续的所有元素，通过<strong>枚举</strong>来求得最大值，而这仅仅能求得这一个位置。这也导致算法的时间复杂度是O(N²)的。于是我们换个思路，当我们考虑以当前位置的元素作为结尾时的最大和，可以根据<strong>前一个位置</strong>求得的最大和 <code>sum</code> 的<strong>正负</strong>，来决定当前位置是加在前一个元素之后，还是自己成为一个新的子数组。当 <code>sum &gt; 0</code>，对于当前数，加上这个 <code>sum</code>，有增加的效果；当 <code>sum &lt;= 0</code> ，对于当前数，加上这个 <code>sum</code> ，有减小的效果，因此可以丢弃之前的 <code>sum</code> ，重新开始计算。</p>
<div class="note success"><p>根据前一个位置的结果得到当前位置的结果，这是典型的<strong>动态规划</strong>思想。</p></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]&gt;<span class="number">0</span> ? dp[i-<span class="number">1</span>]+nums[i] : nums[i];</span><br><span class="line">        res = Math.max(dp[i],res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的，因为我们只需要知道前一个位置的结果，因此使用一个变量 <code>sum</code> 记录，优化空间复杂度。<div><div class="fold_hider"><div class="close hider_title">查看</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum = sum &gt; <span class="number">0</span> ? sum+num : num;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>538. 把二叉搜索树转换为累加树</title>
    <url>/posts/7da63a80.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉搜索树，把它转换为累加树，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
</blockquote>
<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">            /   \</span><br><span class="line">           <span class="number">2</span>     <span class="number">13</span></span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             <span class="number">18</span></span><br><span class="line">            /   \</span><br><span class="line">          <span class="number">20</span>     <span class="number">13</span></span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>根据题意，需要求每个节点比它大的所有节点值的和，对于一棵二叉搜索树，当题目所求和大小关系有关时，应该想到<strong>中序遍历</strong>。在二叉搜索树的中序遍历序列中，每个节点比它大的所有节点都在它的右侧。</p>
<p>如示例中，中序遍历序列为 <code>[2,5,13]</code>，对于2，需要加上 <code>5+13</code> ，对于5，需要加上 <code>13</code>。我们可以发现，第一个节点加上了整个序列之和减去自身的值，接下来的节点也是类似。因此最直接的思路是先求所有节点之和 <code>add</code>，然后根据中序遍历顺序，<code>add</code>作为所有大于当前节点的值的和，修改每个节点的值并更新<code>add</code>即可。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrderForAdd(root);<span class="comment">//求和</span></span><br><span class="line">    inOrderForConvert(root);<span class="comment">//加值</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderForAdd</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderForAdd(node.left);</span><br><span class="line">        add+=node.val;</span><br><span class="line">        inOrderForAdd(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderForConvert</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderForConvert(node.left);</span><br><span class="line">        add-=node.val;</span><br><span class="line">        node.val+=add;</span><br><span class="line">        inOrderForConvert(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述思路虽然直接，但是有些迂回了。我们需要转换一下想法，中序遍历是递增的，因此我们遍历的时候第一个到达的节点是最小值，需要加上其他所有值，这也导致了我们需要先进行一次遍历求得所有和。反过来向，如果能将中序遍历改造成递减的，那么第一个到达的节点是最大值，不需要加其他值，下一个节点只需要加上前一个节点即可，于是我们只需要遍历一次即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        convertBST(root.right);<span class="comment">// 反向中序遍历</span></span><br><span class="line">        root.val += add;</span><br><span class="line">        add = root.val;<span class="comment">//更新add</span></span><br><span class="line">        convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>572. 另一个树的子树</title>
    <url>/posts/689f55a9.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个非空二叉树 s 和 t ，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<pre><code>给定的树 s:
     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</code></pre><p>示例 2:</p>
<pre><code>给定的树 s：
     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：
   4
  / \
 1   2
返回 false。</code></pre></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树的问题，通常可以使用递归来求解，因为树本身具有天然的递归结构。通常的做法是，判断当前树/当前树的左子树/当前树的右子树是否符合条件。求解这类问题的时候，可以先不考虑具体的边界/递归终止问题，只需要先把框架写出来，用几个示例套入框架，可以较快地确定递归终止条件。</p>
<p>本题中，求一棵树是否为另一颗树的子树，根据上述的思路，可以先得到 <code>return isSub(s, t) || isSubTree(s.left , t) || isSubTree(s.right, t);</code> 这样的框架。然后我们需要写 <code>isSub(s , t)</code> 的逻辑，这个函数处理传入的两个树是否相等，需要满足以下三个条件：1. 节点值相等，即<code>s.val = t.val</code> 2. 节点左子树相等，即<code>isSub(s.left, t.left)</code> 3. 节点右子树相等，即<code>isSub(s.right, t.right)</code> 。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>于是我们综合上面的过程，再套入示例（这个过程最好自己实操一下），确定边界和终止条件。可以写出如下的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//s当前节点-t, s.left-t, s.right-t</span></span><br><span class="line">     <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> isSub(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span> &amp;&amp; s == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.val == t.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSub(s.left , t.left) &amp;&amp; isSub(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>704. 二分查找</title>
    <url>/posts/41f30363.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
</blockquote>
<a id="more"></a>

<div class="note default"><p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p> <del>不用什么思路，直接二分就完了</del>😝</p>
<h5 id="二分基本步骤"><a href="#二分基本步骤" class="headerlink" title="二分基本步骤"></a>二分基本步骤</h5><ol>
<li>确定左右边界，考虑开闭区间。这里我的左右边界分别是 <code>left = 0</code>，<code>right = nums.length - 1</code>，形成一个<code>[left ... right]</code>的左闭右闭区间。你也可以使用其他的边界类似 <code>right = nums.length</code>等，<strong>最重要的是</strong>你要知道你所定义的这些变量，在运行过程中代表什么，如何变化。</li>
<li>确定循环终止条件，考虑跳出循环的时候，<code>left</code> 和 <code>right</code> 的关系，返回时的处理。</li>
<li>通过中间位置的数 <code>nums[mid]</code> 与 <code>target</code> 的大小关系，修改边界，缩小区间，达到<strong>减治</strong>的目的。这里介绍下 <code>mid</code> 的几种求法。</li>
</ol>
<div class="note info"><p><code>int mid = (left + right) / 2</code>：当<code>left</code> 和 <code>right</code> 值太大时，<code>left + right</code> 会溢出，导致结果不正确</p>
<p><code>int mid = left + (right - left) / 2</code>：通常使用这种。</p>
<p><code>int mid = left + (right - left) &gt;&gt; 1</code> ：有一种说法是位运算比四则运算更快，但是其实优秀的编译器会帮我们做这步优化，因此使用第二种即可。</p>
<p><code>int mid = (left + right) &gt;&gt;&gt; 1</code>：即使产生溢出，无符号右移也可以返回正确的结果。但是不够直观，影响代码的可读性。</p></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//循环终止条件left&gt;right,区间长度&lt;0,表示不存在target</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//±1 -- 因为mid已经被排除</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>739-每日温度</title>
    <url>/posts/f2adbb58.html</url>
    <content><![CDATA[<blockquote>
<p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>比较直观的做法就是对于每个位置，往后遍历，当遇到第一个比自身大的元素时就停下来，记录位置；如果直到最后都没有遇到，则表示气温在这之后都不会升高。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//暴力</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T[j] &gt; T[i])&#123;</span><br><span class="line">                res[i] = j-i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>暴力遍历的方式虽然可以获得一个accept，但是效率是非常低的。因为每一次我们都是重新开始遍历，没有利用之前的结果。因此有了以下两种优化方式。</p>
<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>单调栈的含义是，一个栈中从栈顶到栈底一直保持着递增/递减的性质。当遇到新的元素入栈时，如果破坏了性质，则要通过出栈直到剩余的元素和新元素仍保持性质。</p>
<p>本题中，通过维护一个递减的单调栈，可以求出结果。将数组中元素（下标）逐个入栈，当<strong>新元素比栈顶元素大</strong>时，对于栈顶元素来说，即遇到了<strong>第一个比它大</strong>的元素，也就是气温升高，因此将栈顶出栈，并记录结果（下标差）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单调栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">            res[index] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="逆向-跳跃"><a href="#逆向-跳跃" class="headerlink" title="逆向+跳跃"></a>逆向+跳跃</h4><p>对于数组的最后一个元素，由于其后面没有元素，因此该位置结果为0。基于最后一个位置，我们尝试不断地推出前一个元素的结果。先看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跳跃</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T[j] &gt; T[i])&#123;</span><br><span class="line">                res[i] = j - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j += res[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层for循环从后往前遍历，对于每一个位置<code>i</code>，内层while循环起点是后一个元素<code>j</code>，如果<code>T[j] &gt; T[i]</code>，即气温升高，则记录结果（下标差）；如果位置<code>j</code>不大于<code>i</code>，按照暴力的逻辑，我们会逐个往后遍历，而这里我们通过判断已求得的结果<code>res[j]</code>是否为0来进行“跳跃”。对于<code>res[j]</code>：</p>
<ul>
<li><code>res[j] == 0</code>，即<code>j</code>之后气温不再升高，那么由于<code>T[i]&gt;=T[j]</code>，可得<code>res[i] = 0</code></li>
<li><code>res[j] &gt; 0</code>，即<code>j</code>之后<code>res[j]</code>天气温升高，在<code>[j...j+res[j]]</code>间没有比<code>T[i]</code>大的值，可以进行跳跃，加快效率，在对新的<code>j</code>进行判断</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>98. 验证二叉搜索树</title>
    <url>/posts/5e0c5aa8.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。假定一个二叉搜索树有以下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数</li>
<li>所有左子树和右子树自身必须也是二叉搜索树</li>
</ul>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树由于天然的具有递归结构，因此大多数问题都可以通过<strong>递归</strong>来解决。本题需要判断当前树是否为二叉搜索树，则当当前节点为二叉搜索树、其左子树为二叉搜索树、其右子树为二叉搜索树时返回 <code>true</code> 。需要注意的是，作为一棵二叉搜索树，它左子树的所有节点都必须小于它，因此不能仅仅判断它和它的左子节点，这样只能判断父子关系而没有判断爷孙关系。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(TreeNode node, <span class="keyword">long</span> min , <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.val &lt; min || node.val &gt; max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid(node.left, min, node.val) &amp;&amp; valid(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-中序遍历"><a href="#✍️-中序遍历" class="headerlink" title="✍️ 中序遍历"></a>✍️ 中序遍历</h3><p>对于一颗二叉搜索树，它的中序遍历序列是递增的。根据这个特征，我们在中序遍历的时候判断当前值是否大于上一个值即可。如果对树的遍历还不熟悉，可以查看这篇文章 <a href="/posts/ea4681d0.html" title="二叉树的遍历">二叉树的遍历</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归版</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &gt;= root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非递归版</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>983. 最低票价</title>
    <url>/posts/dcddc4fc.html</url>
    <content><![CDATA[<blockquote>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：days = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">20</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">1</span> 天生效。</span><br><span class="line">在第 <span class="number">3</span> 天，你花了 costs[<span class="number">1</span>] = $<span class="number">7</span> 买了一张为期 <span class="number">7</span> 天的通行证，它将在第 <span class="number">3</span>, <span class="number">4</span>, ..., <span class="number">9</span> 天生效。</span><br><span class="line">在第 <span class="number">20</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">20</span> 天生效。</span><br><span class="line">你总共花了 $<span class="number">11</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>分析题目，针对于某一天，它是否花费决定于上一次花费购买的类型，比如在第31天，它的上一次购买可能是1天前、7天前、30天前。第 <code>31-30</code> 天可以购买30天的通行证，这样可以在 <code>[1...30]</code>天旅行；第 <code>31-7</code> 天可以购买7天的通行证，这样可以在 <code>[24...30]</code>天旅行；第 <code>31-1</code> 天可以购买1天的通行证，这样可以在 <code>[30...30]</code>天旅行；因此第31天可以有3种购买方式产生3种花费，在这三种花费中选择最低的价格。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(days == <span class="keyword">null</span> || days.length == <span class="number">0</span> || costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days[days.length-<span class="number">1</span>] + <span class="number">1</span>]; <span class="comment">//最大天数</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//第一天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : days)&#123;</span><br><span class="line">        dp[i] = -<span class="number">1</span>; <span class="comment">//标志需要旅游的天数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == <span class="number">0</span>)&#123;<span class="comment">//不需要旅游的</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = dp[i-<span class="number">1</span>] + costs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c7 = dp[i-<span class="number">7</span>] + costs[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> c30 = dp[i-<span class="number">30</span>] + costs[<span class="number">2</span>];</span><br><span class="line">            dp[i] = Math.min(c1, Math.min(c7, c30));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常体系</title>
    <url>/posts/f885a170.html</url>
    <content><![CDATA[<p></p>

<a id="more"></a>

<h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>Java中的异常都是Throwable的子类，分为Error和Exception，Error用来表示JVM无法处理的错误，Exception分为受检异常和不受检异常，又叫编译期异常和运行时异常，其区别是编译期异常如果不处理会编译失败，运行时异常可以通过编译。</p>
<p>运行时异常时RuntimeException及其所有子类，除此之外都是编译期异常。其体系结构如下图：</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004826.png" alt="图片"></p>
<p>Error下有OutOfMemoryError和StackOverflowError，Exception下有RuntimeException和IOException。常见的Runtime有NumberFormatException，ClassNotFoundException，ClassCastException，CloneNotSpportException，IndexOutOfBoundException，常见的IOException有FileNotFoundException，FileExistsException，EncodeException，DecodeException，SocketException等。</p>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><ol>
<li><p>逻辑：如果有finally，执行完try会执行finally，如果有finally有return或者让程序结束的语句，则直接结束，否则会回到try中执行。</p>
</li>
<li><p>字节码：先是try中的翻译成机器指令(比如4-8条)，然后是finally块的指令(比如9-10条)，然后是return(11条)。接下来的字节码是catch中的指令(12-14)，然后是final的指令(15-16跟第一个finally一样的)，最后是goto指令(17)。每个catch有这么一段，goto指令都指向最后一句return(38)。最后还会有未被catch的其他异常，字节码结构为astore存储异常(33)，finally的指令(34-35)，aload取出异常，然后是抛出异常的athrow指令，最后一句是return(38条).也就是所有catch之后goto的位置。接下来是异常表Exception Table决定在抛异常后跳转到的位置，格式如下：</p>
<table>
<thead>
<tr>
<th align="center">from指令开始行</th>
<th align="center">to指令最后行</th>
<th align="center">target跳转到目标指令行号</th>
<th align="center">type异常类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">Exception1–异常1</td>
<td align="center">在try中抛出了异常Exception1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">18</td>
<td align="center">Exception2–异常2</td>
<td align="center">在try中抛出了异常Exception2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在try中抛出了未被catch的异常</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">17</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理Exception1时抛出了其他异常</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">23</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理Exception2时抛出了其他异常</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">37</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理其他异常的时候抛出了异常，准确来说是处理其他异常时finally抛出的异常</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h3><ol>
<li>throw：用在方法体内，抛出异常，在运行时是一定会抛出的，由上层调用者处理抛出的异常</li>
<li>throws：用在方法声明中，表示在运行时可能抛出异常，由上层调用者处理</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>990. 等式方程的可满足性</title>
    <url>/posts/19551cf1.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>看懂题目之后一顿狂喜，<del>苦学已久的</del>并查集终于要派上用场了。</p>
<p>题目的意思就是，给定的数组里每个字符串都是<code>a==b</code>或者<code>a!=b</code> ，其中a，b代表变量，要求赋值之后所有方程都成立。例如，<code>[a == b, b == c, c == d, a != d, e == f, b != e]</code>，所有等式要成立要求<code>[a=b=c=d ,e=f]</code>（如下图）</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722002913.jpg" alt="UnionFindSet"></p>
<p>由于<code>b!=e</code>中<code>b</code>和<code>e</code>属于在形成的两条等式里（颜色不同），符合要求，但对于不等式<code>a!=d</code>，发现它在形成的同一条等式里（颜色相同），因此不满足要求。</p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>可以将并发集中的元素看作一棵树，像上图所示，满足相同性质（本题是相等）的节点在同一棵树上，拥有相同的根节点。有以下两个基本操作：</p>
<ol>
<li>并：将满足性质的节点（树）合并为同一棵树。</li>
<li>查：查找某个节点的根节点，可以用来判断两个节点是否满足相同性质。</li>
</ol>
<p>因此本题的解法是先将所有等式两边的节点添加到并查集中，然后判断不等式两边的节点是否在同一棵树上，如果在，则表示他们必须相等，因此不等式也就不成立了。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>并查集可以使用一个数组<code>parent</code>来实现，以0-25来代表26个小写字母，数组中每个位置存放该位置（字母）的父亲节点，如<code>[1,2,3,3,5,5]</code>，位置0值为1，表示a的父亲节点是b，位置1值为2，表示b的父亲节点是c，位置3值为3，表示d的父亲节点是d，则d为和d相等的节点形成的树的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        parent[i] = i;<span class="comment">//初始每个节点的父亲节点是自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            union(a,b, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String s: equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(a,parent) == find(b,parent))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank)</span></span>&#123;</span><br><span class="line">    parent[find(a, parent)] = find(b, parent);<span class="comment">//合并a,b形成的树--a的根节点的父亲节点指向b的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] != index)&#123;<span class="comment">//当父亲节点是自身时跳出循环</span></span><br><span class="line">        parent[index] = parent[parent[index]];<span class="comment">//让父亲节点指向爷爷节点</span></span><br><span class="line">        index = parent[index];<span class="comment">//此时index为爷爷节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;<span class="comment">//循环结束时index为根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>优化是对于并查集的优化，通常有两种策略：加权合并规则法、路径压缩法。这里介绍基于树高度的路径压缩法。</p>
<p>增加<code>rank</code>数组记录每个节点所在树的高度，在进行合并时，将选择合并后树高度最低的方案。这样在进行查找操作时，迭代次数少（递归深度低），达到优化目的。这种优化在数据量大时优化效果明显。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//基于rank的路径压缩</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;<span class="comment">//初始化树高度为1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            union(a,b, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String s: equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(a,parent) == find(b,parent))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank)</span></span>&#123;</span><br><span class="line">    <span class="comment">// parent[find(a, parent)] = find(b, parent);</span></span><br><span class="line">    <span class="keyword">int</span> aRoot = find(a,parent);</span><br><span class="line">    <span class="keyword">int</span> bRoot = find(b,parent);</span><br><span class="line">    <span class="keyword">if</span>(aRoot == bRoot)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让高度低的并到高度高的--高度越小 find越快</span></span><br><span class="line">    <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])&#123;</span><br><span class="line">        parent[aRoot] = bRoot;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[aRoot] &gt; rank[bRoot])&#123;</span><br><span class="line">        parent[bRoot] = aRoot;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//高度相同</span></span><br><span class="line">        parent[aRoot] = bRoot;</span><br><span class="line">        rank[bRoot] ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] != index)&#123;</span><br><span class="line">        parent[index] = parent[parent[index]];</span><br><span class="line">        index = parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode周赛-187</title>
    <url>/posts/2b34ab19.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h3 id="旅行终点站"><a href="#旅行终点站" class="headerlink" title="旅行终点站"></a>旅行终点站</h3><blockquote>
<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法"><a href="#💡-解法" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>终点站不会出现在任何线路的起点，因此将所有终点存入一个set，然后将出现在起点的站点从set中删除，最终剩下的就是终点站。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">destCity</span><span class="params">(List&lt;List&lt;String&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; city = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; cs : paths)&#123;</span><br><span class="line">        city.add(cs.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; cd : paths)&#123;</span><br><span class="line">        <span class="keyword">if</span>(city.contains(cd.get(<span class="number">0</span>)))&#123;</span><br><span class="line">            city.remove(cd.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> city.iterator().next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="是否所有-1-都至少相隔-k-个元素"><a href="#是否所有-1-都至少相隔-k-个元素" class="headerlink" title="是否所有 1 都至少相隔 k 个元素"></a>是否所有 1 都至少相隔 k 个元素</h2><blockquote>
<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<p><strong><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004857.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004907.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法-1"><a href="#💡-解法-1" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>只要所有1之间最小的间隔等于k即可。换句话说，如果还没出现k个0就再次出现1，返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kLengthApart</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span> &amp;&amp; distance &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        distance = nums[i]==<span class="number">0</span> ? distance + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a>绝对差不超过限制的最长连续子数组</h2><blockquote>
<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法-2"><a href="#💡-解法-2" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>最长连续子数组问题，都可以通过暴力枚举以每一个位置开头的最长连续子数组来求解。要求子数组任意两个元素之间绝对差小于等于<code>limit</code>，而最大的绝对差来自最大值和最小值的差，因此需要动态维护子数组中的最大值和最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[i];</span><br><span class="line">        <span class="keyword">int</span> max = nums[i];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[j]-min) &gt; limit || Math.abs(max-nums[j]) &gt; limit)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">                min = Math.min(min, nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(count, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交之后会获得一个<strong>超时</strong>的结果😂。</p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述过程中，由于没有利用到上一次求取过程中的信息，每一个位置的求解都需要遍历该位置元素之后的整个数组，因此是O(N²)的复杂度。解题和优化的思路和Leetcode第 <a href="/posts/4bff4329.html" title="3. 无重复字符的最长子串">3. 无重复字符的最长子串</a> 题类似，既然开头行不通，那么我们可以反过来求解以每一个位置为结尾的满足要求的最长连续子数组。遍历每一个位置，从右向左查找满足条件的。<code>[left...i-1]</code>一定是满足条件的，通过 <code>i</code> 和其左边的数字，更新left，表示包含 <code>i</code> 之后，符合条件的最左下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//满足条件的最小下标数组值。</span></span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length; ++ i)&#123;</span><br><span class="line">        <span class="comment">//队列维护</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j --)&#123;</span><br><span class="line">            <span class="comment">//如果存在相同的值，直接跳过，不处理left</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右往左处理，如果有不满足，直接更新left.</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[j] - nums[i])&gt; limit)&#123;</span><br><span class="line">                left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>文中题目以及图片来自 <a href="https://leetcode-cn.com/contest/weekly-contest-187/" target="_blank" rel="noopener">Leetcode 第 187 场周赛</a> .</p></div>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试问题</title>
    <url>/posts/e745ac01.html</url>
    <content><![CDATA[<p>
<a id="more"></a>

<h2 id="为什么要使用缓存？"><a href="#为什么要使用缓存？" class="headerlink" title="为什么要使用缓存？"></a>为什么要使用缓存？</h2><ol>
<li><p>高性能</p>
<p>假设用户第一次访问数据库获取数据，这个过程是比较慢的，因为是从硬盘读取，同时如果需要获取的数据本身查询过程十分耗时，那么我们将第一次获取到的结果直接放在缓存中，下一次访问直接在缓存中获取即可，操作缓存就是操作内存，速度更块。</p>
</li>
<li><p>高并发</p>
<p>内存能够承受的请求是远远大于直接访问数据库的，所以我们将数据库的部分数据转移到缓存中，可以让部分请求直接访问内存而不经过数据库。</p>
</li>
</ol>
<details>
<summary>数据库有缓存吗？</summary>
有，以mysql为例，它会将查询sql和结果以key-value的形式缓存起来，再遇到hash值相同的sql语句就不再经过编译解析优化和查询，直接返回结果。<br/>
缺点：
    通过hash，意味着语义相同的可能有不同的表达，这样也无法命中缓存。对于频繁更新的表，缓存总是难以命中，但还是需要耗费资源维护缓存。
</details>

<h2 id="选择Redis的原因？"><a href="#选择Redis的原因？" class="headerlink" title="选择Redis的原因？"></a>选择Redis的原因？</h2><h3 id="本地缓存和分布式缓存"><a href="#本地缓存和分布式缓存" class="headerlink" title="本地缓存和分布式缓存"></a>本地缓存和分布式缓存</h3><ol>
<li><p>Java中使用map/guaua来做本地缓存，直接将数据存在jvm内存中，与jvm拥有相同的生命周期。其优点是轻量且快速。但在多实例的情况下，每个实例都需要保存自己的一份缓存，不具有一致性</p>
</li>
<li><p>Redis和Memcache实现的是分布式缓存，在多实例下，共用一份缓存，具有一致性。因此需要保证服务的高可用，架构较复杂。</p>
</li>
</ol>
<h3 id="redis和memcache"><a href="#redis和memcache" class="headerlink" title="redis和memcache"></a>redis和memcache</h3><ol>
<li>持久化：memcache不支持持久化，缓存数据只存在在内存中，断电后数据就丢失了。redis提供了持久化机制，可以将数据保存到磁盘中，重启后通过日志文件可以恢复数据。</li>
<li>数据类型：memcache只支持简单的string类型，redis除了string之外，还支持列表，哈希，集合等多种数据结构。</li>
<li>分布式：memcache不支持分布式，只能通过多个客户端使用一致性哈希来向集群中存储数据，这种方式在查询和存储时都需要计算一次。redis原生支持集群模式。</li>
<li>线程模型：memcache是多线程的，redis默认是单线程的，减少了线程切换的消耗</li>
</ol>
<h2 id="说说Redis的线程模型？"><a href="#说说Redis的线程模型？" class="headerlink" title="说说Redis的线程模型？"></a>说说Redis的线程模型？</h2><p>redis内部采用文件事件处理器，它是单线程的，通过I/O多路复用机制，监听多个socket，根据socket上的事件选择对应的事件处理器来处理。<br>文件事件处理器包括四个部分：socket、I/O多路复用程序、事件分派器、事件处理器（包括连接应答处理器，命令请求处理器，命令回复处理器）</p>
<p>redis基于reactor模式开发出自己的I/O多路复用程序，多个socket同时产生的事件将被加入到队列中，事件分派器从队列中取出事件，根据事件类型分派给不同的事件处理器。</p>
<details><summary>事件的调度和执行</summary>
redis服务器是一个事件驱动程序，有文件事件和时间事件。服务器需要一直监听socket以得到到达的文件事件，但是由于需要执行时间事件，不能一直监听，否则时间事件不能在预期时间内执行。因此，redis通过计算距离最近的时间事件，根据所剩的时间，监听文件事件，在剩余时间结束后，处理该时间段内的文件事件，同时处理该时间的时间事件。不断重复直到服务器关闭。
</details>

<h2 id="你了解Redis的数据类型吗？应用场景是什么？"><a href="#你了解Redis的数据类型吗？应用场景是什么？" class="headerlink" title="你了解Redis的数据类型吗？应用场景是什么？"></a>你了解Redis的数据类型吗？应用场景是什么？</h2><ol>
<li><p>String字符串</p>
<p>存储：字符串，整型，浮点型</p>
<p>命令：set get incr decr</p>
<p>应用场景：key-value存储，计数器</p>
<p>底层实现：简单可变字符串，使用char数组保存数据，并有长度len，空闲长度free。记录len和free属性可以实现空间预分配和惰性释放。通过len减少连续增长字符串时所需的空间重分配的操作次数，因为每次增长字符串时将多分配len字节的未使用空间。通过free优化字符串的缩短操作，不需要在每次缩短时立即释放未使用的空间，通过free记录下来等待将来使用</p>
</li>
<li><p>List列表</p>
<p>存储：列表</p>
<p>命令：lpop lpush rpop rpush lrange(实现分页查询)</p>
<p>应用场景：关注列表/粉丝列表/消息列表</p>
<p>底层实现：结构体包含链表头节点、尾节点、长度、释放/复制/比较节点函数。节点数据结构包含前置/后置指针、任意类型的值。</p>
</li>
<li><p>Set集合</p>
<p>存储：集合，去重</p>
<p>命令：sadd spop smembers sunion</p>
<p>应用场景：由于有方便的求交集差集并集的操作，可以实现共同关注等</p>
<p>底层实现：使用整形集合或字典实现。</p>
<p>​    <strong>整型集合</strong>：当集合只包含int类型时，使用intset存放，intset数据结构中包含编码格式、数组、长度。编码格式规定了能存储的数据范围，比如int_16t表示存储-32768-32767（1位符号位15位数值位），超出范围则会自动升级到32位。</p>
<p>​    <strong>字典</strong>：Dict是最上层的结构体，包含两个distht哈希表（一个用于存放数据一个用于rehash）、rehashidx、类型特定函数（键值复制释放、哈希函数、键比较函数）。distht哈希表包含distEntry数组、表的大小、已用大小、计算索引的sizemark。distEntry结构体是数组中存放的数据类型，包含key、value、next指针。</p>
</li>
<li><p>Hash映射表</p>
<p>存储：包含键值对的无序散列表</p>
<p>命令：hset hget hexists hlen</p>
<p>应用场景：存储结构化的对象 非常方便的修改某个属性</p>
<p>底层实现：使用字典或压缩列表实现。</p>
<p>​    <strong>字典</strong>。</p>
<p>​    <strong>压缩列表</strong>：结构体中包含所占字节数zlbytes、尾部到起点的字节数zltail、节点数zllen、列表末端zlend、节点数组entry。节点结构体包含的属性有前一个结点的长度previous_length、数据类型encoding、数据内容content。存放hash对象时，键一个entry值一个entry</p>
</li>
<li><p>SortedSet有序集合</p>
<p>存储：跟set相比，增加了权重参数，根据参数来排序</p>
<p>命令：zadd zrange zrem zrank zcount</p>
<p>应用场景：由于是排序的，可以实现排行榜等</p>
<p>底层实现：使用跳跃表和字典来实现。<strong>跳跃表</strong>：基于链表+索引实现，解决了数组插入时的O(n),链表查询时的O(n)。由多层链表组成，每一层都是有序链表，上一层的链表是下一层链表的子集。每一个链表结点都有两个指针，一个指向同层的下一个结点，另一个指向下一层的同一个链表节点。最上层结构体是zskiplist，包含头节点和尾节点skiplistNode、节点数量length、最大层数level。</p>
</li>
</ol>
<h2 id="Redis中Key的过期时间是怎么实现的？"><a href="#Redis中Key的过期时间是怎么实现的？" class="headerlink" title="Redis中Key的过期时间是怎么实现的？"></a>Redis中Key的过期时间是怎么实现的？</h2><p>通过set key的expiretime来设置key的存活时间，过期自动删除。redis中有两种key的过期机制。</p>
<ul>
<li>定期删除：默认每100ms<strong>随机抽取</strong>内存中的key判断是否过期决定是否删除。可以在配置文件中设置间隔时间。定期删除每次不会检查所有key，因为这样会十分耗时，因此采用随机选择部分key进行判断。</li>
<li>惰性删除：因为定期删除可能遗漏了部分key，惰性删除则在key<strong>再次被请求</strong>时，判断是否过期决定是否删除。</li>
</ul>
<p>但是在这两种过期机制下，还是会存在key到期也没被删除，定期删除没有删掉，惰性删除因为没有再次请求也没有生效，此时可能内存占用会越来越高。redis通过设置<strong>内存淘汰策略</strong>解决这一问题。</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>当内存超过了设置的最大内存限制，就会执行内存淘汰策略。</p>
<ol>
<li>allkeys-lru:从所有数据集中选择最近最久未使用的数据淘汰</li>
<li>allkeys-lfu:从所有数据集中选择访问频率最低的数据淘汰</li>
<li>allkeys-random:从所有数据集中随机选择数据淘汰</li>
<li>no-eviction：不淘汰，新写入时报错</li>
<li>volatile-lru:从已设置过期时间的数据集中选择最近最久未使用的数据淘汰</li>
<li>volatile-lfu:从已设置过期时间的数据集中选择访问频率最低的数据淘汰</li>
<li>volatile-ttl:从已设置过期时间的数据集中选择将要过期的数据淘汰</li>
<li>volatile-random:从已设置过期时间的数据集中随机选择数据淘汰</li>
</ol>
<p>lru：redis中的lru不使用常规的维护队列的方式，通过全局的时钟和key中保存的时钟，选择最久未被使用的淘汰。一般场景下，缓存中存放热点数据，为了提高缓存命中率，使用lru策略<br>lfu：将lru中的24位时钟分为两部分，前16位记录时钟，后8位记录访问频率。访问频率并不是简单的线性增长，而是设置参数lfu-log-factor和lfu-decay-time通过公式来计算实现。</p>
<p><em>当数据集中没有设置过期时间的key，前四种策略将由于不满足先决条件而和no-eviction相同</em></p>
<h2 id="redis断电之后数据如何恢复？"><a href="#redis断电之后数据如何恢复？" class="headerlink" title="redis断电之后数据如何恢复？"></a>redis断电之后数据如何恢复？</h2><p>通过redis的持久化机制，在重启之后可以恢复数据。redis提供了以下三种持久化机制。</p>
<ul>
<li>RDB快照持久化：将某一时刻的数据保存到文件中，通过配置文件可以设置在n秒内如果数据发生m次变化则触发bgsave创建快照，备份当前数据。也可以手动调用bgsave来触发持久化。rdb持久化的优点是文件小，恢复快。缺点是实时性较差，最后一次快照之后的数据将丢失。</li>
<li>AOF持久化：开启了aof持久化后，redis将把每一条改变数据的操作追加到日志文件中。这样的缺点是aof文件会不断增大，可以通过日志重写来解决，日志重写的过程将当前数据直接生成新的命令写入到新的aof文件中，合并和简化命令。</li>
<li>混合持久化：开启混合持久化后，aof重写时将当前数据以rdb格式写入到文件，在此过程中新的变化将以aof格式写入，恢复时先将重写rdb内容，再执行aof的内容。</li>
</ul>
<h2 id="了解redis的事务吗？"><a href="#了解redis的事务吗？" class="headerlink" title="了解redis的事务吗？"></a>了解redis的事务吗？</h2><p>redis事务通过MULTI、EXEC、DISCARD、WATCH来实现。只有在将命令添加进队列时发现语法错误才会导致EXEC命令报错。语法正确的指令即使是执行时出错，redis也会执行其他命令。</p>
<ul>
<li>MULTI:开启一个事务，之后可以一条条输入想要执行的命令添加到队列中</li>
<li>EXEC:执行在MULTI之后队列中添加的所有命令</li>
<li>DISCARD:回滚，取消执行MULTI开启的事务</li>
<li>WATCH:监控一个或多个key，当key发生变化时，事务将不会被执行。提供了CAS的功能，在MULTI开始之前，监控key，EXEC时判断key是否修改过。</li>
</ul>
<h2 id="说说缓存穿透和缓存雪崩"><a href="#说说缓存穿透和缓存雪崩" class="headerlink" title="说说缓存穿透和缓存雪崩"></a>说说缓存穿透和缓存雪崩</h2><ul>
<li>缓存穿透：用户请求的数据不在数据库中，自然也不在缓存中，此时每次请求该key，总是无法在缓存中找到，也无法在数据库中找到。因此每次都会访问数据库。这种现象称为缓存穿透。</li>
</ul>
<p>​    <strong>解决方法</strong>：1. 为该key设置null值，但是设置较短的过期时间，避免当数据存在时却在缓存中获取到空值。2. 使用布隆过滤器，将所有可能存在的数据哈希到一个bitmap中，不存在的数据一定会被bitmap拦截。</p>
<ul>
<li>缓存雪崩：大量的key在同一时间失效，导致请求全部落在数据库。</li>
</ul>
<p>​    <strong>解决办法</strong>：1. 预防：错开过期时间 2. 应对：限流以保证数据库不会挂掉</p>
<details>
<summary>缓存击穿</summary>
一个热点数据在失效瞬间，仍然有大量请求来获取，此时缓存失效，请求都落在数据库上。**解决方法**：1. 热点数据永不过期 2. 使用互斥锁：在请求时先查缓存，有则返回，否则尝试获取锁，成功之后查询数据库并更新缓存然后释放锁，获取锁失败说明已经有线程在查数据库准备更新缓存，因此可以通过自旋之后重试查询缓存。
</details>

<details>
<summary>布隆过滤器</summary>
单个hash函数可能出现不同数据hash值相同的情况，因此通过采用k个相互独立的hash函数解决冲突，将所有可能存在的数据hash到一个bitmap中。
</details>

<h2 id="如何解决并发竞争key问题？"><a href="#如何解决并发竞争key问题？" class="headerlink" title="如何解决并发竞争key问题？"></a>如何解决并发竞争key问题？</h2><p>多个客户端对同一个key做set操作。<br>解决方案：</p>
<ol>
<li>乐观锁：通过watch可以方便的实现乐观锁，watch监听的key在事务期间发生变化，事务将会回滚</li>
<li>时间戳：在set key时加入时间戳，通过比较key的时间戳来确定是否继续执行set操作</li>
<li>消息队列：将并发的操作加入到消息队列中，串行化执行</li>
<li>分布式锁：客户端在执行操作之前需要先获取分布式锁</li>
</ol>
<h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><blockquote>
<p>分布式锁是控制分布式系统之间同步访问共享资源的方式。在分布式系统中，多个系统共享一个资源，使用分布式锁来保证数据一致性</p>
</blockquote>
<h4 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h4><div class="note info"><p>使用set lock_key random_value nx px n完成加锁（一次原子性的setnx+expire），解锁时先get根据random_value判断是否是锁的拥有者，再进行del。为了保证原子性，使用lua脚本.</p></div>

<div class="note info"><p>使用redisson实现，方法1的实现锁不具有可重入性。redisson加解锁过程如下：</p>
<ol>
<li>加锁：通过tryAcquire来获取锁，如果返回的ttl为空表示加锁成功。加锁失败则会订阅该锁的channel，等待锁被释放的消息，再重新获取锁。tryAcquire中使用lua脚本来加锁，锁使用hash结构来实现。hexists判断锁是否存在，不存在则hset加锁成功，存在则判断是否是当前线程的锁，是则hincrby将count+1（可重入锁），否则返回锁的过期时间。</li>
<li>解锁：同样使用lua脚本。先判断锁是否存在，不存在则publish发布释放锁的消息，解锁成功。锁存在则判断是否是当前线程的锁，如果是通过hincrby将count-1，当count为0，将del锁并publish释放锁的消息，如果不是则抛出异常。</li>
</ol></div>

<h4 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h4><div class="note info"><p>redlock算法：根据<a href="http://redis.cn/topics/distlock.html/" target="_blank" rel="noopener">redis官网</a>描述总结。假定有5个redis实例，且相互独立，没有主从关系（原因是防止master节点没来得及把新set的锁复制到slave上）。</p>
<ol>
<li>尝试向五个实例获取锁</li>
<li>超过获取锁的限制时间则跳到下一个实例</li>
<li>超过半数（这里是3个）成功加锁并且消耗的总时间小于锁的过期时间则加锁成功</li>
<li>加锁失败/释放锁，将向<strong>所有实例</strong>发出解锁请求。因为可能存在某个节点set成功但是由于网络问题客户端没有接收到其响应，因此需要向所有节点发出解锁请求</li>
<li>redlock采用<strong>延时重启</strong>来解决故障重启后带来的安全性问题：A B C三个节点，客户端1请求加锁在A B上获得成功，1获取锁。然后B宕机重启，由于持久化策略等问题，导致B上的锁没有被恢复，此时客户端2请求相同的锁，在BC上获取成功，这样客户端1和2就持有了相同的锁。</li>
</ol></div>

<div class="note info"><p>zookeeper：客户端每次请求一把锁，就在zookeeper对应节点目录下创建一个有序节点，只需要比较节点的顺序就可以判断是否成功获取锁。</p></div>

<h2 id="redis单点-单机会有什么问题-挂掉怎么办？"><a href="#redis单点-单机会有什么问题-挂掉怎么办？" class="headerlink" title="redis单点/单机会有什么问题/挂掉怎么办？"></a>redis单点/单机会有什么问题/挂掉怎么办？</h2><p>为了避免redis单机挂掉的问题，我们可以搭建redis集群来保证redis服务的高可用。redis集群有以下三种模式：</p>
<ol>
<li><p>主从模式：实现读写分离，主节点的数据通过全量/增量同步发送到从节点上</p>
</li>
<li><p>哨兵模式：主从模式升级版，哨兵监听主节点的状态，发现宕机后选出新的主节点</p>
</li>
<li><p>集群模式：一个redis cluster由多个redis节点组组成，每个节点组内由主从节点，负责数据的一个/多个分片-slot。</p>
</li>
</ol>
<div class="note info"><p><strong>配置的一致性</strong>：集群中的每个节点都保存了集群的配置信息，通过一个全局的版本号epoch来保证信息的一致。各节点之间通过频繁的ping/pong消息携带的gossip部分更新自己对集群的认识。当某个节点率先感知了集群的变化后，自增自身的epoch并将其通过ping/pong消息扩散出去，其他节点发现接收到的epoch＞自身于是更新自身关于集群的信息。</p>
<p><strong>数据分片</strong>：cluster中节点组之间负责的数据互相独立，客户端需要通过一致性哈希算法将key映射到0-16383个slot中的一个上，找到对应的redis节点。当请求的key不在节点上（发生了数据迁移），会返回moved/ask消息告知客户端.</p>
<p><strong>Failover保证高可用</strong>：故障发现、故障确认、主备切换机制</p>
<ol>
<li><p>故障发现：各节点在进行ping/pong交换信息时，如果一个节点A的ping消息超时没有收到对端B的pong回复，则会在自身集群信息中将该节点状态设置为pfail，并通过和其他节点的ping/pong将此信息传递到整个集群。</p>
</li>
<li><p>故障确认：节点A在1之后，如果接收到其他节点的gossip消息中B也为pfail状态，则会将B的状态升级为fail，确认故障，然后发起slave选举流程。</p>
</li>
<li><p>slave选举：A作为B的salve在确认B为故障节点后，发起竞选：将自己的epoch自增并发送FAILOVER_AUTH_REQUEST到其他的master节点，如果master未收到过FAILOVER_AUTH_REQUEST(收到时的自身epoch小于FAILOVER_AUTH_REQUEST中的epoch)，则回复同意，否则拒绝。当A收到超过半数的master同意之后，将替代B称为master节点，更新自己的epoch，通过配置一致性完成集群结构的更新。当B回复正常后，通过与其他节点的gossip消息可以得知新的master节点为A，自己将会成为A的slave节点。</p>
</li>
</ol></div>

<details><summary>数据迁移</summary>
    当加入新的master节点/ 旧的节点组下线/负载不均衡需要调整时，会发生数据迁移，迁移过程：<br/>
    1. 设置slot原所在节点A状态为migrating,slot新节点B状态为importing.<br/>
    2. 针对A上的slot的所有key，分别发送migrate命令将数据迁移到B.<br/>
    migrating的A：如果请求的key尚未迁出则正常提供服务；如果已经迁出则使用ask回复让客户端跳转到B.<br/>
    importing的B：如果请求不是由ask跳转的则通过moved让客户端跳转到A上.<br/>
    这样的跳转控制可以让同一个key操作迁移之前在原节点执行，迁移之后在新节点执行，避免冲突。迁移完成之后，通过配置的一致性让整个集群更新配置。
</details>

<details><summary>moved和ask</summary>moved会更新client的路由缓存，即moved之后对相同的key操作会直接到新节点上，ask操作只是单次的，之后相同的key还是回到原来的节点上</details>

<h2 id="如何保证缓存和数据库的一致性？"><a href="#如何保证缓存和数据库的一致性？" class="headerlink" title="如何保证缓存和数据库的一致性？"></a>如何保证缓存和数据库的一致性？</h2><p>如果要求数据库和缓存的实时一致性，那么只能串行化地执行读写请求。一般来说允许缓存和数据库出现短暂的不一致。最经典的方式是先更新数据库，再删除缓存。读请求先查缓存，缓存没有则查询数据库，将查询结果放入缓存中，返回响应。更新时，先更新数据库，再删除缓存。</p>
<h3 id="为什么是删除缓存，而不是更新缓存？"><a href="#为什么是删除缓存，而不是更新缓存？" class="headerlink" title="为什么是删除缓存，而不是更新缓存？"></a>为什么是删除缓存，而不是更新缓存？</h3><p>在复杂一点的缓存场景中，缓存中的数据并不是简单的从数据库中直接获取。存入缓存的数据可能需要进行多表查询并进行计算得到。所以更新缓存的成本是比较高的。除此之外，缓存的数据如果来自一张频繁更新的表，但是缓存却较少的被访问，也会造成资源的浪费。因此采用删除缓存，是一种懒加载的思想，等到需要的时候发现缓存中没有再查询数据库将结果放入缓存。</p>
<h3 id="先更新数据库再删除缓存就一定能保证一致性吗？"><a href="#先更新数据库再删除缓存就一定能保证一致性吗？" class="headerlink" title="先更新数据库再删除缓存就一定能保证一致性吗？"></a>先更新数据库再删除缓存就一定能保证一致性吗？</h3><p>不一定，在更新完数据库之后，如果删除缓存失败，此时缓存中是旧的数据，而数据库是新的数据，出现了不一致。解决方法是：先删除缓存，再更新数据库。如果更新数据库失败了，再次请求则会去读取旧的数据，不会产生数据不一致。</p>
<h3 id="这样就没问题了吗？"><a href="#这样就没问题了吗？" class="headerlink" title="这样就没问题了吗？"></a>这样就没问题了吗？</h3><p>如果在并发量较低的情况下，一般不会出现问题。但是当并发量较大，对一个数据并发读写就可能出现：如果在删除完缓存之后，尚未完成更新，此时另一个请求到来，发现没缓存，于是查数据库，存入缓存，并返回结果。之后数据库完成了更新，此时数据库和缓存再次出现不一致。<strong>解决方案</strong>：串行化。一个更新数据的操作，“删除缓存+更新数据库”，将其路由到一个jvm的队列中。读取数据的操作，如果发现缓存中没有数据，则将“读取数据+更新缓存”的操作也放入一个jvm的工作队列中。一个工作线程对应一个队列，线程从队列中获取操作并执行，这样，更新数据的操作将顺序执行删除缓存，然后更新数据库，在数据库未更新完成之前，如果有读取数据的请求，发现缓存中没有数据，将进入工作队列中，等待前一个更新操作完成之后，再执行“读取数据+更新缓存”的操作，保证了数据的一致性。</p>
]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-03. 数组中重复的数字</title>
    <url>/posts/2f50b40c.html</url>
    <content><![CDATA[<blockquote>
<p>找出数组中的重复数字</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内，其中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中的任意一个重复的数字。</p>
</blockquote>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>重复的数字在数组中出现次数会大于1。在遍历数组的过程中，使用HashSet来记录出现过的数字，当HashSet中存在该元素时，说明重复，返回该元素即可。由于数字范围在 0~n-1 范围内，因此可以使用一个数组来记录某个元素出现的次数达到优化的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(freq[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            freq[i] ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-优化"><a href="#✍️-优化" class="headerlink" title="✍️ 优化"></a>✍️ 优化</h3><p>暴力解法的实践和空间复杂度均达到了O(N)，本题由于数组数字范围和长度相同，因此可以将原数组作为哈希表，达到优化空间的目的，但是会<strong>修改输入</strong>。</p>
<p>由于数字范围和数组长度一致，如果没有重复数字，那么每个位置上在排序后的状态下数字和位置是一一对应的，但是我们并不做排序这个工作，因为这样时间复杂度是O(nlogn)级别的。我们只是利用这一特征，遍历数组时，如果当前数字和位置不对应，则将当前数字交换到它应该在的位置上。如果应该在的位置上已经有了正确的数字，那么说明当前数字就是重复的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = nums[nums[i]];</span><br><span class="line">            nums[nums[i]] = nums[i];</span><br><span class="line">            nums[i] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>数组</tag>
        <tag>哈希</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础问题总结</title>
    <url>/posts/503970b4.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<div class="note info"><p>长文预警  🤣 谨慎食用 💡 善用搜索和目录</p></div>

<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="说说Java语言的特点？"><a href="#说说Java语言的特点？" class="headerlink" title="说说Java语言的特点？"></a>说说Java语言的特点？</h3><ol>
<li>平台无关性：实现一次编译，到处运行</li>
<li>相对安全的内存管理和访问机制，避免大部分内存泄露和指针越界</li>
<li>热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能</li>
</ol>
<h3 id="Java如何实现平台无关？"><a href="#Java如何实现平台无关？" class="headerlink" title="Java如何实现平台无关？"></a>Java如何实现平台无关？</h3><p>Java的源代码经过编译后生成的字节码是和计算机体系结构无关的指令，可以在任何机器上解释执行，动态地转换成本地机器代码，而这个过程是由JVM完成的，不同平台使用不同的JVM，屏蔽了不同操作系统的差异。</p>
<h3 id="Java是值传递还是引用传递？"><a href="#Java是值传递还是引用传递？" class="headerlink" title="Java是值传递还是引用传递？"></a>Java是值传递还是引用传递？</h3><blockquote>
<p>值传递是指方法接收调用者提供的值，引用传递是指方法接收调用者提供的变量地址</p>
</blockquote>
<p>Java是值传递，方法接受的是参数的副本，对于基本数据类型，改变入参不会影响实参；对于对象，接受的是对象的引用，改变其属性值会影响实参，但是改变这个引用并不会让实参引用新的对象</p>
<h3 id="谈谈深拷贝和浅拷贝？"><a href="#谈谈深拷贝和浅拷贝？" class="headerlink" title="谈谈深拷贝和浅拷贝？"></a>谈谈深拷贝和浅拷贝？</h3><p>深拷贝完全拷贝基本数据类型和引用数据类型，浅拷贝值复制基本引用类型和引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。</p>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射是指在运行状态中，可以获得任意一个类的属性和方法，可以调用任意一个对象的方法和属性。反射破坏了<strong>封装性</strong>和<strong>泛型约束</strong>。</p>
<h3 id="Class类的作用？"><a href="#Class类的作用？" class="headerlink" title="Class类的作用？"></a>Class类的作用？</h3><p>在程序运行期间，Java运行时系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是Class，可以通过<code>类名.class</code>、<code>对象.getClass()</code>、<code>Class.forName(类的全限定名)</code>来获取Class对象</p>
<h3 id="什么是注解、元注解？"><a href="#什么是注解、元注解？" class="headerlink" title="什么是注解、元注解？"></a>什么是注解、元注解？</h3><p>注解是一种标记，使类/接口/方法/属性附加额外信息，完成特定功能。</p>
<p>元注解是注解的注解，用于标识注解的相关信息。</p>
<ol>
<li>@Target({参数列表})：注解作用域，可填参数为：CONSTRUCTOR-构造方法、FIELD-属性、METHOD-方法、PACKAGE-包、LOCAL_VARIABLE-局部变量、TYPE-类/接口</li>
<li>@Retention(参数)：生命周期，可填参数为：RUNTIME-运行时注解，可以通过<strong>反射</strong>获取、SOURCE-源代码注解、CLASS-编译时注解，运行时注解</li>
<li>@Inherited：可继承到子类，但不能继承到子类的方法</li>
<li>@Document：生成java-doc会包含注解信息</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">如何获取注解</div></div><div class="fold">
<p>通过反射获取运行时的注解信息，getAnnotations方法</p>

</div></div>

<h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>泛型可以看作一种数据类型，用来接收未知的数据类型，解决不确定对象具体类型时可能发生强制转换异常等问题，Java中的泛型时防止有效输入的，在编译器有效。通过反编译可以看到如果泛型T没有被指定，则会转换为多态，即类型声明为Object；在使用对应数据时将在返回之前加一条checkcast来做类型转换。</p>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>Throwable下有Error和Exception，Error用来标识JVM无法处理的错误，Exception分为受检异常和不受检异常，也叫编译期异常和运行时异常，编译期异常如果不处理会编译失败，运行时异常可以通过编译，RuntimeException及其所有子类都是运行时异常，除此之外都是编译期异常。其体系结构图如下：</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004710.png" alt="图片"></p>
<p>处理过程参见<a href="/posts/f885a170.html" title="Java异常体系">Java异常体系</a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol>
<li>byte：1字节</li>
<li>char：2字节</li>
<li>int：4字节</li>
<li>short：2字节</li>
<li>long：8字节</li>
<li>float：4字节</li>
<li>double：8字节</li>
<li>boolean：JVM编译时会转为int类型存储，true-&gt;1,false-&gt;0</li>
</ol>
<h3 id="包装类型自动装箱-拆箱是什么？"><a href="#包装类型自动装箱-拆箱是什么？" class="headerlink" title="包装类型自动装箱/拆箱是什么？"></a>包装类型自动装箱/拆箱是什么？</h3><div class="note info"><p>每个基本数据类型都有自己的包装类型，之间的自动转化称为拆箱和装箱。封装成包装类型主要是面向对象的设计，可以提供更方便的操作某种数据类型的方法，例如<code>parseInt()</code>。</p>
<p>包装类型设有缓存池，在使用<code>valueOf()</code>的方法时先查看是否在缓存池中，没有再通过 <code>new Integer()</code>在堆中创建一个新对象。</p></div>

<h3 id="String为什么是不可变对象？但是又可以修改它的值？"><a href="#String为什么是不可变对象？但是又可以修改它的值？" class="headerlink" title="String为什么是不可变对象？但是又可以修改它的值？"></a>String为什么是不可变对象？但是又可以修改它的值？</h3><p>在Java中String被<strong>final</strong>关键字修饰，因此是不可被继承的。存储字符串内容的char数组也通过<strong>final</strong>修饰，并且不提供修改数组的方法，因此String是不可变的。Java9中改用byte数组存放，并用coder指定编码类型（0-单字节Latin-1，1-双字节UTF-16）。主要是为了节省空间。</p>
<p>对一个String对象的修改实际上都是创建了一个新String对象，再引用该对象。</p>
<h3 id="String和StringBuidler和StringBuffer的区别"><a href="#String和StringBuidler和StringBuffer的区别" class="headerlink" title="String和StringBuidler和StringBuffer的区别"></a>String和StringBuidler和StringBuffer的区别</h3><p>String字符串相加时底层通过StringBuilder实现，但每次都会新生成一个StringBuidler对象且最终通过toString方法返回拼接后的字符串。StringBuilder可解决在字符串相加时创建多个字符串占用空间多效率低下的问题，底层是未被final修饰的初始容量为16的byte数组，可自动扩容。StringBuffer使用synchronized修饰，线程安全。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="谈谈你对面向对象的理解？"><a href="#谈谈你对面向对象的理解？" class="headerlink" title="谈谈你对面向对象的理解？"></a>谈谈你对面向对象的理解？</h3><p>面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型项目，模块之间耦合严重，面向对象区别与面向过程，强调高内聚低耦合，对现实事物进行抽象并映射成对象，定义共性行为，再解决实际问题。</p>
<h3 id="面向对象的三个特性？"><a href="#面向对象的三个特性？" class="headerlink" title="面向对象的三个特性？"></a>面向对象的三个特性？</h3><ol>
<li>封装：是对象功能内聚的表现形式，对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单。</li>
<li>继承：用来扩展一个类，子类继承父类的部分属性和行为使模块具有复用性，继承是“is a”的关系。</li>
<li>多态：以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。因为在编译时无法确定最终调用的方法体，在运行时由JVM动态绑定，调用合适的重写方法。</li>
</ol>
<h3 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h3><ol>
<li>重载：在同一个类中，对同名函数的不同实现，其参数类型/顺序/个数不同。但不能以返回值来作为标准，因为我们在调用方法时有时并不关注返回值。对于编译器来说，方法名称和参数列表构成了一个唯一的方法签名，重载在编译时就知道该调用哪个方法，因此属于静态绑定，并不属于<strong>多态</strong>。</li>
<li>重写：在子类中，重写父类方法，要求返回相同类型或子类型，且访问权限不能变小，抛出的异常类型不能变大。</li>
</ol>
<h3 id="对象的通用方法？"><a href="#对象的通用方法？" class="headerlink" title="对象的通用方法？"></a>对象的通用方法？</h3><ol>
<li>equals：判断对象是否相等，默认使用==，可重写equals方法实现自定义比较逻辑。对于基本数据类型，判断值是否相等，对于引用类型，判断是否引用自同一对象</li>
<li>hashCode：对象的散列值，等价的对象散列值一定相等，反之不然。在重写equals方法时应同时重写hashCode，保证等价的对象散列值相等</li>
<li>toString：默认返回类名+@+数值，数值为散列值的无符号十六进制表示</li>
<li>clone：克隆，默认用protected修饰，如果没有显式重写clone方法编译器报错时protected的访问错误了；如果重写了clone但没有让类实现Cloneable接口，将会抛出CloneNotSupported异常。默认实现的是浅拷贝，可以通过重写实现深拷贝</li>
<li>getClass：获取对象的类类型</li>
<li>finalize：在对象被回收时可能被调用。在finalize中重新与引用链上的对象建立关联就可以被移出回收集合不被回收</li>
<li>作为锁的几个方法：wait、notify、notifyAll</li>
</ol>
<h3 id="内部类的作用是什么，有哪些分类？"><a href="#内部类的作用是什么，有哪些分类？" class="headerlink" title="内部类的作用是什么，有哪些分类？"></a>内部类的作用是什么，有哪些分类？</h3><p>内部类方法可以访问定义这个内部类的作用域中的数据，包括private。编译器会将内部类转换为常规的类文件，以$分隔外部类和内部类名。</p>
<ol>
<li>静态内部类：只加载一次，可通过外部类名.内部类名直接访问，可以访问外部类的所有静态属性和方法。HashMap的Node节点、ReentrantLock中的Sync都是静态内部类</li>
<li>成员内部类：外部类的每个对象都会加载一次，不可以定义静态成员和方法，可访问外部类的所有内容</li>
<li>局部内部类：定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法</li>
<li>匿名内部类：只用一次的没名字的类，字节码文件以数字编号命名</li>
</ol>
<h3 id="接口和抽象类的异同？"><a href="#接口和抽象类的异同？" class="headerlink" title="接口和抽象类的异同？"></a>接口和抽象类的异同？</h3><blockquote>
<p>接口和抽象类对实体类进行更高层次的抽象，仅定义公共行为和特征。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员变量</td>
<td align="center">无要求</td>
<td align="center">默认public static final常量</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="center">有构造方法，不能实例化</td>
<td align="center">没有构造方法，不能实例化</td>
</tr>
<tr>
<td align="center">方法</td>
<td align="center">抽象类可以没有抽象方法，但有抽象方法一定是抽象类</td>
<td align="center">默认public abstract，JKD8支持默认/静态方法，JDK9支持私有方法</td>
</tr>
<tr>
<td align="center">继承</td>
<td align="center">单继承</td>
<td align="center">多继承</td>
</tr>
</tbody></table>
<p>抽象类体现is-a关系，接口体现like-a关系。抽象类是对同类事物相对具体的抽象，接口是对行为的定义。</p>
<h3 id="子类初始化顺序？"><a href="#子类初始化顺序？" class="headerlink" title="子类初始化顺序？"></a>子类初始化顺序？</h3><p>父类静态代码块和静态变量-&gt;子类静态代码块和静态变量-&gt;父类普通代码块和普通变量-&gt;父类构造方法-&gt;子类普通代码块和普通变量-&gt;子类构造方法</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="说一说ArrayList"><a href="#说一说ArrayList" class="headerlink" title="说一说ArrayList"></a>说一说ArrayList</h3><p>ArrayList是容量可变的非线程安全列表，使用数组实现，因此支持对元素的快速随机访问，但是插入和删除速度慢，扩容时会创建更大的数组，把原有数组复制到新数组。</p>
<ol>
<li>elementData是ArrayList的数据域，被transient修饰，序列化时会调用writeObject写入流，反序列化时调用readObject重新赋值到新对象的elementData</li>
<li>size是当前实际大小，即为elementData大小</li>
<li>modCount记录了ArrayList结构性变化的次数，继承自AbstractList，所有涉及结构变化的方法都会增加该值。通过比较expectModCount和modCount值是否相等，抛出ConcurrentModificationException，保证了在序列化和迭代过程中数组不会被修改，称为<strong>fail-fast</strong>机制</li>
</ol>
<h3 id="说一说LinkedList"><a href="#说一说LinkedList" class="headerlink" title="说一说LinkedList"></a>说一说LinkedList</h3><p>LinkedList本质是双向链表，在插入和删除上速度更快，但是随机访问元素慢，实现了Deque接口，具有队列和栈的性质。通过附加引用的方式将零散的内存单元关联起来，内存利用率高</p>
<h3 id="Set有什么特点，有哪些实现？"><a href="#Set有什么特点，有哪些实现？" class="headerlink" title="Set有什么特点，有哪些实现？"></a>Set有什么特点，有哪些实现？</h3><p>Set不允许元素重复，常用实现有HashSet、LinkedHashSet、TreeSet</p>
<ol>
<li>HashSet：通过HashMap实现，map的key即set存储的元素，所有value都为Object类型常量，不保证有序，线程不安全。对于包装类型通过值判重，对于引用类型，通过hashCode和equals判重</li>
<li>LinkedHashSet：继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序</li>
<li>TreeSet：通过TreeMap实现，添加元素到集合时按照比较规则将其插入到合适的位置，保证集合有序</li>
</ol>
<h3 id="TreeMap有什么特点？"><a href="#TreeMap有什么特点？" class="headerlink" title="TreeMap有什么特点？"></a>TreeMap有什么特点？</h3><p>TreeMap基于红黑树实现，增删改查的平均和最差时间复杂度均为O(logn)，最大特点是key有序，key必须实现Comparable接口或提供Comparator比较器，因此不能为null。</p>
<p>在排序时，如果比较器不为空，则通过比较器的compare方法，否则使用key实现的Comparable接口的compareTo方法，如果都没有则抛出异常。</p>
<p>关于红黑树的其他特性，参见<a href="/posts/75890e6e.html" title="红黑树基础">红黑树基础</a></p>
<h3 id="HashMap相关问题"><a href="#HashMap相关问题" class="headerlink" title="HashMap相关问题"></a>HashMap相关问题</h3><h4 id="HashMap有什么特性？"><a href="#HashMap有什么特性？" class="headerlink" title="HashMap有什么特性？"></a>HashMap有什么特性？</h4><ol>
<li>HashMap存储键值对实现快速存取，允许为null（因为对null做了特殊处理），key不可重复，重复则覆盖原值</li>
<li>非同步，线程不安全</li>
<li>无序</li>
</ol>
<h4 id="HashMap底层原理是什么？"><a href="#HashMap底层原理是什么？" class="headerlink" title="HashMap底层原理是什么？"></a>HashMap底层原理是什么？</h4><p>在JDK8之前底层实现是数组+链表，在JDK8改为数组+链表/红黑树，节点类型从Entry变为Node。成员变量包括存储数据的table数组、元素数量size、负载因子loadFactor。默认初始化容量是16，扩容容量必须是2的幂，默认负载因子为0.75</p>
<h4 id="如何计算key在table数组中的位置？"><a href="#如何计算key在table数组中的位置？" class="headerlink" title="如何计算key在table数组中的位置？"></a>如何计算key在table数组中的位置？</h4><p>在JDK8之前：对于字符串类型，调用stringHash32计算；对于其他类型，使用一个不变的随机值hashSeed和key的hashCode异或之后，再通过移位和异或，最终和表的长度与运算获得最终的地址。这样既减少了哈希冲突又比取模效率更高</p>
<p>在JDK8：当key为null时，返回0；否则通过key的hashCode与高16位做异或运算得到在数组中的位置，这种hash计算将高位的变化扩展到低位，避免因表范围的限制，高位不会在索引计算中使用，可以减少哈希冲突。</p>
<h4 id="get函数的实现？"><a href="#get函数的实现？" class="headerlink" title="get函数的实现？"></a>get函数的实现？</h4><p>① JDK8之前：</p>
<div class="note warning"><p>key为null，调用getForNullKey方法，如果size为0表示链表为空，返回null；否则遍历table[0]链表，找到key为null的节点则返回其value，否则返回null。</p></div>

<div class="note info"><p>key不为null，调用getEntry方法，当size不为0，计算key的hash值，遍历对应位置的链表，如果key和hash都相等则返回该节点的value</p></div>

<p>② JDK8：</p>
<p>调用getNode函数，如果table数组不为空，则判断第一个节点和查找的key和hash相等则返回；否则判断其他节点，如果是TreeNode则以getTreeNode在树中查找，否则遍历链表查找，最终返回对应的节点的值或null。</p>
<h4 id="put函数的实现？"><a href="#put函数的实现？" class="headerlink" title="put函数的实现？"></a>put函数的实现？</h4><p>① JDK8之前：</p>
<div class="note warning"><p>key为null，直接存入table[0]。</p></div>

<div class="note info"><p>key不为null，计算hash值，遍历对应位置的链表，如果key存在更新value，返回旧value；否则将modCount++，使用addEntry方法增加一个节点并返回null</p></div>

<p>② JDK8：</p>
<p>如果table为空/长度为0则进行扩容，否则计算key对应的位置，不存在则调用newNode创建一个节点。如果存在且是TreeNode，则调用putTreeVal增加一个树节点，并维持平衡；如果是链表，则遍历插入/更新。此时如果树的size超过阈值8则通过treeifyBin方法，当table的长度大于64时将其转为红黑树，没超过时进行扩容。</p>
<h4 id="扩容为什么要2的幂，具体是怎么扩容的？"><a href="#扩容为什么要2的幂，具体是怎么扩容的？" class="headerlink" title="扩容为什么要2的幂，具体是怎么扩容的？"></a>扩容为什么要2的幂，具体是怎么扩容的？</h4><p>保证为2的幂首先是在进行hash计算的时候，可以用与来替代取模运算，提高效率，其次可以减少碰撞，均匀分布。</p>
<p>① JDK8之前：</p>
<p>如果当前容量达到了最大容量<code>MAXIMUM_CAPACITY</code>，将阈值设置为Integer最大值，停止扩容；否则计算新容量，将阈值设为<code>newCapacity * loadFactor</code>和<code>MAXIMUM_CAPACITY + 1</code>的较小值，创建新容量的Entry数组，通过transfer将数据转移。遍历链表，重新计算位置，使用头插法将元素转移。</p>
<p>② JDK8：</p>
<p>如果当前容量<code>oldCap</code>达到了最大容量，将阈值设置为Integer最大值，停止扩容；当<code>oldCap&lt;&lt;1</code>不超过最大容量则扩大为两倍；当当前扩容阈值<code>oldThr&gt;0</code>，则将其作为新容量；否则将新容量设为默认的16，阈值为12</p>
<p>数据的转移：当节点为TreeNode，调用split方法对树进行修建，当树的结点数小于6则将其转为链表；当节点为链表，将其拆分为hash值超过旧容量的部分和未超出的部分，对于<code>hash &amp; oldCap = 0</code>的部分不需要处理，否则通过旧下表+旧容量计算出新下标并完成转移。</p>
<h4 id="为什么负载因子是0-75？"><a href="#为什么负载因子是0-75？" class="headerlink" title="为什么负载因子是0.75？"></a>为什么负载因子是0.75？</h4><p>这是个折中的数字，0.5造成了一半空间的浪费，1则在扩容时无法处理其他put，0.75是空间和时间的均衡，避免了较多的hash冲突（实验获得）。</p>
<h4 id="HashMap扩容容易死循环你了解吗？"><a href="#HashMap扩容容易死循环你了解吗？" class="headerlink" title="HashMap扩容容易死循环你了解吗？"></a>HashMap扩容容易死循环你了解吗？</h4><p>在JDK8之前，使用头插法迁移元素，链表节点之间存在指针引用关系，因此在并发修改时容易出现死循环。JDK8改用尾插法，并且没有指针引用关系，解决了死循环的问题。</p>
<p>但是在并发下扩容时容易造成数据丢失：首先是当某个线程在transfer时，其他线程新增的元素可能在已遍历过的链表上，因此这部分数据就丢失了；在多个线程resize的过程中，新创建了多个newTable，这是线程内的局部变量，线程之间不可见，在<code>table=newTable</code>时会覆盖其他线程的操作。因此HashMap是<strong>线程不安全</strong>的。</p>
<h3 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h3><ol>
<li><p>使用synchronized修饰：Vector、HashTable、Collections.synchronizedXX</p>
</li>
<li><p>并发容器：</p>
<div class="note info"><p>CopyOnWriteArrayList：add中使用可重入锁，复制一份，读写分离，在写操作时操作副本，然后将原数组指向新数组，保证最终一致性</p></div>

<div class="note success"><p>ConcurrentHashMap：1.7使用分段锁不锁整张表仅锁住某一段seagment。1.8使用红黑树，通过CAS操作和synchronized保证线程安全同时提高效率。</p></div>

</li>
</ol>
<h2 id="多线程高并发"><a href="#多线程高并发" class="headerlink" title="多线程高并发"></a>多线程高并发</h2><h3 id="JMM是什么？有什么作用？"><a href="#JMM是什么？有什么作用？" class="headerlink" title="JMM是什么？有什么作用？"></a>JMM是什么？有什么作用？</h3><blockquote>
<p>JMM是Java内存模型，JMM主要是影响线程共享的内存可见性问题，Java线程之间的通信由JMM控制。</p>
</blockquote>
<p>所有变量存储于主内存，每个线程有自己的工作内存，保存被该线程使用的变量的主内存副本，线程对变量的操作必须在工作内存中进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存的变量，线程通信必须经过主内存。关于工作内存和主内存的交互，JMM定义了8种原子操作：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">作用变量范围</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock</td>
<td align="center">主内存</td>
<td align="center">把变量标识为线程独占状态</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">主内存</td>
<td align="center">释放处于锁定状态的变量</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">主内存</td>
<td align="center">把变量从主内存传到工作内存</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">工作内存</td>
<td align="center">把read的值放入工作内存的变量副本</td>
</tr>
<tr>
<td align="center">use</td>
<td align="center">工作内存</td>
<td align="center">把工作内存的变量值传给执行引擎</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">工作内存</td>
<td align="center">把从执行引擎接收的值赋给工作内存的变量</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">工作内存</td>
<td align="center">把工作内存的变量值传到主内存</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">主内存</td>
<td align="center">把store取到的变量值放入主内存变量</td>
</tr>
</tbody></table>
<h3 id="什么是指令重排序？"><a href="#什么是指令重排序？" class="headerlink" title="什么是指令重排序？"></a>什么是指令重排序？</h3><p>为了提高性能，编译器和处理器通常会对指令进行重排序，重排序指从源代码到指令序列的重排序，分为以下三种：</p>
<ol>
<li>编译器优化的重排序：在不改变单线程程序语义的前提下重排语句的执行顺序</li>
<li>指令级并行的重排序：如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序</li>
</ol>
<h3 id="as-if-serial和happens-before了解吗？"><a href="#as-if-serial和happens-before了解吗？" class="headerlink" title="as-if-serial和happens-before了解吗？"></a>as-if-serial和happens-before了解吗？</h3><p>as-if-serial语义是指不论如何重排序，<strong>单线程</strong>程序的执行结果不能改变。因此，编译器和处理器不会对存在数据依赖关系的操作重排序</p>
<p>happens-before是先行发生原则，对有顺序性保障的禁止重排序，保证了正确同步的<strong>多线程</strong>程序的执行结果不变</p>
<p>两者都是为了不改变程序执行结果的前提下尽可能提高程序执行<strong>并行度</strong></p>
<h3 id="什么是原子性、可见性、有序性？"><a href="#什么是原子性、可见性、有序性？" class="headerlink" title="什么是原子性、可见性、有序性？"></a>什么是原子性、可见性、有序性？</h3><ol>
<li>原子性：基本数据类型的访问都具备原子性，但是64位长度的long和double需要被划分为两次32位操作，因此不具备原子性。更大范围的原子性，JMM提供了lock和unlock操作，对应到更高层次的字节码指令monitorenter和monitorexit，也就是Java代码中的synchronized</li>
<li>可见性：指当一个线程修改了共享变量之后，其他线程能够立即得知修改。JMM通过在变量修改后将值同步会主内存，在变量读取前从主内存刷新的方式实现可见性。volatile通过这种方式保证可见性，synchronized则通过unlock前必须先执行sotre和write来保证</li>
<li>有序性：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句指as-if-serial语义，后半句指指令重排序和工作内存与主内存延迟现象。</li>
</ol>
<h3 id="对volatile有什么理解？"><a href="#对volatile有什么理解？" class="headerlink" title="对volatile有什么理解？"></a>对volatile有什么理解？</h3><p>volatile的内存语义是：在写一个volatile变量时，把该线程工作内存的值立即刷新到主内存中；在读一个volatile变量时，把该线程的工作内存值置为无效，从主内存中读取</p>
<p>当变量被volatile修饰后，具备两种特性：</p>
<ol>
<li>保证变量对所有线程可见</li>
<li>禁止指令重排序优化：在写操作之前，汇编指令有<strong>lock</strong>前缀，相当于一个内存屏障，后面的指令不能排在内存屏障之前，同时会先对缓存变量做一次<strong>store和write</strong>操作，写回主内存中</li>
</ol>
<h3 id="final可以保证可见性吗？"><a href="#final可以保证可见性吗？" class="headerlink" title="final可以保证可见性吗？"></a>final可以保证可见性吗？</h3><p>可以，被final修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把this引用传递出去（this引用逃逸），在其他线程中就能看见final字段值。</p>
<p>JMM禁止把<strong>写final域</strong>重排序到构造方法之外，在写final之后，构造方法return之前，有一个<strong>Store屏障</strong>，确保在对象引用为其他线程课件只之前，对象的final域已初始化过。</p>
<p>在初次<strong>读final域</strong>时，JMM要求必须先读这个final域所在的对象引用，通过一个<strong>Load屏障</strong>，确保初次读对象引用和初次读final域不会被重排序</p>
<h3 id="谈一谈synchronized"><a href="#谈一谈synchronized" class="headerlink" title="谈一谈synchronized"></a>谈一谈synchronized</h3><p>synchronized关键字解决的是多个线程之间访问同一资源的同步问题，被synchronized修饰的同步代码块可以保证在任意时刻只能有一个线程执行。可以通过javap看到相关的字节码，在进入和退出同步块时有monitorenter和monitorexit指令，这里的monitor是存在Java对象头中的监视器，对象头中有两部分数据，一是classPointer指向对象的类，二是MarkWord，存储运行时对象的各种信息，包括hashCode、gc年龄、<strong>锁状态</strong>等。锁状态由锁标志位标识，标志位的指针指向monitor对象。</p>
<h4 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//指向拥有锁的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程进入同步代码块后，首先进入<strong>_EntryList</strong>，当线程获取对象的monitor之后，将 <strong>_owner</strong> 设置为当前线程，同时<strong>count</strong>++；当线程调用<strong>wait</strong>方法，将释放当前持有的monitor， <strong>_owner</strong>设置为null，<strong>count</strong>–，同时进入 <strong>_WaitSet</strong>等待被唤醒；当前线程执行完毕后，也将释放monitor，同时复位<strong>count</strong>，以便其他线程进入获取monitor</p>
<h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><p>在早期版本中，synchronized属于重量级锁，基于操作系统底层的<strong>MutexLock互斥锁</strong>来实现，线程的挂起和切换需要从用户态到内核态的转换，时间成本高；JDK6对synchronized做了优化，引入了自旋锁、偏向锁、轻量级锁、锁粗化和锁消除等，提高锁的效率，因此锁一共有四个状态，分别是无锁（01-0）、偏向锁（01-1）、轻量级锁（00）、重量级锁（10）</p>
<ol>
<li>自旋锁：如果获取不到锁则会等待一段时间，不直接挂起线程，避免上下文切换的时间消耗。后来又引进了<strong>自适应自旋锁</strong>，其等待次数是自适应的，更加聪明</li>
<li>偏向锁：认为每次获取当前锁的都是同一线程，对象头MarkWord中的偏向线程ID存储了这个线程，因此加锁时只需要检查MarkWord中的偏向线程iID是否是当前线程，如果是则直接获取锁，否则就要检测当前锁状态是否是偏向锁，如果是则将当前线程id设置到MarkWord中的偏向线程ID，否则通过CAS竞争锁。此时如果有第二个线程竞争锁，会发现偏向线程id已指向了线程1，则出现了锁竞争，会触发重新偏向或升级到轻量级锁，大部分情况下是升级</li>
<li>轻量级锁：线程1获取锁，如果锁为无锁状态，将MarkWord拷贝到当前线程栈帧中的锁记录LockRecord，JVM将通过CAS尝试将MarkWord中的Lock Word指向LockRecord、将LockRecord的owner指向MarkWord，如果成功则将对象锁状态更新为轻量级锁，否则表示当前轻量级锁已经被获取了，将进入自旋，达到一定次数后膨胀为重量级锁（将MarkWord指向<strong>互斥量Mutex</strong>）。在释放锁时如果CAS将当前线程的LockRecord替换为MarkWord成功，则释放锁成功，进入无锁状态，否则说明MarkWord已经指向互斥量，锁为重量级锁，需要通知被阻塞的线程</li>
<li>重量级锁：当线程想要获取锁发现是重量级锁时，将被阻塞，等待锁释放时被唤醒。这样的操作需要操作系统来执行，从<strong>用户态转换为内核态</strong>，开销大，耗时。</li>
</ol>
<h4 id="什么是锁消除、锁粗化？"><a href="#什么是锁消除、锁粗化？" class="headerlink" title="什么是锁消除、锁粗化？"></a>什么是锁消除、锁粗化？</h4><ul>
<li><p>锁消除：JVM判断不存在竞争，则不进行加锁，节省无意义的加解锁。</p>
</li>
<li><p>锁粗化：一般来讲，我们尽量的让同步代码块的范围更小，这样影响的范围会更小，<strong>并发程度高</strong>，即使存在竞争也不需要等待太长时间，但是如果有一连续的加锁解锁，那么反而会造成性能降低 因此锁粗化就是在这种情况下，一连续的加锁解锁<strong>合并</strong>成一次加锁解锁，扩展锁的范围</p>
</li>
</ul>
<h3 id="什么是CAS？它会有什么问题？"><a href="#什么是CAS？它会有什么问题？" class="headerlink" title="什么是CAS？它会有什么问题？"></a>什么是CAS？它会有什么问题？</h3><p>CAS是指Compare And Swap，比较并交换，有3个操作数，分别是内存位置V、旧的预期值A和准备设置的新值B。CAS指令执行时，当且仅当V的值为A时，处理器才会用B更新V的值。其处理过程是原子操作，不会被其他线程打断。</p>
<p>从语义上来说，如果V初次读取时A，并且在准备更新时仍为A，这并不能说明它没有被修改过，因为它可能已经<strong>先变为C再被改回A</strong>，但是CAS是察觉不到的，这个问题称为<strong>ABA问题</strong>。可以通过引入版本号、时间戳来解决这一问题。</p>
<h3 id="了解ReentrantLock吗？和synchronized有什么区别"><a href="#了解ReentrantLock吗？和synchronized有什么区别" class="headerlink" title="了解ReentrantLock吗？和synchronized有什么区别"></a>了解ReentrantLock吗？和synchronized有什么区别</h3><p>ReentrantLock是JUC Lock接口的实现，synchronized是由JVM实现的，很多优化并不直接暴露给我们，ReentrantLock是API层面实现的，比synchronized拥有更细粒度的控制和更高级的功能，可实现中断响应、限时等待、等待通知、公平锁等。在性能上，JDK6之后做了许多优化，二者性能基本持平</p>
<ol>
<li>中断响应：通过lockInterrupt获取锁，能在获取过程中响应中断，如果中断则不再等待获取锁直接返回。而不响应中断的获取锁则是等待到获取锁成功再将线程置于中断状态</li>
<li>等待通知：通过Condition的await将当前线程放入等待队列，直到获得信号唤醒线程，可以通过多个Condition实现<strong>选择性唤醒</strong></li>
<li>公平锁：按照先来先服务的原则，等待时间长的先获得锁，代码上通过<code>!hasQueuedPredecessors</code>来判断是否有之前已经在等待的线程，再CAS获取锁</li>
<li>可重入锁：已获取锁的线程可以<strong>重复获取</strong>锁</li>
</ol>
<h3 id="你提到了JUC，还了解JUC包的其他东西吗？"><a href="#你提到了JUC，还了解JUC包的其他东西吗？" class="headerlink" title="你提到了JUC，还了解JUC包的其他东西吗？"></a>你提到了JUC，还了解JUC包的其他东西吗？</h3><p>JUC的核心是AQS队列同步器，内部维护一个双向等待队列，内部类Node作为结点包含前置后置指针以及线程标识，它使用一个 volatile int state 变量作为共享资源，当state为1则为<strong>独占式</strong>，一次只能有一个线程获取锁，否则为<strong>共享式</strong>；如果线程获取资源失败，则通过addWaiter进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。通过getState/setState/compareAndSetState来进行状态变更。采用<strong>模板方法</strong>设计模式，提供了tryAcquire、tryRelease等方法由子类实现。</p>
<ol>
<li><p>CountDownLatch：用于阻塞线程，等待所有线程（子任务）完成才继续执行，初始化传入子任务数量，通过countDown方法递减，当任务数量为0时await方法返回，继续执行当前线程；可以限制超时时间</p>
</li>
<li><p>Semaphore：信号量，控制并发线程数，初始化传入并发数，每次通过acquire获取一个/多个资源，执行结束后通过release释放，tryAcquire尝试获取，也可以设置超时</p>
</li>
<li><p>CyclicBarrier：多个线程同步等待，await方法会在准备好的线程达到要求的数量返回，继续执行，在count为0时会将count重置为原先输入的数量开启新一轮等待</p>
</li>
<li><p>FutureTask：可以获取线程执行的返回值，可以取消，可以等待</p>
</li>
<li><p>fork/join：切分子任务并行执行，把子任务放在不同的队列，从队列头部取出任务，执行完自己的任务后去其他子线程的任务队列尾部窃取一个任务。</p>
</li>
<li><p>BlockingQueue：阻塞队列，当队列为空时消费者等待新的可消费对象，当队列满时生产者等待被消费再把可消费对象放入队列，有以下几个分类：</p>
<div class="note info"><p>① ArrayBlockingQueue：先进先出，有界</p>
<p>② DelayQueue：延迟队列，按执行时间排序</p>
<p>③ LinkedBlockQueue：无界队列，可不指定大小</p>
<p>④ PriorityBlockQueue：优先级，可插入null对象</p>
<p>⑤ SynchronizedQueue：同步队列，不存储元素，只有元素被消耗才能再次插入</p></div>

</li>
</ol>
<h3 id="创建线程有哪些方式？分别有什么优缺点"><a href="#创建线程有哪些方式？分别有什么优缺点" class="headerlink" title="创建线程有哪些方式？分别有什么优缺点"></a>创建线程有哪些方式？分别有什么优缺点</h3><ol>
<li>使用new Thread创建线程，可以使用实现了Runable和Callable接口的类，后者可以通过FutureTask获取返回值；继承Thread类，重写run方法。使用这种方式性能差，缺乏统一管理，占用过多资源容易导致oom，并且功能单一</li>
<li>使用线程池ThreadPoolExecutor：可重用存在的线程减小对象创建消亡的开销，可以控制最大并发线程数避免阻塞，可以定期执行定时执行单线程并发数控制等</li>
</ol>
<h3 id="线程有哪些方法？"><a href="#线程有哪些方法？" class="headerlink" title="线程有哪些方法？"></a>线程有哪些方法？</h3><ol>
<li>sleep方法会让当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIME_WAITING状态</li>
<li>yield方法会让出CPU时间片，回到RUNNABLE状态，与其他线程一起竞争时间片</li>
<li>join方法用于等待其他线程运行终止，如果当前线程调用了其他线程的join方法，则当前线程进入BLOCKED状态，当另一个线程结束时，当前线程转为RUNNABLE，等待CPU时间片，底层使用的是wait，会释放锁</li>
</ol>
<h3 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h3><ol>
<li>NEW：新建状态，尚未调用start启动</li>
<li>RUNNABLE：Java将操作系统中的就绪和运行两种状态统称为RUNNABLE，此时线程可能在等待时间片或者正在执行</li>
<li>BLOCKED：阻塞状态，可能由于锁被其他线程占用、调用了<code>sleep</code>/<code>join</code>方法</li>
<li>WAITING：等待状态，不会被分配时间片，需要其他线程通知或终端，可能由于调用了无参的<code>wait</code>和<code>join</code>方法</li>
<li>TIME_WAITING：限期等待状态，可以在指定时间内自行返回，可能由于调用了带参的<code>wait</code>和<code>join</code>方法</li>
<li>TERMINATED：终止状态，表示当前线程已执行完毕或异常退出</li>
</ol>
<h3 id="线程通信的方式有哪些？"><a href="#线程通信的方式有哪些？" class="headerlink" title="线程通信的方式有哪些？"></a>线程通信的方式有哪些？</h3><blockquote>
<p>命令式编程中线程通信的方式有共享内存和消息传递两种，在共享内存的并发模型中线程间共享内存的公开状态，通过读-写内存中的公共状态进行隐式通信，在消息传递的并发模型中线程间没有公告状态，必须通过发送消息来显式通信。Java并发采用共享内存模型，线程间的通信隐式进行，对程序员完全透明。</p>
</blockquote>
<p><a href="#对volatile有什么理解？">volatie</a>：读取变量需要从主存中获取，写必须同步刷新回主存，保证所有线程对变量访问的可见性</p>
<p><a href="#谈一谈synchronized">synchronized</a>：确保多个线程在同一时刻只能有一个处于方法/同步块中，保证线程对变量访问的原子性、可见性</p>
<p>wait/notify：等待通知机制，线程A调用了对象的wait方法进入等待状态，线程B调用了对象的notify方法，线程A收到通知后结束组测并执行后续操作</p>
<p>管道I/O流：用于线程间数据传输，媒介为内存，生产者消费者模式</p>
<p><a href="#谈一谈ThreadLocal">ThreadLocal</a>：线程共享变量，可以为每个线程创建单独的副本，副本值时线程私有的，互相之间互不影响</p>
<h3 id="创建线程池有哪些参数，线程池有哪些分类？"><a href="#创建线程池有哪些参数，线程池有哪些分类？" class="headerlink" title="创建线程池有哪些参数，线程池有哪些分类？"></a>创建线程池有哪些参数，线程池有哪些分类？</h3><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><ol>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务执行时最大存活时间</li>
<li>unit：时间单位</li>
<li>threadFactory：线程工厂，用来创建线程</li>
<li>rejectHandler：拒绝策略，默认抛异常，可设为丢弃任务，丢弃最老任务，让当前线程转为执行该任务</li>
</ol>
<div class="note warning"><p>小于核心线程数量：直接创建新线程处理任务。</p></div>

<div class="note info"><p>在核心和最大之间：只有当workingQueue满才创建新线程。</p></div>

<div class="note success"><p>当线程数到达max时，如果阻塞队列未满则放入阻塞队列等待空闲线程处理，否则，根据线程池设置的拒绝策略处理(抛异常等)</p></div>

<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ol>
<li>newFixThreadPool：核心线程和最大线程相同，指定核心线程和最大线程数，采用无界队列，当无空闲线程将任务放到无界队列等待被处理（可能造成<strong>oom</strong>）。适用于<strong>CPU密集型</strong>，确保CPU在长期被工作线程占用时，尽可能减少分配线程，适用执行<strong>长期任务</strong></li>
<li>newCachedThreadPool：核心线程为0，最大线程为整型最大值，使用同步队列，因为没有核心线程所以任务直接放在队列中，如果有空闲线程则取出任务执行，否则创建新线程执行任务。keepAliveTime为60s。适用于<strong>并发执行量大短期的小任务</strong></li>
<li>newSingleThreadPool：核心线程和最大线程都为1，使用无界队列，串行执行任务，keepAliveTime为0，通常是一个线程不停的串行执行所有任务</li>
<li>newScheduleThreadPool：核心可选，最大线程数是整型最大值，keepAliveTime为0，使用延迟队列，线程从延迟队列中取出执行时间大于等于当前时间的任务执行完成后修改该任务的时间为当前时间并放回队列。适用于<strong>周期/定期执行的任务</strong>。</li>
</ol>
<h3 id="线程池有哪些状态？"><a href="#线程池有哪些状态？" class="headerlink" title="线程池有哪些状态？"></a>线程池有哪些状态？</h3><ol>
<li><p>running：可以接受新任务，处理队列中的任务。通过<code>shutdown</code>进入shutdown状态，<code>shutdownNow</code>进入stop状态</p>
</li>
<li><p>shutdown：不再接受新任务，可以处理队列中的任务。等待队列中无任务，正在处理的任务也结束进入tidying状态</p>
</li>
<li><p>stop：不再接受新任务，停止处理正在处理的任务/队列中的任务。进入tidying状态</p>
</li>
<li><p>tidying：线程池的任务数为0。terminate执行完成进入terminated状态。</p>
</li>
<li><p>terminated：彻底终止。</p>
</li>
</ol>
<h3 id="谈一谈ThreadLocal"><a href="#谈一谈ThreadLocal" class="headerlink" title="谈一谈ThreadLocal"></a>谈一谈ThreadLocal</h3><p>ThreadLocal是线程共享变量，主要用于一个线程内跨类、方法传递数据，ThreadLocal有一个静态内部类ThreadLocalMap，其key是ThreadLocal对象，值是Entry对象，Entry内只有一个Object的value，ThreadLocal是线程共享的，但ThreadLocalMap是线程私有的，ThreadLocal主要有get、set、remove三个方法</p>
<ul>
<li>set：首先获取当前线程，然后再获取当前线程对应的ThreadLocalMap类型的对象map，如果map存在就设置key，key是当前的ThreadLocal对象，value是传入的参数；否则通过createMap方法创建一个ThreadLocalMap，再设置值</li>
<li>get：首先获取当前线程，然后再获取当前线程对应的ThreadLocalMap类型的对象map，如果map存在就以当前ThreadLocal对象作为key获取Entry类型的对象e，如果e存在就返回它的value；如果map或者e不存在，就调用setInitialValue方法先为当前线程创建一个ThreadLocalMap对象然后返回默认的初始值null</li>
<li>remove：获取ThreadLocalMap类型的对象map，如果map不为空，则解除ThreadLocal这个key及其value的联系</li>
</ul>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>脏数据：线程池会复用Thread，因此ThreadLocal也会被复用，而如果没有通过remove方法清理与线程相关的ThreadLocal数据，则下一个线程可能会get到之前的数据</li>
<li>内存泄漏：由于ThreadLocal是弱引用，但Entry的value是强引用，因此当ThreadLocal被回收后，value没有被释放，造成内存泄漏，因此需要及时调用remove清理</li>
</ol>
<h2 id="I-O流问题"><a href="#I-O流问题" class="headerlink" title="I/O流问题"></a>I/O流问题</h2><h3 id="同步、异步、阻塞、非阻塞都是什么概念？"><a href="#同步、异步、阻塞、非阻塞都是什么概念？" class="headerlink" title="同步、异步、阻塞、非阻塞都是什么概念？"></a>同步、异步、阻塞、非阻塞都是什么概念？</h3><div class="note info"><p>同步和异步是通信机制，阻塞和非阻塞是调用状态。</p></div>

<p>同步IO是用户线程发现IO请求后需要等待或轮询内核IO操作完成后才能继续执行；异步IO是用户线程发起IO请求后可以继续执行，当内核IO操作完成后会通知用户线程，或调用用户线程注册的回调函数。</p>
<p>阻塞IO是IO操作需要彻底完成后才能返回用户空间；非阻塞IO是IO操作调用后立即返回一个状态值，无需等IO操作彻底完成。</p>
<h3 id="Java中有哪些IO模型，简单介绍下"><a href="#Java中有哪些IO模型，简单介绍下" class="headerlink" title="Java中有哪些IO模型，简单介绍下"></a>Java中有哪些IO模型，简单介绍下</h3><ol>
<li>BIO：<strong>同步阻塞式</strong>IO，JDK1.4之前的IO模型，服务器实现模式为一个连接请求对应一个线程，也就是一个客户端请求需要创建一个线程，适用于<strong>连接数目少</strong>且服务器资源多的情景。</li>
<li>NIO：<strong>同步非阻塞</strong>IO，JDK1.4引入，服务器实现模式为多个连接请求对应一个线程，客户端连接请求会注册到一个多路复用器Selector，Selector轮询到连接有IO请求时才启动以恶搞线程处理，适用于连接<strong>数目多</strong>且连接<strong>时间短</strong>的场景。</li>
<li>AIO：<strong>异步非阻塞</strong>IO，JDK7引入，服务器实现模式为一个有效请求对应一个线程，客户端的IO请求都是由操作系统先完成IO操作再通知服务器应用来直接使用准备好的数据，适用于连接<strong>数目多</strong>且连接<strong>时间长</strong>的场景。</li>
</ol>
<h4 id="详细介绍下NIO"><a href="#详细介绍下NIO" class="headerlink" title="详细介绍下NIO"></a>详细介绍下NIO</h4><p>不同于传统的IO，NIO以块的方式传输数据，一次处理一个数据块，可以控制读取某个位置的数据，速度更快。它有几个重要的组件：</p>
<ol>
<li>Buffer：缓冲区，本质是一块可读写的内存，用来简化数据读写，不再以字节来处理数据，并提供flip、clear、compact来切换读写状态，通过读写位置position和极限位置limit来实现</li>
<li>Channel：通道是对IO中流的模拟，通过Channel读写数据，将数据读取到Buffer/通过Buffer将数据写出，一个Buffer可以切换读写，被不同的Channel使用，这让NIO成为了非阻塞的IO，通过Channel的返回就可以知道缓冲区是否有数据，而不是和IO流一样需要阻塞等待数据。</li>
<li>Selector：多路复用器，轮询检查多个Channel的状态，判断注册事件是否发生，即判断Channel是否处于可读/可写状态</li>
</ol>
<p>其工作流程是通过Selector的静态方法open实例化一个选择器，通过Channel的register方法将通道的某个事件和Selector绑定起来，事件有CONNECT、ACCEPT、READ、WRITE。Selector的select方法返回目前就绪的通道数，通过selectKeys得到对应的集合，处理其中的事件</p>
<h3 id="IO包下有哪些流？"><a href="#IO包下有哪些流？" class="headerlink" title="IO包下有哪些流？"></a>IO包下有哪些流？</h3><p>主要分为字符流和字节流，字符流一般用于处理文本文件，其他类型用字节流处理</p>
<ul>
<li>字节流：使用了<strong>装饰器模式</strong>，InputStream和OutputStream是抽象组件，FileInputStream、ByteArrayInputStream是基础实现类，FilterInputStream是抽象装饰器，其实现类BufferInputStream、PushBackInputStream等为基础实现类提供了额外的功能，使用BufferInputStream装饰FileInputStream（在FileInputStream外套上BufferInputStream）可以实现具有缓存的输入流；使用PushBackInputStream装饰ByteArrayInputStream可以实现具有回退读取unread的功能的输入流；<strong>DataInputStream</strong>提供了读取Java基本数据类型的方法，实现上并未改变基本的读写方法，只是动态的处理成需要的类型。</li>
<li>字符流：在程序中一般操作的是字符形式的数据，Java提供了基本的InputStreamReader和OutputStreamWriter完成了字节流和字符流之间的编解码转换，家族结构和Stream类似也采用了<strong>装饰器模式</strong>。</li>
</ul>
<h3 id="序列化和反序列化是什么？"><a href="#序列化和反序列化是什么？" class="headerlink" title="序列化和反序列化是什么？"></a>序列化和反序列化是什么？</h3><p>Java对象在JVM退出时会全部销毁，如果需要将对象及状态持久化，就要通过<strong>序列化</strong>实现，将内存中的对象保存在二进制流中，需要时再将二进制流<strong>反序列化</strong>为对象。对象序列化保存的是对象的状态，因此类的<strong>静态变量</strong>不会被序列化。常见的序列化方式有以下几种：</p>
<ol>
<li>Java原生：实现Serializable接口，Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息）以及对象数据，兼容性最好，但不支持跨语言，性能一般。序列化和反序列化必须保证序列化ID一致，如果没有序列化ID，则会抛异常。具体的序列化过程：判断对象类型，写入<strong>对象类型标记</strong>；写入<strong>对象类信息</strong>，包括类名、序列化ID、字段数、字段名等；写入<strong>实例数据</strong>，基本类型直接写入，引用类型<strong>递归</strong>调用<strong>writeObject</strong>写入</li>
<li>Hessian：支持跨语言、动态类型，用一个字节表示常用基础类型，极大缩短二进制流，更加高效</li>
<li>JSON：转化为JSON字符串，不记录类型信息，因此反序列化需要提供类型信息才能正确进行；可读性高</li>
</ol>
<h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><h3 id="介绍一下Java虚拟机的整体结构？各个模块的作用"><a href="#介绍一下Java虚拟机的整体结构？各个模块的作用" class="headerlink" title="介绍一下Java虚拟机的整体结构？各个模块的作用"></a>介绍一下Java虚拟机的整体结构？各个模块的作用</h3><p>在Java程序的执行过程中，JVM把它管理的内存划分为不同的数据区，其中线程私有的有程序计数器、虚拟机栈、本地方法栈，线程共享的有堆、方法区，虚拟机的类加载器负责将类信息加载到内存中，执行引擎负责执行字节码，采用即时编译技术。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004726.png" alt="图片"></p>
<ol>
<li>程序计数器：每个线程有自己的计数器，指示当前线程所执行字节码的行号，改变计数器的值选取下一条指令。对于Java方法记录了字节码的指令地址；对于本地方法，值为undefined</li>
<li>虚拟机栈：每个栈帧中有局部变量表存储方法内使用的变量、操作数栈、动态链接、返回地址，每新调用一个方法就创建一个栈帧，因此递归过深超过虚拟机允许的深度会报StackOverflowError</li>
<li>本地方法栈：native方法的栈，调用本地方法时虚拟机栈不变，动态链接并直接调用指定本地方法，同样会报StackOverflowError</li>
<li>方法区：存储类信息、常量、静态变量、即时编译的代码缓存等。JDK8之前使用永久代实现方法区，容易内存溢出，JDK7中把放在永久代的字符串常量池、静态变量等移出，JDK8废弃永久代，采用本地内存实现的元空间代替</li>
</ol>
<h3 id="运行时常量池、字符串常量池、Class常量池"><a href="#运行时常量池、字符串常量池、Class常量池" class="headerlink" title="运行时常量池、字符串常量池、Class常量池"></a>运行时常量池、字符串常量池、Class常量池</h3><ul>
<li>Class常量池：class文件中包含了类的版本、字段、方法、接口等信息，还有常量池（Constant Pool Table），存放编译器生成的字面量和符号引用</li>
<li>运行时常量池：类会经过加载、验证、准备、解析、初始化加载到内存，JVM会将class常量池中的内容存放到运行时常量池，class常量池存放的并不是对象实例，因此在解析阶段将会查找字符串常量池，将符号引用转换为直接引用</li>
<li>字符串常量池：在经过验证、准备阶段后，在堆中生成字符串实例，将其引用值存放到字符串常量池中，被所有类共享</li>
</ul>
<h3 id="Java程序是怎样运行的？"><a href="#Java程序是怎样运行的？" class="headerlink" title="Java程序是怎样运行的？"></a>Java程序是怎样运行的？</h3><p>首先通过javac将.java编译为JVM可加载的.class字节码文件，之后通过即时编译器JIT把字节码文件翻译为本地机器码，之后执行引擎将执行指令代码</p>
<h3 id="有哪些类加载器？类加载的过程是怎样的？"><a href="#有哪些类加载器？类加载的过程是怎样的？" class="headerlink" title="有哪些类加载器？类加载的过程是怎样的？"></a>有哪些类加载器？类加载的过程是怎样的？</h3><p>启动类加载器<strong>BootstrapClassLoader</strong>负责加载/lib/rt/下的核心类库java.* ；由C++编写，平台/扩展类加载器<strong>ExtClassLoader</strong>加载/lib/ext下的扩展类库javax.* ；应用类加载器<strong>AppClassLoader</strong>加载用户写的类，位置在classpath下；另外，还可以通过继承ClassLoader实现自定义的类加载器，通过findClass方法将字节数组传入由defineClass方法负责加载到JVM中。</p>
<p>类加载采用双亲委派机制：一个类加载器接收到类加载请求会将请求<strong>委派给父加载器</strong>，只有当父加载器没法完成时，才会由子加载器尝试加载。可以确保类在每个类加载器环境都是同一个，避免重复加载。</p>
<p>类加载过程分为<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong>三个阶段，加载阶段将class字节码加载到JVM，生成class对象，链接阶段先通过<strong>验证</strong>检查class的安全性和正确性，之后为类变量分配空间并设置初始值，称为<strong>准备</strong>，在<strong>解析</strong>时将常量池内的符号引用转换为直接引用，最后的初始化阶段执行类变量赋值和静态代码块。</p>
<h3 id="创建对象new的时候发生了什么？"><a href="#创建对象new的时候发生了什么？" class="headerlink" title="创建对象new的时候发生了什么？"></a>创建对象new的时候发生了什么？</h3><ol>
<li>当JVM遇到字节码new指令时，首先检查该指令的参数能否在常量池定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析、初始化，如果没有则执行类加载</li>
<li>类加载检查通过后，虚拟机将为新生对象分配内存</li>
<li>内存分配完成后虚拟机将成员变量设为初始值，保证对象的实例字段可以不赋初值就使用</li>
<li>设置对象头，包括hashCode、GC信息、锁信息、类类型等</li>
<li>执行init方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋给引用变量</li>
</ol>
<h3 id="如何判断对象是否为需要被回收？"><a href="#如何判断对象是否为需要被回收？" class="headerlink" title="如何判断对象是否为需要被回收？"></a>如何判断对象是否为需要被回收？</h3><ul>
<li>引用计数：在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是存在对象间循环引用的问题，导致计数器无法清零。</li>
<li>可达性分析：判断对象的引用链是否可达。将所有对象组成图，从一系列GC Root对象开始向下搜索其他对象，路径称为引用链，如果所有的GC Root都无法到达的对象则判定为垃圾。可以作为GC Root对象的有虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</li>
</ul>
<h3 id="Java中有哪些引用类型？"><a href="#Java中有哪些引用类型？" class="headerlink" title="Java中有哪些引用类型？"></a>Java中有哪些引用类型？</h3><ol>
<li>强引用：最常见的引用，只要对象有强引用且GC Root可达，在垃圾回收时即使内存耗尽也不会被回收</li>
<li>软引用：在内存即将耗尽时，会把软引用关联的对象加入回收范围</li>
<li>弱引用：只能生存到下次年轻代GC前</li>
<li>虚引用：定义完成后无法通过引用来获取该对象，只是为了在对象被回收时收到一个系统通知</li>
</ol>
<h3 id="有哪些GC算法？"><a href="#有哪些GC算法？" class="headerlink" title="有哪些GC算法？"></a>有哪些GC算法？</h3><ul>
<li>复制算法：对内存分为对象面和空闲面，将存货的对象复制到空闲面，然后将对象面所有对象从内存清除。减少碎片，适合对象存活率低的场景，复制越少越快。但是意味着要有一块空闲空间不能使用</li>
<li>标记-清除算法：使用可达性算法标记垃圾，之后将垃圾清除。会产生碎片</li>
<li>标记-整理算法：使用可达性算法标记，移动存货的对象，将对象顺序排列，之后清除最后一个对象的地址之后的内存空间。减少碎片，也不需要设置两块内存，适用于存活率高的场景</li>
</ul>
<h3 id="常见的垃圾收集器有哪些？"><a href="#常见的垃圾收集器有哪些？" class="headerlink" title="常见的垃圾收集器有哪些？"></a>常见的垃圾收集器有哪些？</h3><p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004738.png" alt="图片"></p>
<ol>
<li>Serial：单线程收集，采用复制算法，会STW，Client模式年轻代默认收集器</li>
<li>ParNew：多线程收集，其他于Serial相同，追求低停顿</li>
<li>ParallelScavenge：多线程收集，采用复制算法，更关注系统吞吐量，Server模式年轻代默认收集器</li>
<li>Serial Old：单线程收集，采用标记-整理算法，Client模式老年代默认收集器</li>
<li>Parallel Old：多线程收集，采用标记-整理算法，追求吞吐量</li>
<li>CMS：追求最短停顿时间，采用标记-清除算法，过程较复杂</li>
<li>G1：不再区分以老年代/年轻代简单区分内存，以Region内存布局面向局部收集，实现了可预测的停顿</li>
</ol>
<h4 id="CMS回收过程"><a href="#CMS回收过程" class="headerlink" title="CMS回收过程"></a>CMS回收过程</h4><p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004753.png" alt="图片"></p>
<p><strong>初始标记</strong>阶段进入STW，使用单线程标记GC Root直接关联的对象；<strong>并发标记</strong>阶段从初始标记的对象开始遍历，耗时较长但是不需要停顿；<strong>重新标记</strong>阶段修正在并发标记期间因用户程序运作而导致标记产生变动的部分记录，需要STW；<strong>并发清除</strong>清理垃圾，不需要移动对象，可以并发执行</p>
<h4 id="G1回收过程"><a href="#G1回收过程" class="headerlink" title="G1回收过程"></a>G1回收过程</h4><p><strong>初始标记</strong>阶段进入STW，标记GC Root直接关联的对象，让下一阶段用户线程并发运行时能正确地在可用的Region中分配新对象；<strong>并发标记</strong>阶段从初始标记的对象开始遍历，查找整个堆，扫描完成后要重新处理此过程中变化的部分；<strong>最终标记</strong>进入短暂的STW，处理并发阶段结束后仍遗留的少量SATB记录；<strong>筛选回收</strong>对各Region的回收价值排序，根据用户期望停顿事件制定回收计划，需要暂停用户线程，多线程并发完成</p>
<h3 id="你知道哪些内存分配和回收策略？"><a href="#你知道哪些内存分配和回收策略？" class="headerlink" title="你知道哪些内存分配和回收策略？"></a>你知道哪些内存分配和回收策略？</h3><ol>
<li>对象优先在Eden区分配：大多数情况下对象在新生代Eden区分配，当Eden不足时会触发Minor GC</li>
<li>大对象直接进入老年代：通过指定-XX:PretenureSizeThreshold参数，大于该值的直接在老年代分配</li>
<li>长期存活对象进入老年代：通过指定-XX:MaxTenuringThreshold参数，对象年龄大于该值的进入老年代，没经过一次Minor GC，年龄+1</li>
<li>动态对象年龄判定：当Survivor中相同年龄所有对象大小的总和大于Survivor的一半，则将年龄不小于该年龄的对象放入老年代</li>
<li>空间分配担保：Minor GC前虚拟机必须检查老年代最大连续可用空间是否大于新生代对象总空间，满足则说明Minor GC安全；如果不满足，虚拟机会查看-XX:HandlePromotionFailure是否允许担保失败，允许则检查老年代最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果满足则冒险尝试Minor GC，否则进行Full GC</li>
</ol>
<h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><h3 id="设计模式要遵循哪些原则？"><a href="#设计模式要遵循哪些原则？" class="headerlink" title="设计模式要遵循哪些原则？"></a>设计模式要遵循哪些原则？</h3><ol>
<li>开闭原则：面向对象的基本原则，指一个实体应该对扩展开放，对修改关闭，提高代码的可复用性和可维护性</li>
<li>单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险</li>
<li>依赖倒置原则：程序应该依赖于抽象类/接口，而不是具体的实现类</li>
<li>接口隔离原则：将不同功能定义在不同接口中实现接口隔离，避免类依赖了它不需要的接口，减少接口之间依赖的冗余和复杂性</li>
<li>里氏替换原则：开闭原则的补充，规定了任何父类可以出现的地方子类都可以出现，可以约束继承泛滥，加强程序健壮性</li>
<li>迪米特原则：也叫最少知道原则，每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度</li>
<li>合成/聚合原则：尽量使用组合（has-a）、聚合（contains-a）而不是继承（is-a）达到软件复用的目的</li>
</ol>
<h3 id="你了解哪些设计模式？"><a href="#你了解哪些设计模式？" class="headerlink" title="你了解哪些设计模式？"></a>你了解哪些设计模式？</h3><blockquote>
<p>设计模式分为创建型、结构型和行为型。创建型在创建对象时<strong>隐藏创建逻辑</strong>，不适用new直接实例化对象；结构型通过类和接口间的<strong>继承和引用</strong>实现创建复杂结构的对象；行为型通过类之间<strong>不同通信方式</strong>实现不同的行为</p>
</blockquote>
<div class="note info"><p>创建型：单例模式、工厂模式、建造者模式、原型模式</p></div>

<div class="note success"><p>结构型：适配器模式、桥接模式、装饰器模式、代理模式、组合模式</p></div>

<div class="note warning"><p>行为型：模板方法模式、策略模式、责任链模式、观察者模式、命令模式</p></div>

<h4 id="讲讲单例模式？"><a href="#讲讲单例模式？" class="headerlink" title="讲讲单例模式？"></a>讲讲单例模式？</h4><p>单例模式属于创建型模式，一个单例类在任何情况下只存在一个实例，私有化构造方法，提供一个静态方法向外提供静态实例变量。数据库连接池、ServletContext、Spring的单例Bean等都是单例模式的应用</p>
<ul>
<li><p>饿汉式：线程安全，在加载时完成实例的创建，提供静态方法获取实例变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>懒汉式：在外部调用时才会创建实例，通过双重检测锁、静态内部类、枚举等方法来保证线程安全</p>
<p>双重检测锁：synchronized加锁，volatile禁止指令重排序</p>
<p>静态内部类：线程安全、延迟加载</p>
<p>枚举：简洁、序列化和反序列化无法破解。反射的newInstance方法会判断是否类被枚举修饰，是则抛出异常。序列化时枚举的每个变量都是静态的所以在jvm中只有一份。</p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双重检测锁机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance; <span class="comment">//禁止内存重排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazySingleton instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 枚举实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LazySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

</li>
</ul>
<h4 id="讲讲工厂模式"><a href="#讲讲工厂模式" class="headerlink" title="讲讲工厂模式"></a>讲讲工厂模式</h4><p>工厂模式属于创建型模式，有<strong>简单工厂</strong>模式、<strong>工厂方法</strong>模式、<strong>抽象工厂</strong>模式三种</p>
<ol>
<li>简单工厂模式：由工厂对象来创建实例，客户端只需要传入参数即可，由工厂对象进行判断和创建具体类型的实例。适用于创建对象类型较少的场景，如果要增加新类型，需要修改工厂对象的判断逻辑，违背了<strong>开闭原则</strong>。Calendar抽象类的getInstance方法调用了createCalendar根据不同的地区参数创建不同的日历对象，Spring的BeanFactory通过Bean唯一标识来获取Bean</li>
<li>工厂方法模式：定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行，解决了简单工厂中产品扩展的问题。Collection接口中定义了一个iterator工厂方法，返回了一个Iterator类的抽象产品，该方法由ArrayList、HashMap等具体工厂实现；Spring的FactoryBean接口的getObject方法也是工厂方阿飞</li>
<li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类，主要用于系统的产品有多于一个的产品族，而系统只消费其中某一个产品族产品的情况。Connection接口应用了抽象工厂，其中包括Statement、Blob、Savepoint等抽象产品</li>
</ol>
<h4 id="建造者模式了解吗？"><a href="#建造者模式了解吗？" class="headerlink" title="建造者模式了解吗？"></a>建造者模式了解吗？</h4><p>建造者模式属于创建型模式，一个类由多个部件构成，一个不见可以有多种实现，通过组合可以创建出不同的实例，在创建该类时，使用者通过一个指挥者实例，实例中有一个抽象建造者，抽象建造者定义了待实现的建造方法(针对不同部件)，抽象建造者的实现类则做出了具体实现。指挥者通过建造者就可以完成对产品的建造，最后将结果返回给使用者。</p>
<h4 id="讲一讲代理模式"><a href="#讲一讲代理模式" class="headerlink" title="讲一讲代理模式"></a>讲一讲代理模式</h4><p>代理模式属于结构型模式，为其他对象提供一种代理以控制对被代理对象的访问，可以增强目标对象的功能，降低代码耦合度，扩展性好。分为静态代理和动态代理两种方式，静态代理在运行前就已经确定了代理类和被代理类的关系，动态代理具有更强的适用性</p>
<ul>
<li><p>JDK动态代理：被代理类需要实现含有业务方法的接口，代理类需要实现InvocationHandler invoke方法来调用具体的业务方法，最终通过Proxy.newInstance生成代理类，会调用ProxyGenerator的generate方法生成字节码，再用类加载器来装载生成的代理类。</p>
<p>在Spring AOP中，生成的Proxy类拥有真实类实现的接口的所有方法，其实就是通过<strong>实现相同的接口</strong>，然后在对应的方法周围加入切面逻辑。从Proxy的字节码可以看到，声明了私有静态成员变量Method 01234…通过静态代码块<strong>利用反射</strong>来初始化各个方法。通过Proxy类的成员变量invocationHandler的invoke方法调用具体方法。invoke中在调用具体方法前后会有<strong>切入</strong>的逻辑。</p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> aop.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy11</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> $Proxy11(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">"aop.UserService"</span>).getMethod(<span class="string">"A"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"aop.UserService"</span>).getMethod(<span class="string">"B"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>CGLIB动态代理：以继承的方式动态生成目标类的代理，通过修改字节码(asm框架)的方式织入，<strong>不需要接口</strong>，因为cglib是利用<strong>继承真实类通过super来调用真实类方法</strong>，并加入新逻辑的方式来实现的。</p>
</li>
</ul>
<h4 id="讲一讲装饰器模式？"><a href="#讲一讲装饰器模式？" class="headerlink" title="讲一讲装饰器模式？"></a>讲一讲装饰器模式？</h4><p>装饰器模式属于结构型模式，不改变类原有的属性，动态的增加其他属性，装饰器是一个抽象制定了待实现的装饰方法，可以有不同的实现，将已有的类传入装饰器后对其进行装饰。<a href="#IO包下有哪些流？">Java IO流家族</a>应用了这种模式</p>
<h4 id="装饰器和代理有什么区别？"><a href="#装饰器和代理有什么区别？" class="headerlink" title="装饰器和代理有什么区别？"></a>装饰器和代理有什么区别？</h4><p>装饰器模式的关注点在于给对象动态<strong>添加方法</strong>，而动态代理更注重对象的<strong>访问控制</strong>。动态代理通常会在代理类中<strong>创建被代理对象的实例</strong>，而装饰器模式会将被装饰者作为构造方法的<strong>参数</strong>。</p>
<h4 id="适配器模式了解吗？有什么应用？"><a href="#适配器模式了解吗？有什么应用？" class="headerlink" title="适配器模式了解吗？有什么应用？"></a>适配器模式了解吗？有什么应用？</h4><p>适配器模式属于结构型模式，将一个类的接口转换为使用者接受的另一种接口，解决由于<strong>不兼容</strong>而不能一起工作的问题。适配器Adapter继承/实现期待的类/接口，在实现期待的接口时，使用用于适配的不兼容者来实现。这样在外部看来就是期待的状态但我们内部通过适配器将原本不兼容的转换为可接受的状态。Java的字符流操作应用了适配器模式，SpringMVC的HandlerAdapter通过适配规则调用不同的处理请求handle方法，Arrays.asList将数组转换为对应的集合</p>
<h4 id="模板方法模式有了解吗？"><a href="#模板方法模式有了解吗？" class="headerlink" title="模板方法模式有了解吗？"></a>模板方法模式有了解吗？</h4><p>模板方法模式属于行为型模式，使子类可以在不改变算法结构的情况下重新定义算法的某些步骤，适用于抽取子类重复代码到公共父类，<a href="#你提到了JUC，还了解JUC包的其他东西吗？">JUC的AQS</a>应用了模板方法模式，HttpServlet定义了一套处理HTTP请求的模板，service为模板方法定义了基本处理流程，doGet/doPost为基本方法，子类可重写这些方法</p>
<h4 id="讲讲责任链模式"><a href="#讲讲责任链模式" class="headerlink" title="讲讲责任链模式"></a>讲讲责任链模式</h4><p>责任链模式属于行为型模式，责任链是指由多个继承了抽象处理类的子类组成的处理链条，通过next连接，将对于某个请求的处理交给一条处理链，子类会不断地转发给下一个子类一直向下处理。Spring的拦截器中HandlerExecutionChain将拦截器放在一个list中，前置处理做正向循环直到被拦截就停下，后置处理从这个位置开始逆向循环做后置处理</p>
<h4 id="对观察者模式有什么了解？"><a href="#对观察者模式有什么了解？" class="headerlink" title="对观察者模式有什么了解？"></a>对观察者模式有什么了解？</h4><p>观察者模式属于行为型模式，也叫发布订阅模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知并被自动更新。ServletContextLister能够监听ServletContext对象的生命周期，当启动时调用contextInitialized方法，终止时调用contextDestroyed方法</p>
<p>如何实现：一个包含了观察者集合和对观察者集合进行操作以及通知观察者的方法的抽象类。一个包含了更新自己的抽象方法，在收到被观察者状态改变通知时被调用。被观察者实现类实现具体的通知方法，当实现类状态改变时通过通知方法调用观察者更新自己的方法。</p>
]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/posts/ea4681d0.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>递归借用系统栈，在遍历时每个节点都会访问三次，因此只要在不同的时机打印出节点的值，即可完成三种遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurTraversal</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(node.val);<span class="comment">//前序</span></span><br><span class="line">        recurTraversal(node.left);</span><br><span class="line">        System.out.print(node.val);<span class="comment">//中序</span></span><br><span class="line">        recurTraversal(node.right);</span><br><span class="line">        System.out.print(node.val);<span class="comment">//后序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h2><ol>
<li><p>前序遍历：前序遍历的顺序是根-左-右，借助栈后进先出的特点，在压栈时先压右再压左，则出栈时先出左再出右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node); <span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">while</span>(!stack,isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：中序遍历的顺序是左-根-右。对于整个二叉树，最左的节点第一个被打印，因此我们从根节点开始，不断入栈左节点（第一次访问），当左节点为空时，说明走到了最左节点，出栈（第二次访问），将其右节点入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//还有左节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left; <span class="comment">//向左走</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有左节点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：后序遍历的顺序是左-右-根。前序遍历是根左右，我们将前序遍历中压栈顺序改为先压左再压右，则出栈顺序变为根右左，其逆序就是左右根。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            node = in.pop();</span><br><span class="line">            out.push(node);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                in.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                in.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!out.isEmpty())&#123;</span><br><span class="line">            System.out.print(out.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层序遍历：逐层打印节点，借助队列实现。每个节点出队时将左右子节点入队，由于队列先进先出，将按入队顺序出队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题04. 二维数组中的查找</title>
    <url>/posts/dda4a850.html</url>
    <content><![CDATA[<blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrix: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br><span class="line">给定 target = <span class="number">5</span>，返回 <span class="keyword">true</span>。</span><br><span class="line">给定 target = <span class="number">20</span>，返回 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>遍历二维数组的每一个位置，判断是否和 <code>target</code> 相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代码的鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; matrix.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😂<del>就这都能双一百你敢信？</del></p>
<p><img src="http://119.3.165.25/img/%E5%89%91%E6%8C%87Offer/04/1.png" alt="图片"></p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>暴力解法没有利用题目提供的每行有序和每列有序的特性。查找的过程无非是判断数字之间的大小关系，并且最好通过大小关系可以帮我们减小查找的范围，就像二分查找，每次可以排除一般的查找范围。</p>
<p>这个二维数组拥有以下特征：对于每一个元素，它所在的行，左侧的元素都比它小，右侧的元素都比它大；它所在的列，上方的元素比它小，下方的元素比它大。要确保所有位置都被考虑到，因此需要确定从四个顶点的哪一个开始。如果从左上角开始，根据target和左上角元素的大小关系，我们无法缩小范围，因为对于左上角来说，只有右侧和下侧，都是比它大的。右小角同理。而对于右上角来说，比它小的在左侧，比它大的在下方，因此如果target比它大，则会出现在下方，我们可以不再考虑当前行；如果比它小，则会出现在左侧，我们可以不必考虑当前列。达到缩小查找范围的目的。左下角同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代码的鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>, curCol = col-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( curRow &lt; row &amp;&amp; curCol &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[curRow][curCol] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[curRow][curCol] &lt; target)&#123;</span><br><span class="line">            curRow ++;<span class="comment">//下一行</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curCol --;<span class="comment">//前一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>剑指Offer</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题05. 替换空格</title>
    <url>/posts/48c165ca.html</url>
    <content><![CDATA[<blockquote>
<p>请实现一个函数，把字符串中的每个空格替换成“%20%”。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"we are happy"</span></span><br><span class="line">输出：<span class="string">"we%20are%happy"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>遍历字符串，如果遇到空格就替换成%20%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"%20"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> sb.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="💡-耍赖"><a href="#💡-耍赖" class="headerlink" title="💡 耍赖"></a>💡 耍赖</h3><p><code>return s.replaceAll(&quot; &quot; , &quot;%20%&quot; );</code></p>
]]></content>
      <tags>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题06. 从尾到头打印链表</title>
    <url>/posts/9649f58.html</url>
    <content><![CDATA[<blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>对于链表的操作，无法方便地使用下标来获取元素，因此，必然需要从头节点开始通过next指针操作。但是需要从尾到头打印，也就是头节点最后被打印，尾节点第一个被打印。因此我们可以利用栈的后进先出的特点，帮助我们完成这道题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    ListNode cur = head;<span class="comment">//不修改输入</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur.val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; stack.size(); i++)&#123;</span><br><span class="line">        res[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>使用栈需要额外的空间复杂度，我们注意到返回结果是一个数组，而数组可以方便地使用下标来存取元素。因此我们先遍历链表获得链表的长度，初始化数组，再次遍历链表，将第一个节点值放在数组的最后一个位置，第二个节点放在倒数第二个位置，…以此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        res[--size] = cur.val;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题09. 用两个栈实现队列</title>
    <url>/posts/eaced0a1.html</url>
    <content><![CDATA[<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 </p>
</blockquote>
<a id="more"></a>

<p>分析题目，提炼关键信息：队列的特点是<strong>先进先出</strong>，栈的特点是<strong>后进先出</strong>。</p>
<p>我们应当关心的是-：<strong>如何保证出的顺序是先进先出？</strong>注意到-假如栈1入栈顺序为1,2,3,则出栈顺序为3,2,1，那么按栈1出栈顺序将元素放入栈2，则栈2入栈顺序为3,2,1,则出栈顺序为1,2,3。 两个栈一个为进一个为出，这样栈1负责入队，栈2负责出队，就满足队列先进先出的要求。</p>
<p>算法执行过程：</p>
<p>当栈2为空时，将栈1中元素弹出压入到栈2。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004551.jpg" alt="图片"></p>
<p>当栈2不为空时，直接返回栈2栈顶元素即可。</p>
<p>代码如下：</p>
<pre><code>import java.util.Stack;

public class Solution {
    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty())stack2.push(stack1.pop());
        }
        return stack2.isEmpty() ? -1 : stack2.pop();
    }
}</code></pre>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题10- I. 斐波那契数列</title>
    <url>/posts/18deca0d.html</url>
    <content><![CDATA[<blockquote>
<p>写一个函数，输入 n ，求斐波那契数列的第 n 项。斐波那契数列定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>, F(<span class="number">1</span>) = <span class="number">1</span>, F(N) = F(N-<span class="number">1</span>)+F(N-<span class="number">2</span>),N&gt;<span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<p>答案需要取模 1e9+7(1000000007)，如计算结果为1000000008，则返回1.</p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>这道题最直接的思路就是通过递归来求解，它的递归过程和终止条件都已经给出。因此我们可以直接写出这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;<span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)%<span class="number">1000000007</span> + fib(n - <span class="number">2</span>)%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>但是简单的这样递归时间复杂度是O(ф^n)，ф是黄金分割比，是一个指数级别的时间复杂度。原因是这样的求解过程中出现了大量的重复计算。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722004614.jpg" alt="重复计算"></p>
<p>对数字n，求解fib(n-1)、<strong>fib(n-2)</strong>，之后对n-1，求解<strong>f(n-2)</strong>、<strong>f(n-3)</strong>，对n-2，求解<strong>f(n-3)</strong>、f(n-4)……因此我们可以通过先解决小问题，再求解大问题，先求解 1,2,3….直到n。这样就可以避免重复求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="comment">//记录中间结果</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">        b = a;<span class="comment">//往后移动</span></span><br><span class="line">        a = sum;<span class="comment">//往后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题46. 把数字翻译成字符串</title>
    <url>/posts/13cdcb1b.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>因为只有<code>26</code> 个小写字母，即数字范围为<code>[0-25]</code>可以翻译为一个字母，因此一个数字的翻译方式最多有两种，一种是单独翻译成一个字母，第二种是和前一个数字组合翻译。而两个数字能够组合翻译的条件是其组成的数字范围在<code>[10-25]</code>之间，因为<code>01</code>、<code>02</code>是不合法的。举个例子：</p>
<ul>
<li>如果只有一位数<code>1</code>，那么他只能有<strong>壹</strong>种翻译结果<code>b</code>；</li>
<li>如果有两位数<code>12</code>，除了各自单独翻译这一种方法之外，由于组合的数字<code>12</code>在<code>[10-25]</code>之间满足要求，可以组合翻译，翻译种数为<code>1+1=2</code>；</li>
<li>如果有三位数，如<code>121</code>，在两位数<code>12</code>的基础上，如果对第三位单独翻译，那么剩下的两位数<code>12</code>有<strong>两</strong>种不同的翻译；因为第二位<code>2</code>和第三位<code>1</code>组合得到<code>21∈{10, 25}</code>，因此他们可以组合翻译，那么剩下第一位<code>1</code>，它只有<strong>壹</strong>种翻译，所以三位数<code>121</code>总共有<code>2+1=3</code>种翻译；</li>
<li>如果有四位数<code>1212</code>，在三位数的基础上，如果对第四位单独翻译，那么剩下的三位数<code>121</code>有<strong>叁</strong>种翻译；因为第三位<code>1</code>和第四位<code>2</code>组合的数字<code>12∈{10, 25}</code>，可以组合翻译，那么剩下两位数<code>12</code>，它有<strong>两</strong>种翻译；于是对于四位数<code>1212</code>，共有<code>3+2=5</code>种翻译。</li>
</ul>
<p>于是我们可以这样求解，从数字<code>num</code>的第一位（最高位）开始，遍历每一位，当前位的翻译种数至少和它前一位的种数相同（当前位单独翻译）；除此之外，如果当前位和前一位组成的数字在<code>[10-25]</code>之间，那么翻译种数需要再加上前两位的种数（当前位和前一位组合翻译）。</p>
<p>这样的过程不断在使用之前的结果来推导出新的结果，也就是<strong>动态规划</strong>的思想。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>为了方便地从数字的高位遍历到低位，我们先将数字转换成字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(num);</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//动态规划，设dp[i]为前i个数字的翻译种数。对于i,两种情况：</span></span><br><span class="line">    <span class="comment">//1.自己翻译成一个字母,这样和上一位的种数是相同的;</span></span><br><span class="line">    <span class="comment">//2.如果和上一位组合的数字在10和25之间,可以组合翻译,这样种数就是前一位种数+前两位种数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">'1'</span> || (s.charAt(i)&lt;<span class="string">'6'</span> &amp;&amp; s.charAt(i-<span class="number">1</span>)==<span class="string">'2'</span>))&#123;</span><br><span class="line">            dp[i] += i-<span class="number">2</span> &lt; <span class="number">0</span> ? <span class="number">1</span> : dp[i-<span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>由于我们每次都只用到前一位和前两位的结果，因此可以对空间复杂度进行优化，这种优化方式称为滚动数组。仅仅使用两个变量保存结果。</p>
<p>这里还有一个优化是我们将当前位<code>i</code>的结果记录在<code>i+1</code>的位置上，这样就不需要每次都进行 <code>i-2 &lt; 0</code>的检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(num);</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">1</span>;<span class="comment">//前一位种数</span></span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">1</span>;<span class="comment">//前两位种数</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//中间变量-备份</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i ++)&#123;</span><br><span class="line">        temp = one;<span class="comment">//暂存前一位种数</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>) == <span class="string">'1'</span> || (s.charAt(i-<span class="number">2</span>) == <span class="string">'2'</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) &lt; <span class="string">'6'</span>))&#123;</span><br><span class="line">            one += two;</span><br><span class="line">        &#125;</span><br><span class="line">        two = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-数组中数字出现的次数 I</title>
    <url>/posts/1f1789a9.html</url>
    <content><![CDATA[<blockquote>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<a id="more"></a>

<h4 id="⛔不符合要求的两种思路"><a href="#⛔不符合要求的两种思路" class="headerlink" title="⛔不符合要求的两种思路"></a>⛔不符合要求的两种思路</h4><ol>
<li><p>数组中的次数问题，我们很容易联想到使用额外的数组记录次数来解决，但这里数组中的元素没有范围，并且由于空间复杂度的要求是O(1)，因此需要考虑其他思路。</p>
</li>
<li><p>首先从数组的特征出发，除两个数字之外，其他每个数字都出现了两次，那么我们可以先排序，然后遍历数组找到只出现一次的两个数字。由于排序的时间复杂度为O(NlogN)，因此也无法满足要求。</p>
</li>
</ol>
<div class="note primary"><p>那么这道题考察什么呢？</p></div>

<p>这是一道非常经典的题目，通过位运算<strong>异或</strong>来解决</p>
<h4 id="☑️正确操作"><a href="#☑️正确操作" class="headerlink" title="☑️正确操作"></a>☑️正确操作</h4><p>先来看看异或的性质</p>
<div class="note default no-icon"><ol>
<li>交换律：p⊕q=q⊕p </li>
<li>结合律：(p⊕q)⊕r = p⊕(q⊕r)</li>
<li>恒等率：p⊕0 = p</li>
<li>归零率：p⊕p = 0</li>
</ol></div>

<p>假设数组中不相同的两个数字是p，q。对数组中的数字进行异或操作，根据交换律，我们让每两个相同的数字异或得到0，最后剩下p，q，因为两个数不同，至少存在一个位不同。异或之后得到的结果肯定存在<strong>某个二进制位为1</strong>。根据这个位，将数组分为两份，由于相同的数字会分到同一组，分别为p和其他相同的数字、q和其他相同的数字。再进行异或，则可以得到p，q。</p>
<div class="note info"><p>举个例子：nums=[1,2,10,4,1,4,3,3]</p>
<ul>
<li>异或和sum = 1⊕2⊕10⊕4⊕1⊕4⊕3⊕3 = 1⊕1⊕3⊕3⊕4⊕4⊕2⊕10 = 2⊕10 = 0010 ⊕ 1010 = 1000</li>
<li>得到二进制为1的位index，sum每次右移一位，当最低位为1<code>sum &amp; 1 == 1</code>，index则为右移次数也即该位在sum中的位置。1000中右移三位0001&amp;1=1，index = 3。<u>此处理论上上使用任何一个为1的位都可以正确得到结果，但是在代码实现上求最右的1是最方便的。</u></li>
<li>根据index划分两组，在划分过程中同时执行异或和计算。对于数组中的所有数字，要么index位为1，要么index位为0 <code>( i &gt;&gt; index ) &amp; 1</code>，如数字1在第三位为0，数字2在第三位为0，数字10在第三位为1，以此划分。</li>
</ul></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	<span class="comment">//1.得到异或和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        sum ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.找到二进制位为1的位</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &amp; <span class="number">1</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        index+=<span class="number">1</span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.分组</span></span><br><span class="line">    <span class="keyword">int</span> p, q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (i &gt;&gt; index) &amp; <span class="number">1</span> == <span class="number">0</span> )&#123;</span><br><span class="line">            p ^= i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p,q&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>当你理解了上述的算法过程之后，如果你知道负数在机器中采用数值的<strong>补码</strong>来表示，那么第二步中的求异或和sum中为1的二进制位就可以使用<code>sum &amp; -sum</code>来得到，补码是原码按位取反+1，-8 使用 8 的补码表示为 1000，那么结果将是1000，接下来第三步操作也相应的有一些小小的改动。</p></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//1.得到异或和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        sum ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.找到二进制位为1的位</span></span><br><span class="line">    sum &amp;= -sum;</span><br><span class="line">	<span class="comment">//3.分组并求和</span></span><br><span class="line">    <span class="keyword">int</span> p, q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sum&amp;i) == <span class="number">0</span>)&#123;</span><br><span class="line">            p^=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            q^=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p,q&#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题11. 旋转数组的最小数字</title>
    <url>/posts/639f1318.html</url>
    <content><![CDATA[<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。例如，数组<code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1.</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>暴力解法就不详述了，遍历可以得到降序的元素。</p>
<p>这题和 Leetcode第 <a href="/posts/e3f3cf8a.html" title="153. 寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a> 题类似，建议先阅读这一篇，解法类似，区别在于这里数组的元素可能出现<strong>重复</strong>，因此缩小区间的时候需要考虑重复元素的情况。</p>
<p>本题中，中间位置元素和最右边的元素有大于小于等于三种关系：</p>
<ol>
<li>当 <code>nums[mid] &lt; nums[right]</code>，区间 <code>[mid...right]</code>保持<strong>升序</strong>，因此最小值在左侧，<code>right = mid</code></li>
<li>当 <code>nums[mid] &gt; nums[right]</code> ，区间 <code>[mid...right]</code> 出现<strong>降序</strong>，因此最小值在右侧，<code>left  = mid + 1</code> </li>
<li>当 <code>nums[mid] == nums[right]</code>，无法确认最小值出现在哪一侧，但是我们希望可以缩小区间。由于中间元素和右边相等，因此可以将右边界左移，就算当前右边界是最小值，但是我们保留了中间元素，所以不会出现问题。</li>
</ol>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span> , r = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r)&#123;<span class="comment">//跳出循环时 l = r，区间剩下的元素就是最小值</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[r] &gt; numbers[mid])&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[r] &lt; numbers[mid])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库面试问题</title>
    <url>/posts/1f02b5ce.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h2 id="事务的概念和特性？"><a href="#事务的概念和特性？" class="headerlink" title="事务的概念和特性？"></a>事务的概念和特性？</h2><p>概念：事务是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。</p>
<p>特性</p>
<ol>
<li>原子性：事务中的所有操作，要么全部成功提交，要么全部失败回滚。逻辑上是不可分割的操作单元。事务的回滚通过回滚日志undolog实现。</li>
<li>一致性：事务的执行必须使数据库保持一致性的状态。在一致性状态下，所有事务对同一数据的读取结果相同。</li>
<li>隔离性：事务在提交之前对数据所做的修改对其他事务是不可见的。并发执行的事务互不影响。</li>
<li>持久性：成功提交的事务对数据所作的修改是永久的。</li>
</ol>
<h3 id="如何保证原子性和持久性？"><a href="#如何保证原子性和持久性？" class="headerlink" title="如何保证原子性和持久性？"></a>如何保证原子性和持久性？</h3><p>通过引入undo log来实现事务的原子性。undo log记录数据被修改前的值，通常是逻辑日志，记录每一行的修改记录。当事务执行过程中出现宕机/需要回滚，则通过undo log将数据恢复。当事务结束时，undo log不会立刻清除，而是放入待清理的链表，由purge线程判断是否有其他事务正在使用undo log中记录的表的上一个事务之前的版本信息，决定是否删除。</p>
<p>由于undo log会被删除，因此引入redo log来保证事务的持久性。</p>
<p>redo log记录修改后的数据，通常是物理日志，记录发生修改的数据页。在事务提交之前写入磁盘，即使事务提交过程中宕机，也可以通过redo log将事务执行结果刷新到数据库。未提交/回滚的事务也会记录在redo log中。</p>
<h2 id="会发生哪些并发一致性问题？"><a href="#会发生哪些并发一致性问题？" class="headerlink" title="会发生哪些并发一致性问题？"></a>会发生哪些并发一致性问题？</h2><ol>
<li>丢失修改：一个事务对数据做了修改，在事务提交之前，另一个事务也对同一个数据做了修改，则第一个事务的修改丢失了。</li>
<li>脏读：一个事务读到另一个事务未提交/回滚的修改。</li>
<li>不可重复读：在同一个事务中，某个查询语句读取某行数据和之后再次读取该行数据得到不同的结果，数据已经发生修改。</li>
<li>幻读：当同一查询执行多次，由于其他事务在这个范围内执行了插入操作，导致每次返回不同的结果集。</li>
</ol>
<h2 id="数据库的四种隔离级别？"><a href="#数据库的四种隔离级别？" class="headerlink" title="数据库的四种隔离级别？"></a>数据库的四种隔离级别？</h2><ol>
<li>读未提交：在一个事务提交之前，它的执行结果对其他事务是可见的，会出现脏读、不可重复读、幻读。</li>
<li>读已提交：一个事务只能看见已经提交的事务的执行结果。解决脏读，会出现不可重复读、幻读。</li>
<li>可重复读：可以确保同一个事务在多次读取某一数据返回相同的结果。解决脏读、不可重复读，会出现幻读。</li>
<li>串行化：强制事务串行执行，使事务之间不可能相互冲突，解决幻读问题。</li>
</ol>
<h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><ol>
<li><p>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会对数据上锁，防止其他事务读取和修改数据。应用于数据更新频繁的场景</p>
</li>
<li><p>乐观锁：操作数据时不会上所，但是更新时会判断在此期间有没有其他事务修改了数据，若被修改过，则失败重试。适用于读多写少的场景。</p>
<div class="note info"><ol>
<li>加一个版本号或时间戳字段，在数据更新时同时更新这个字段</li>
<li>先读取想要更新的字段或者所有字段，只有在字段没有变化才执行更新</li>
</ol></div>

</li>
</ol>
<h2 id="常见的封锁类型"><a href="#常见的封锁类型" class="headerlink" title="常见的封锁类型"></a>常见的封锁类型</h2><blockquote>
<p><strong>封锁</strong>：是指事务对某个数据操作之前，先向系统发出请求，对其加锁。加锁之后事务就对该数据有了一定的控制。</p>
</blockquote>
<ol>
<li><p>排它锁：又称写锁。在事务对数据加上排它锁后，只允许该事务读取和修改数据，并且其他事务不能再对数据加任何锁</p>
</li>
<li><p>共享锁：又称读锁。事务对数据加上共享锁后，拥有了读取数据的权限，但是不能修改数据。其他的事务可以再对数据加共享锁不能加排它锁</p>
</li>
<li><p>意向锁：分为意向排它锁和意向共享锁。</p>
<div class="note info"><p>一个事务在获取某个数据行的共享锁之前，必须先获得整个表的意向共享锁或者更强的锁。</p>
<p>一个事务在获得某个数据行的排它锁之前，必须先获得整个表的意向排它锁。</p>
<p>优点：如果一个事务想要对整个表加排它锁，需要先检测有没有其他事务已经获取了表的排它锁，再检测每一行有没有被加上排它锁，整个过程非常耗时。有了意向锁之后，只需要检测整个表是否被加上意向排它锁即可。</p></div>

</li>
</ol>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><div><div class="fold_hider"><div class="close hider_title">查看</div></div><div class="fold">
<p>Mysql提供了两种封锁粒度：行级锁和表级锁。</p>
<p>封锁力度小表示锁定的数据单元越少，发生锁竞争的可能就越小，系统支持的并发程度越高，但是会增加系统开销，加解锁、检查锁都需要消耗资源。</p>
<p>InnoDB在查询时如果where子句不走索引的话，就会进行全盘扫描，此时将使用表级锁，保证查询结果的正确。</p>

</div></div>

<h3 id="什么是三级封锁协议？"><a href="#什么是三级封锁协议？" class="headerlink" title="什么是三级封锁协议？"></a>什么是三级封锁协议？</h3><ol>
<li>一级封锁协议：事务在修改数据之前必须先对其加排它锁，知道事务结束才能释放。解决了丢失修改问题（如果一个数据正在被修改，那么其他事务无法修改该数据，因此原事务的执行结果不会被覆盖）</li>
<li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，读完即可释放。可以解决脏读问题（如果一个数据正在被修改，此时其他事务无法读取该数据，所以在修改事务提交之前修改结果不可见）</li>
<li>三级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，直到事务结束才能释放。可以解决不可重复读问题（如果读取事务读取数据后就释放，在事务未结束时其他事务可以加排它锁来对数据进行修改，读取事务再次读取数据时，则会读到被修改的数据。三级封锁协议可以保证在整个读取事务期间数据不会被修改）</li>
</ol>
<h3 id="什么是两段锁协议？"><a href="#什么是两段锁协议？" class="headerlink" title="什么是两段锁协议？"></a>什么是两段锁协议？</h3><blockquote>
<p>事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。在事务释放锁之后，就不能再申请加锁。</p>
</blockquote>
<p>两段锁协议可以保证事务满足可串行化调度，也就是并发执行的事务结果与某个串行执行的事务结果相同。</p>
<h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC是指多版本并发控制，INNODB的MVCC，通过在每行记录后保存两个隐藏的列来实现，记录了创建时间和删除时间。这里并不是记录时间戳，而是记录事务版本号。每开启一个事务，系统的版本号就会递增。创建时间的列记录了创建时的事务版本号，删除时间的列记录了删除时的事务版本号。</p>
<p>执行插入操作时，在新创建的行中记录创建版本号；删除操作时记录删除版本号；更新时先在原数据行记录删除版本号，再新增一行并记录创建版本号；在进行查询的时候，只查找创建版本号小于当前事务版本号以及未定义删除版本号和删除版本号大于当前事务版本号的行，这样可以保证已被创建和未被删除。</p>
<h3 id="如何实现读已提交和可重复读？"><a href="#如何实现读已提交和可重复读？" class="headerlink" title="如何实现读已提交和可重复读？"></a>如何实现读已提交和可重复读？</h3><p>读已提交，每次查询都会重新生成readview，readview中有尚未提交的版本号，根据查询的记录的版本号，找到可见的版本号。由于每次查询都会重新生成readview，因此在事务执行过程中，如果有其他的事务完成了提交，再次查询，就会读到不同的数据，也就出现了不可重复读。</p>
<p>可重复读，只会在事务的第一次查询生成一个readview，沿用到事务结束，因此可以解决不可重复读。</p>
<h2 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h2><ol>
<li>第一范式：属性是不可分的。</li>
<li>第二范式：非主属性<strong>完全依赖</strong>于主属性。消除非主属性对主属性的部份依赖。B完全依赖于A表示A中的所有属性唯一确定B。</li>
<li>第三范式：非主属性<strong>直接依赖</strong>于主属性，消除传递依赖。</li>
<li>第四范式：在第三的基础上，每个列不允许有多值，比如移动电话列不允许该用户有两个手机号。</li>
<li>第五范式：#。</li>
<li>BCNF：修正的第三范式，消除主属性之间的传递依赖。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">不符合范式会出现哪些问题？</div></div><div class="fold">
<p>数据冗余：相同的数据重复出现。</p>
<p>插入异常：无法插入一个还没有课程信息的学生</p>
<p>修改异常：修改了一个记录中的信息，相同的信息却没有被修改</p>
<p>删除异常：删除一个信息，丢失其他信息，删除一个课程，将课程的学生也删除了。</p>

</div></div>

<h2 id="主键、超键、候选键、外键分别是什么？"><a href="#主键、超键、候选键、外键分别是什么？" class="headerlink" title="主键、超键、候选键、外键分别是什么？"></a>主键、超键、候选键、外键分别是什么？</h2><ol>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键</li>
<li>候选键：不含有多余属性的超键称为候选键，也就是候选键中不能再删除任何一个属性</li>
<li>主键：用户选作元组标识的候选键</li>
<li>外键：在关系模式R中的属性K是其他关系模式的主键，则K是R的外键</li>
</ol>
<blockquote>
<p>主键是候选键的子集，候选键是超键的子集。</p>
</blockquote>
<h2 id="列举几种表连接的方式？"><a href="#列举几种表连接的方式？" class="headerlink" title="列举几种表连接的方式？"></a>列举几种表连接的方式？</h2><ol>
<li><p>内连接：<code>[inner] join</code> ，只查询出两表中符合查询条件的行信息。</p>
</li>
<li><p>外连接</p>
<div class="note info"><p>左外连接：<code>left [outer] join</code>，左边的表不加限制，将所有行信息都显示，右表没有匹配的用null补上。</p>
<p>右外连接：和左外连接相反。</p>
<p>全外连接：<code>full [outer] join</code>，左右两表都不加限制，将两表所有记录都显示，不匹配的用null补上。</p></div>
</li>
<li><p>交叉连接：<code>cross join</code> ，不带<code>where</code> 子句时，返回笛卡尔积。带<code>where</code> 子句先生成笛卡尔积，再在其中找满足条件的。</p>
</li>
</ol>
<h2 id="delete-drop-truncate的区别"><a href="#delete-drop-truncate的区别" class="headerlink" title="delete/drop/truncate的区别"></a>delete/drop/truncate的区别</h2><ol>
<li>delete是DML语句，逐行的删除数据，并会记录日志，事务提交之后才真正执行。执行速度较低。</li>
<li>truncate是DDL语句，删除整个表的数据，不会记录事务日志，隐式提交。通过释放数据页的内存来删除数据。</li>
<li>drop是DDL语句，将删除整个表的结构和数据，隐式提交</li>
</ol>
<p>如果删除和事务有关，则要使用delete，如果和事务无关，则选择truncate，如果要删除整个表，就使用drop</p>
<h2 id="存储过程、触发器、视图、约束"><a href="#存储过程、触发器、视图、约束" class="headerlink" title="存储过程、触发器、视图、约束"></a>存储过程、触发器、视图、约束</h2><ol>
<li><p>存储过程是一段事先经过编译并存储在数据库的sql语句，类似于函数，通过调用这个函数获得输出结果。</p>
<div class="note info"><p>优点：</p>
<p>预先编译，提高了执行效率。</p>
<p>封装了一系列操作，对于数据交互比较多的操作，可以减少网络通信量。</p>
<p>可复用，安全性高。</p></div>
</li>
<li><p>触发器是由插入/删除/更新操作触发的操作，不能被直接调用，没有参数，用于保证数据的完整性。</p>
</li>
<li><p>视图是从数据库基本表中通过查询选出数据组成的虚拟表。对视图的修改不影响基本表。</p>
</li>
<li><p>约束有多种类型，主键约束、唯一约束、非空约束、外键约束</p>
</li>
</ol>
<h2 id="为什么要使用索引？使用索引的好处？"><a href="#为什么要使用索引？使用索引的好处？" class="headerlink" title="为什么要使用索引？使用索引的好处？"></a>为什么要使用索引？使用索引的好处？</h2><ol>
<li>加快数据的检索速度，避免全盘扫描。</li>
<li>可以显著减少查询中分组和排序的时间，因为如果order by的字段本身就是索引，那么它已经是有序的。</li>
<li>通过创建唯一性索引，可以保证数据表中每一行的唯一性</li>
<li>将随机I/O变为顺序I/O，B+树索引会把相邻的数据存储在一起</li>
</ol>
<p><strong>缺点</strong>：建立和维护索引耗费空间和时间</p>
<h2 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h2><p>和<strong>B树</strong>相比：</p>
<ol>
<li>m阶B+树所有非叶子节点都有m个子树指针，B树最多有m个子树指针，因此B+树的高度会更低。并且B+树的非叶子节点只存放关键字，B树还会存放数据，因此B+树I/O次数更少。</li>
<li>在进行范围查询时，由于B+树的所有数据都在叶子节点，并且叶子节点之间有指针，因此直接遍历叶子节点即可，而B树需要中序遍历整棵树</li>
<li>B+树的查询效率更加稳定，每次都需要从根节点到叶子节点</li>
</ol>
<p>和<strong>hash索引</strong>相比：</p>
<ol>
<li>哈希索引虽然可以以O(1)时间进行查找，但是只支持精确查找，并且在大量哈希值相等的情况下，查询效率会降低</li>
</ol>
<h2 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h2><ol>
<li>以“%”开头的LIKE语句</li>
<li>OR语句前后没有同时使用索引</li>
<li>数据类型出现隐式转化</li>
<li>对于复合索引，必须满足最左匹配原则</li>
<li>在数据量小的表中，Mysql可能判断全盘扫描更快。</li>
</ol>
<h2 id="哪些地方适合创建索引？"><a href="#哪些地方适合创建索引？" class="headerlink" title="哪些地方适合创建索引？"></a>哪些地方适合创建索引？</h2><p>经常被查询、作为表连接、ORDER BY、GROUP BY的字段。数据量小的字段、非空的字段。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol>
<li>功能类：普通索引、唯一索引、主键索引、覆盖索引（索引包含了要返回的值因此不用回表）</li>
<li>按列分：单列索引、符合索引</li>
<li>聚集索引和非聚集索引：聚集索引的顺序决定了数据的物理顺序，因此一张表只有一个聚集索引。非聚集索引只存放数据的逻辑地址。</li>
</ol>
<h2 id="存储引擎InnoDB和MyISAM的区别"><a href="#存储引擎InnoDB和MyISAM的区别" class="headerlink" title="存储引擎InnoDB和MyISAM的区别"></a>存储引擎InnoDB和MyISAM的区别</h2><ol>
<li>InnoDB支持事务、外键、行级锁和表级锁，MyISAM支持表级锁。</li>
<li>MyISAM支持压缩表，需要的内存空间更小，但是压缩后只读，更新操作需要解压后执行。</li>
<li>InnoDB支持在线热备份</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>MyISAM管理非事务表，提供高速存储和检索，对于数据量小，或者只读数据，使用MyISAM效率更高。InnoDB支持事务，在并发下有更好的性能。</p>
<h3 id="热备份和冷备份"><a href="#热备份和冷备份" class="headerlink" title="热备份和冷备份"></a>热备份和冷备份</h3><p>热备份：在数据库运行期间完成快照备份。备份时数据库仍可提供服务</p>
<p>冷备份：数据库关闭后，将数据文件复制到另一位置的备份方式</p>
<h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><ol>
<li><p>SQL优化</p>
<div class="note info"><p>分析慢查询日志，查看查询时间长、IO多的SQL语句，针对性的优化</p>
<p>使用explain分析，查看表的读取顺序、使用了哪些索引、扫描行数。</p>
<p>通过写出需要的列返回必要的列，避免使用select *</p>
<p>通过limit限制返回的行数</p>
<p>将一次大的复杂的多表查询分解成简单的单表查询</p></div>
</li>
<li><p>索引优化：避免索引失效、在合适的地方创建索引</p>
</li>
<li><p>表结构优化：遵循三大范式来进行表设计。数据量大时可以进行表切分</p>
</li>
</ol>
<h3 id="垂直切分和水平切分"><a href="#垂直切分和水平切分" class="headerlink" title="垂直切分和水平切分"></a>垂直切分和水平切分</h3><div class="note info"><p>垂直切分：按业务来切分数据库，相同的业务表存放在同一个数据库节点。垂直切分减少了单节点数据库的负载，原来只有一个数据库，所有业务读写请求都在同一个节点，负载太高。但是对于那些单表数据量就巨大的表（比如商品表、订单表），即使切分到一个数据库，仍然容易造成性能降低。</p>
<p>水平切分：按表中的字段的规则（主键求模、主键范围、日期）把数据切分到不同的数据表，达到缩表的目的。</p>
<p>先进行水平切分，因为水平切分不需要修改整个系统架构，做业务模块的拆分，工作量小。</p></div>

<h2 id="什么是主从复制？实现原理是什么？"><a href="#什么是主从复制？实现原理是什么？" class="headerlink" title="什么是主从复制？实现原理是什么？"></a>什么是主从复制？实现原理是什么？</h2><p>主从复制是指数据可以从一个Mysql数据库主服务器复制到其他的从服务器。</p>
<p>通过三个线程来实现：</p>
<ol>
<li>主服务器binary log dump 线程：将主服务器中的数据更改记录到bin log日志中</li>
<li>从服务器I/O线程：负责从主服务器读取bin log，并写入本地的relay log</li>
<li>从服务器SQL线程：负责读取relay log，解析出主服务器的数据更改，并在从服务器上重放，实现主从数据的一致性。</li>
</ol>
<h3 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h3><ol>
<li>读写分离：主服务器负责写，从服务器负责读。缓解锁竞争，即使主服务器的数据被加了锁，从服务器依然可以处理读请求。从服务器可以采用MyISAM提高查询性能，节省存储空间。</li>
<li>提高系统的可用性，当某个节点出现故障，可以进行故障切换保证服务。</li>
<li>数据实时备份</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>本地配置Git多账户</title>
    <url>/posts/372eebb7.html</url>
    <content><![CDATA[<p>

<a id="more"></a>

<h2 id="1-生成公钥和私钥"><a href="#1-生成公钥和私钥" class="headerlink" title="1. 生成公钥和私钥"></a>1. 生成公钥和私钥</h2><div class="note info"><p>在命令行窗口或<code>git bash</code>下输入命令，默认生成路径为当前路径，建议在系统<code>.ssh</code>文件夹（默认是<code>C:\Users\Administrator\.ssh</code>）下使用命令行或<code>git bash</code></p></div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"a@email.com"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003007.png" alt="图片"></p>
<ol>
<li>进行多用户配置时需要针对不同的账号设置不同的文件名，比如<code>id_rsa_a</code>和<code>id_rsa_b</code></li>
</ol>
<h2 id="2-配置ssh-agent"><a href="#2-配置ssh-agent" class="headerlink" title="2. 配置ssh-agent"></a>2. 配置ssh-agent</h2><div class="note info"><p><code>ssh-agent</code>即ssh代理，管理着本地的所有密钥。当我们进行多用户配置时，需要将多个不同的密钥添加到ssh代理中。启动ssh-agent可能报错，需要用管理员权限打开PowerSheel，执行<code>Set-Service -Name ssh-agent -StartupType automatic</code></p></div>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-<span class="keyword">add</span> id_rsa_a</span><br></pre></td></tr></table></figure>

<h2 id="3-添加公钥到Github账户"><a href="#3-添加公钥到Github账户" class="headerlink" title="3. 添加公钥到Github账户"></a>3. 添加公钥到Github账户</h2><p>路径为<code>settings-&gt;SSH and GPG keys-&gt;New SSH key</code><a href="https://github.com/settings/keys" target="_blank" rel="noopener"></a>，将<code>.ssh</code>文件夹下的<code>id_rsa.pub</code>文件内容粘贴到文本框中，完成添加</p>
<h2 id="4-config文件配置"><a href="#4-config文件配置" class="headerlink" title="4. config文件配置"></a>4. config文件配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//如果不存在，则创建config文件</span><br><span class="line">touch config</span><br></pre></td></tr></table></figure>

<ol>
<li>配置config文件内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#该文件用于配置私钥对应的服务器</span></span><br><span class="line"><span class="comment">#account1(email)</span></span><br><span class="line"> Host git@github.com</span><br><span class="line"> HostName https://github.com</span><br><span class="line"> User a //这里填写username</span><br><span class="line"> IdentityFile id_rsa_a</span><br><span class="line"></span><br><span class="line"><span class="comment">#account2(email)</span></span><br><span class="line"> Host git@gitlab.com</span><br><span class="line"> HostName https://gitlab.com</span><br><span class="line"> User b//这里填写username</span><br><span class="line"> IdentityFile id_rsa_b</span><br></pre></td></tr></table></figure>

<h2 id="5-测试是否可用"><a href="#5-测试是否可用" class="headerlink" title="5. 测试是否可用"></a>5. 测试是否可用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">//<span class="keyword">if</span> success will <span class="built_in">return</span></span><br><span class="line">//Hi a! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">//else return </span></span><br><span class="line"><span class="string">//some errors</span></span><br></pre></td></tr></table></figure>

<h2 id="6-切换账号"><a href="#6-切换账号" class="headerlink" title="6. 切换账号"></a>6. 切换账号</h2><ol>
<li><p>在<code>.ssh</code>文件夹下，创建脚本文件用于切换账号，避免每次都手写切换代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建切换到a账户脚本</span><br><span class="line">touch changeToA.sh</span><br><span class="line">//填入内容</span><br><span class="line">git config --global user.name <span class="string">"a"</span></span><br><span class="line">git config --global user.email  <span class="string">"a@email.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行脚本以切换账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./changeToA.sh</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>开发环境相关</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.04. 检查平衡性</title>
    <url>/posts/4ad52213.html</url>
    <content><![CDATA[<blockquote>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回 <span class="keyword">true</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">4</span>   <span class="number">4</span></span><br><span class="line">返回 <span class="keyword">false</span> 。</span><br></pre></td></tr></table></figure></div>



<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树递归问题，在递归过程中我们将到达一个节点三次，在这三次过程中，我们需要收集树的信息并判断是否符合要求的条件，具体地说，在这个问题中，判断以当前节点为根节点的树是否是平衡的，需要知道左子树是否平衡、右子树是否平衡，当左右都平衡的时候，需要知道当前节点是否平衡——左子树和右子树的高度差。因此我们需要的信息是，左子树的高度以及是否平衡、右子树的高度是否平衡。</p>
<p>于是我们确定了递归需要返回的信息是<strong>树的高度和是否平衡</strong>。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//高度差小于1 -- 需要的值有 当前树的高度,是否平衡</span></span><br><span class="line">    <span class="keyword">return</span> process(root).isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Data <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Data left = process(node.left);</span><br><span class="line">    <span class="keyword">if</span>(!left.isBalanced)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Data right = process(node.right);</span><br><span class="line">    <span class="keyword">if</span>(!right .isBalanced)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(right.h - left.h) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Data(Math.max(left.h, right.h)+<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">    Data(<span class="keyword">int</span> h , <span class="keyword">boolean</span> isBalanced)&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">        <span class="keyword">this</span>.isBalanced = isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>在把思路理清并写出了上面的代码之后，可以再简化代码，具体的是简化返回的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//高度差小于1 -- 需要的值有 当前树的高度,是否平衡</span></span><br><span class="line">    <span class="keyword">return</span> process(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = process(node.left);</span><br><span class="line">    <span class="keyword">if</span>( left == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = process(node.right);</span><br><span class="line">    <span class="keyword">if</span>( right == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(right - left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员面试经典</category>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>程序员面试经典</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树基础</title>
    <url>/posts/75890e6e.html</url>
    <content><![CDATA[<P></p>

<a id="more"></a>

<h2 id="从2-3树开始说起"><a href="#从2-3树开始说起" class="headerlink" title="从2-3树开始说起"></a>从2-3树开始说起</h2><h3 id="🍉简介"><a href="#🍉简介" class="headerlink" title="🍉简介"></a>🍉简介</h3><p>我们知道二分搜索树在插入元素本身是有序的情况下，其将退化成一个链表，查询效率也由O(logN)退化到O(N)，为了提升效率，将二分搜索树优化为平衡二叉树，在插入删除过程中保证左右子树的高度差不超过1，让树的高度最小。但是维护平衡也需要带来更多更复杂的操作，因此引入了2-3树。</p>
<p>2-3树是一棵绝对平衡的树，它的结点可以有2个孩子或3个孩子，这也是其名字的由来，它满足二分搜索树的基本性质，其大小关系如下图</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003409.png" alt="图片"></p>
<h3 id="🍓插入操作"><a href="#🍓插入操作" class="headerlink" title="🍓插入操作"></a>🍓插入操作</h3><p>2-3树在插入结点时不能将结点插入到一个空结点上，因为要保证其绝对平衡的性质，新的结点只能通过分裂或者融合产生。</p>
<p>下面通过对上图的2-3树的构建过程，了解2-3树的插入操作。</p>
<p>依次插入16-15-13-12-11-10-8-6-5</p>
<ol>
<li><p>插入16-15-13</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003432.png" alt="图片"></p>
<p>在插入13之后，形成了一个“4结点”，于是通过<strong>分裂</strong>将其转变为3个2结点</p>
</li>
<li><p>插入12-11</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003503.png" alt="图片"></p>
<p>在插入11之后，形成了一个“4结点”，于是通过<strong>分裂</strong>将其转变为3个2结点，但也因此出现了不平衡，所以需要通过<strong>融合</strong>保证树的绝对平衡。</p>
</li>
<li><p>插入10-8</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003554.png" alt="图片"></p>
<p>和前面的过程类似，需要通过多次的<strong>分裂</strong>和<strong>融合</strong>来保证平衡</p>
</li>
<li><p>插入6-&gt;5</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003606.png" alt="图片"></p>
</li>
</ol>
<div class="note info"><p>可以发现，在插入过程中，2-3树通过融合和分裂两个操作的多次使用，来保证树的绝对平衡。其情况可总结为以下4种</p>
<p>①插入一个2结点，<strong>融合</strong></p>
<p>②插入一个3结点，且是根结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点</p>
<p>③插入一个3结点，其父亲结点是2结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点，再和父亲结点<strong>融合</strong>成一个3结点</p>
<p>④插入一个3结点，其父亲结点是3结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点，再和父亲结点<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点…</p>
<p>其实只要理解了<strong>融合</strong>和<strong>分裂</strong>两个过程，遇到具体情况再具体分析即可，不需要死记情况。</p></div>

<h2 id="与2-3树等价的红黑树"><a href="#与2-3树等价的红黑树" class="headerlink" title="与2-3树等价的红黑树"></a>与2-3树等价的红黑树</h2><h3 id="😯从2-3树到红黑树"><a href="#😯从2-3树到红黑树" class="headerlink" title="😯从2-3树到红黑树"></a>😯从2-3树到红黑树</h3><p>由于2-3树的结点并不统一，也就是2-3树的结点可能有1个元素或者2个元素，在实现上会比较复杂，于是尝试保持结点仍然只有1个元素，但是保持2-3树的思想，大体的做法是：对于2结点，不需要修改；对于3结点，将2个元素拆开，成为两个2结点；并以颜色区分2结点和3结点，2结点为黑色，3结点拆分出来的左侧（较小）的结点为红色，右侧的结点为黑色；这样实现出来的树称为红黑树。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003617.png" alt="图片"></p>
<h3 id="🍉基本性质"><a href="#🍉基本性质" class="headerlink" title="🍉基本性质"></a>🍉基本性质</h3><p>在有了2-3树的基础之后，再来看《算法导论》这本书中对于红黑树的性质介绍，就比较容易理解了。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003626.png" alt="图片"></p>
<ol>
<li>所有的结点或者是红色，或者是黑色。这个是红黑树本身的定义</li>
<li>根结点是黑色的。对于2-3树，它的根结点要么是2结点，要么是3结点，对于2结点，它本身就转化为黑色结点；对于3结点，我们将右侧作为父亲结点，左侧作为孩子结点，并且右侧为黑色，左侧为红色；因此根结点一定是黑色的</li>
<li>所有叶子结点（<strong>空结点</strong>）都为黑色。此处的叶子结点是空结点，而不是左右子树为空的结点。当红黑树为空树时，由性质2，可知根结点为黑色，而此时根结点为空，因此也是性质3的体现</li>
<li>红色结点的左右孩子结点都是黑色的。在2-3树中，从3结点分离出来的红色结点，它的子树根结点只能是2结点或3结点，而经过转化之后，这个子树的根结点只能变为黑色结点，参考性质2。因此红色结点的孩子结点都是黑色的</li>
<li>从每一个结点到其叶子结点所经过的黑色结点数目是相同的。原因是2-3树是一棵绝对平衡的树，因此从一个结点到其叶子结点经过的结点数是相同的，而在转化成红黑树之后，无论是2结点还是3结点，都会转化出一个黑色结点</li>
</ol>
<h4 id="题外问：为什么红黑树能保持O（logN）的复杂度？"><a href="#题外问：为什么红黑树能保持O（logN）的复杂度？" class="headerlink" title="题外问：为什么红黑树能保持O（logN）的复杂度？"></a>题外问：为什么红黑树能保持O（logN）的复杂度？</h4><p>因为红黑树的最大高度为2logN，出现在当有一条从根结点到叶子结点都是3结点的情况下，如果都是2结点，那么和平常的二叉树一样，都是logN，在全是3结点的时候，转化为红黑树时，一个3结点会成为一个红色结点和一个黑色结点，因此高度是2logN的，由于2是常数，在时间复杂度上仍然当作O（logN）级别。</p>
<h3 id="🍓插入操作-1"><a href="#🍓插入操作-1" class="headerlink" title="🍓插入操作"></a>🍓插入操作</h3><p>红黑树也是一棵二分搜索树，因此插入操作的基本步骤是相同的，首先是查找要插入的位置，然后将新结点设置为红色，这一步的原因在于如果将新结点设置为黑色，就会导致从根到叶子的路径上多一个额外的黑色结点，难以调整，而连续的两个红色结点可以通过旋转和颜色翻转来调整。第三步是自下而上的调整树，使其仍为红黑树。</p>
<p>具体的调整分为以下几种情况：</p>
<ol>
<li><p>插入到黑色结点左侧：这种情况即相当于在2-3树中插入到2结点，融合形成3结点，而3结点转化成红黑树正好是左侧为红色、右侧为黑色，因此不需要调整</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003637.png" alt="图片"></p>
</li>
<li><p>插入到黑色结点右侧：在2-3树中仍然是和2结点融合形成3结点，因此我们只需要考虑如何将其调整为3结点转化为红黑树之后的形态，而这一步调整根据我们在AVL树中的经验，可以使用<strong>左旋转</strong>来实现。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003646.png" alt="图片"></p>
<p>对应的代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node x = node.right; <span class="comment">//42</span></span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    x.color = node.color; <span class="comment">//当前子树的根结点从node变为x, 因此x的颜色需要变为node的颜色</span></span><br><span class="line">    node.color = RED;<span class="comment">//在2-3树中的3结点转化后,左侧的结点为红色结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//返回子树新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>插入到左孩子为红色结点的黑色结点右侧：左孩子为红色结点的结点对应于2-3树中的3结点，在其右侧插入新结点后，融合形成一个”4结点“，经过分裂成为3个2结点，也就是黑色结点，其中子树根结点需要保持原来的颜色(（红色）。因此整个过程等同于根结点和其孩子结点交换颜色，称为<strong>颜色翻转</strong></p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003656.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>插入到左孩子为红色结点的黑色结点左侧：相当于在2-3树中的3结点左侧插入一个新结点，为了构造出“4结点”分裂后的树，需要先经过一次<strong>右旋</strong>，由于根结点变为37，因此37需要保持原来根结点42的黑色，而42为了表示其作为“4结点”的一部分，需要变为红色。在经过右旋之后，就成为了情况3，因此之后需要经过一次<strong>颜色翻转</strong></p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003706.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node -&gt; 42</span></span><br><span class="line">    Node x = node.left; <span class="comment">//37</span></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>插入到左孩子为红色结点的黑色结点中间：相当于在2-3树的3结点中间插入一个新结点，综合前面几种情况，可以比较快地构造出“4结点”分裂后的树，首先是先对37所在子树进行一次<strong>左旋</strong>，就得到了<strong>情况4</strong>，之后经过<strong>右旋</strong>，就得到了<strong>情况3</strong>，最后通过<strong>颜色翻转</strong>就可以调整为红黑树</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003716.png" alt="图片"></p>
</li>
</ol>
<p>可以发现，情况4和5可以通过旋转转换为情况3，因此上述的5种情况，其处理的方式可以在统一的流程里实现，即总是经过左旋-&gt;右旋-&gt;颜色翻转就可以完成对树的调整。</p>
<div class="note info"><p>当前结点右孩子为红色结点，左孩子为黑色结点，需要左旋——对应情况2</p></div>

<div class="note success"><p>当前结点左右孩子都为红色结点，需要颜色翻转——对应情况3</p></div>

<div class="note warning"><p>当前结点左孩子为红色结点，左孩子的左孩子为红色结点，需要右旋——情况4</p></div>

<p>于是，在对红黑树进行插入操作的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">    root.color = BLACK; <span class="comment">//保持根结点为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++; <span class="comment">//维护结点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, RED);<span class="comment">//新结点总是红色的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分搜索树的查找并插入</span></span><br><span class="line">    <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;<span class="comment">//插入到右子树</span></span><br><span class="line">        node.right = add(node.right, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;<span class="comment">// 插入到左子树</span></span><br><span class="line">        node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//维护红黑树</span></span><br><span class="line">    <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;<span class="comment">//右孩子为红色 左孩子为黑色</span></span><br><span class="line">        leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;<span class="comment">//左孩子和左孙子为红色</span></span><br><span class="line">        rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.right))&#123;<span class="comment">//左右都红</span></span><br><span class="line">        filpColors(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="noopener">数据结构之红黑树</a></li>
<li><a href="https://class.imooc.com/datastructure" target="_blank" rel="noopener">liuyubobobo《算法和数据结构》</a></li>
<li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络面试问题</title>
    <url>/posts/f4828e27.html</url>
    <content><![CDATA[<p>

<a id="more"></a>

<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><div class="note info"><p>OSI标准是七层模型，TCP/IP中是四层模型</p>
<p>​    <strong>物理层</strong>：完成数模转换和模数转换。网卡</p>
<p>​    <strong>数据链路层</strong>：有错误检测和纠正机制。交换机，ARP协议</p>
<p>​    <strong>网络层</strong>：解决不同子网的通信问题。路由器，RIP协议</p>
<p>​    <strong>传输层</strong>：保证数据段有效到达对端。TCP,UDP协议</p>
<p>​    <strong>会话层</strong>：不同实体建立和使用连接（会话）。全双工、半双工、单工</p>
<p>​    <strong>表示层</strong>：数据的表示方式。编解码、加解密、压缩</p>
<p>​    <strong>应用层</strong>：为用户直接提供服务。FTP(21)、SSH(22)、SMTP和POP3、HTTP、DNS</p></div>

<h3 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a>什么是RIP协议？</h3><p>RIP是距离矢量路由协议，每个路由器维护一张表，记录自己和其他路由器之间的距离，在进行路由的时候优先选择距离短的。通过和相邻路由器交换信息更新表。</p>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址由网络号和主机号组成，共四个字节。根据网络号所占的字节数划分为ABCDE五类网。A类网网络号占一个字节，B类占两个字节，以此类推。</p>
<details>
    <summary>子网划分</summary>
    从主机号借用若干位成为子网号，数据报仍根据网络号找到目的网络，由路由器根据网络号和子网号找到目的子网，通过子网掩码和目的地址逐位与操作，得到子网地址。
</details>


<h3 id="什么是ARP协议"><a href="#什么是ARP协议" class="headerlink" title="什么是ARP协议"></a>什么是ARP协议</h3><p>ARP是地址解析协议，完成了IP地址到物理地址的映射。每一个主机都有一张高速缓存映射表，里面记录了所在局域网内的其他主机和路由器的IP地址和物理地址。当主机需要发送数据包时，将查找自己的ARP缓存，如果能找到目的主机的记录，则直接发送，否则将向所在局域网广播一个ARP请求包，包含自己和目的主机的IP和MAC地址。收到请求的主机将检查自己是不是目的主机，如果是则保存源主机的IP和MAC地址，然后向源主机发送ARP响应，包含自己的IP和MAC地址。如果源主机请求的目的地址不在当前网络，将通过路由器转发到其他局域网进行查找。</p>
<h3 id="什么是NAT？"><a href="#什么是NAT？" class="headerlink" title="什么是NAT？"></a>什么是NAT？</h3><p>NAT是网络地址转换，由NAT路由器将内网中的本地主机IP转换为全球IP地址，让内网中的主机和因特网中的主机进行通信。</p>
<h2 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a>什么是三次握手？</h2><div class="note info"><p>三次握手是遵循TCP协议的通信双方建立连接的过程。</p>
<p>第一次握手：客户端发起连接请求，发送SYN=1，初始化序列号为x的数据包给服务端，进入SYN_SENT状态。</p>
<p>第二次握手：服务端接收请求连接报文，并发送确认包，确认序列号为x+1，同时将SYN位置1，并初始化自己的序列号为y发送给客户端，进入SYN_RECV状态。</p>
<p>第三次握手：客户端接收到确认和请求连接报文，检查确认标志位ACK是否为1，确认序列号是否为x+1，检查正确后，发送确认报文，确认序列号为y+1，进入established状态。服务端接收到确认报文，检查ACK和ack number正确后，进入established状态。三次握手结束，连接建立。</p></div>

<h3 id="TCP建立连接可以两次握手吗？"><a href="#TCP建立连接可以两次握手吗？" class="headerlink" title="TCP建立连接可以两次握手吗？"></a>TCP建立连接可以两次握手吗？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>不可以，主要有以下两个原因。</p>
<ul>
<li><p>两次握手容易造成服务端连接资源浪费的情况，当客户端发送的第一次握手消息由于网络等原因延迟了，客户端会重新发送握手消息，然后成功完成通信并释放连接。此时延迟的握手消息到达了服务端，如果只有两次握手，服务端再接收到这个消息时就会发送确认并建立连接等待接收客户端的数据，但此时客户端并没有想要建立连接，因此服务端的连接资源也就白白浪费了。采用三次握手则可以避免这种情况。</p>
</li>
<li><p>三次握手可以确保通信双方成功互换初始序列号，这是后续通信时确认应答和超时重传的基础，保证TCP的可靠性。</p>
</li>
</ul>

</div></div>

<h3 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>发起连接的一方会生成一个32位的序列号作为初始序列号发送给对端，对端也会发送自己的初始序列号。初始序列号作为原点，对要传输的数据进行编号。根据发送序列号和确认序列号，发送方可以知道接收方已确认接收的数据，接收方可以验证哪些数据编号是合法的。</p>

</div></div>

<h3 id="TCP建立连接可以四次握手吗？"><a href="#TCP建立连接可以四次握手吗？" class="headerlink" title="TCP建立连接可以四次握手吗？"></a>TCP建立连接可以四次握手吗？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>可以，其实三次握手中的第二次握手，服务端将确认和请求连接的消息放在一个报文里，将这个过程拆分成两次握手，就是四次握手。但是这样也浪费了资源</p>

</div></div>

<h3 id="第三次握手中，如果客户端的ACK未到达服务端，会怎样？"><a href="#第三次握手中，如果客户端的ACK未到达服务端，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未到达服务端，会怎样？"></a>第三次握手中，如果客户端的ACK未到达服务端，会怎样？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>服务端如果没有接收到客户端的确认，则会重传第二次握手消息，默认可重传5次，如果都没有接收到确认，就进入CLOSED状态；如果接收到确认，就建立连接。</p>
<p>服务端进入CLOSED状态之后，再接收到客户端的数据，将会以RST包响应。</p>

</div></div>

<h3 id="建立连接后，如果客户端出现故障，会怎样？"><a href="#建立连接后，如果客户端出现故障，会怎样？" class="headerlink" title="建立连接后，如果客户端出现故障，会怎样？"></a>建立连接后，如果客户端出现故障，会怎样？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>服务端每接收到客户端一个报文之后，就会重置自己的计时器，通常是两小时，如果在这期间都没有接收到客户端的数据，则会发送一个探测报文，之后每隔75秒发送一次，如果发送了10次都没有响应，则判断客户端出现故障，就会关闭连接。</p>

</div></div>

<h2 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h2><div class="note info"><p>四次挥手是遵循TCP协议的通信双方释放连接的过程</p>
<p>第一次挥手：客户端完成了数据的传输，发起释放连接请求，FIN=1，序列号为x，进入FIN_WAIT1状态。</p>
<p>第二次挥手：服务端接收到请求后，发送确认报文，进入CLOSE_WAIT状态。客户端接收到确认报文后，进入FIN_WAIT2状态。</p>
<p>第三次挥手：服务端也完成了数据的发送，发送释放连接报文，进入LAST_ACK状态。</p>
<p>第四次挥手：客户端接收到释放连接请求，发送确认报文，进入TIME_WAIT状态，等待2MSL时间后，释放连接，进入CLOSED状态。服务端接收到确认报文后，释放连接，进入CLOSED状态。</p></div>

<h3 id="为什么不能三次挥手？服务端的CLOSE-WAIT状态有什么意义？"><a href="#为什么不能三次挥手？服务端的CLOSE-WAIT状态有什么意义？" class="headerlink" title="为什么不能三次挥手？服务端的CLOSE_WAIT状态有什么意义？"></a>为什么不能三次挥手？服务端的CLOSE_WAIT状态有什么意义？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>客户端发起释放连接的请求只能确认客户端没有数据要进行传输了，但此时服务端可能还有未发送的数据，CLOSE_WAIT状态用来等待服务端数据也发送完毕再释放连接。</p>

</div></div>

<h3 id="TIME-WAIT状态的意义？"><a href="#TIME-WAIT状态的意义？" class="headerlink" title="TIME_WAIT状态的意义？"></a>TIME_WAIT状态的意义？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>第四次挥手，客户端的ACK可能会丢失，TIME_WAIT状态用来重发可能丢失的ACK。如果服务端没有接收到ACK，则会重发FIN报文。TIME_WAIT的时长是2MSL，MSL就是报文段在网络中的最长存活时间。客户端的ACK在一个MSL内没到达服务端，服务端就会重发FIN，这个重发的FIN最长存活时间也是MSL，那么在2MSL时间内都没有接收到服务端重发的FIN，则认为ACK已经成功到达服务端。</p>

</div></div>

<h2 id="TCP如何进行流量控制？"><a href="#TCP如何进行流量控制？" class="headerlink" title="TCP如何进行流量控制？"></a>TCP如何进行流量控制？</h2><div class="note info"><p>使用滑动窗口协议来实现流量控制。接收方根据自己缓冲区的情况，动态调整接收窗口大小，并将接收窗口大小放在ACK报文中发送给发送方。发送方的发送窗口大小不能超过接收窗口，防止发送速率太快，接收方缓冲区不够导致溢出。当发送方接收到确认之后，将窗口向右滑动。</p></div>

<h3 id="什么是”零窗口“？"><a href="#什么是”零窗口“？" class="headerlink" title="什么是”零窗口“？"></a>什么是”零窗口“？</h3><p>当接收方无法接受新数据时，就会将接收窗口大小设为0，发送方将会停止发送数据，并通过1字节大小的探测报文来检查接收窗口的变化，当接收窗口&gt;0时，就恢复数据发送。</p>
<h2 id="TCP如何进行拥塞控制？"><a href="#TCP如何进行拥塞控制？" class="headerlink" title="TCP如何进行拥塞控制？"></a>TCP如何进行拥塞控制？</h2><p>拥塞控制主要通过四个算法实现，分别是慢开始、拥塞避免、快重传、快恢复。</p>
<p><img src="https://gitee.com/jingshanccc/image/raw/master/image/20200722003811.jpg" alt="拥塞控制"></p>
<div class="note info"><p><strong>慢开始</strong>：刚开始发送数据时，将拥塞窗口大小设置为1MSS，最大报文段长度，之后每收到一个确认ACK，就将窗口增大1个MSS，这样窗口大小随着传输轮次呈指数增长。</p>
<p><strong>拥塞避免</strong>：当慢开始执行到窗口大小等于慢开始门限时，将减缓窗口增大速度，每个传输轮次线性增长。</p>
<p><strong>快重传</strong>：快重传要求接收方在接收到一个失序的报文段后立即发出重复确认。当发送方连续接收到三个重复确认，就要立即重传失序的报文段。</p>
<p><strong>快恢复</strong>：当发送方接收到三个重复确认时，就把慢开始门限减小为拥塞窗口的一半，然后执行拥塞避免算法。</p>
<p>出现<strong>重传</strong>的两种情况：</p>
<p>超时未接收到ACK：发送方在发送完一个报文段时，会启动一个计时器，当超时未接受到ACK时，则会重新传输该报文段。在这种情况下，发送方认为网络状况不佳，因此将慢开始门限设置为拥塞窗口的一半，拥塞窗口设置为1，重新执行慢开始算法。</p>
<p>接收到3个重复确认：此时由于可以接收到3个重复确认，因此网络没有出现拥塞，此时将慢开始门限减小为拥塞窗口的一半，但可以适当增大拥塞窗口，然后执行拥塞避免算法。</p></div>

<h3 id="慢开始门限有什么用？"><a href="#慢开始门限有什么用？" class="headerlink" title="慢开始门限有什么用？"></a>慢开始门限有什么用？</h3><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><div class="note info"><p>TCP面向连接，UDP面向无连接，即UDP传输数据前不需要建立连接</p>
<p>TCP是可靠的，UDP是不可靠的，因为UDP接收方不需要发送确认，也就没有确认重传等机制</p>
<p>TCP有拥塞控制，在网络拥塞时控制发送速率，UDP不会因为网络的拥塞而减小发送速率，这在实时应用中是很重要的</p>
<p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多</p>
<p>TCP是面向字节流的，一个数据包可以以字节为单位拆分成多个组发送，UDP是面向数据报文的，一个报文只能一次发完。</p>
<p>TCP的报文首部20字节，比UDP8字节开销更大。</p></div>

<h3 id="什么时候使用TCP，什么时候使用UDP？"><a href="#什么时候使用TCP，什么时候使用UDP？" class="headerlink" title="什么时候使用TCP，什么时候使用UDP？"></a>什么时候使用TCP，什么时候使用UDP？</h3><p>在实时性要求高、可以容忍传输错误的应用中，如直播、游戏、即时通信，使用UDP。其他情况使用可靠的TCP。</p>
<h3 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h3><p>以前来说不可以，HTTP需要可靠的传输协议，UDP不可靠。而新的HTTP/3基于QUIC协议，不再使用TCP，在UDP的基础上增加拥塞控制和可靠性等。</p>
<h2 id="TCP如何保证传输的可靠性？"><a href="#TCP如何保证传输的可靠性？" class="headerlink" title="TCP如何保证传输的可靠性？"></a>TCP如何保证传输的可靠性？</h2><div class="note info"><p>奇偶校验和：检查数据包是否出错</p>
<p>乱序重排：正确接收数据</p>
<p>丢弃重复包：正确接收数据</p>
<p>确认应答机制：发送确认让发送方知道数据已被成功接收</p>
<p>超时重传机制：未被接收的数据重新发送</p>
<p>流量控制：控制发送速率避免接收方缓冲区发生溢出</p></div>

<h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><div class="note info"><p>HTTP默认使用80端口，HTTPS使用443端口</p>
<p>HTTP使用明文传输，HTTPS运行于SSL协议之上，有加密和认证机制，更加安全</p>
<p>HTTPS加解密过程需要消耗更多的CPU和内存</p>
<p>HTTPS需要向证书颁发机构CA购买证书</p></div>

<h3 id="HTTPS建立连接的过程？"><a href="#HTTPS建立连接的过程？" class="headerlink" title="HTTPS建立连接的过程？"></a>HTTPS建立连接的过程？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<ul>
<li>浏览器向服务端发送连接请求，消息内容包含自己支持的加密规则（对称加密、非对称加密、摘要算法）</li>
<li>服务端接收到请求后，选择一套加密规则，生成非对称加密的公钥，和证书一起发送回浏览器</li>
<li>浏览器验证证书的有效性，随机生成用于对称加密的密钥，使用服务端的公钥加密生成密文，通过摘要算法生成摘要，一起发送给服务端</li>
<li>服务端使用私钥解密消息，通过摘要算法验证数据完整性，得到浏览器生成的密钥，然后使用密钥加密消息，并生成摘要发送给浏览器。</li>
<li>浏览器接受后使用密钥解密消息并验证完整性，成功之后，连接建立，接下来使用密钥加密数据传输保证安全性。</li>
</ul>

</div></div>

<h3 id="直接输入-www-baidu-com-是如何转为HTTPS的？"><a href="#直接输入-www-baidu-com-是如何转为HTTPS的？" class="headerlink" title="直接输入 www.baidu.com , 是如何转为HTTPS的？"></a>直接输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> , 是如何转为HTTPS的？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>打开浏览器的调试界面，可以看到直接使用 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 时，服务端会发回307响应，在响应头中的LOCATION指定重定向的地址为 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> ，然后浏览器重新向该地址发起请求。服务端在响应头中携带Strict-Transport-Security字段，设置过期时间，在这段时间内，再次请求该地址，浏览器会自动转换为HTTPS。</p>

</div></div>

<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><div class="note info"><p>GET一般用于向服务端获取资源，POST可能会对服务端资源进行修改。因此GET具有幂等性，即每次请求相同的URL会获得相同的响应，POST不具有幂等性。</p>
<p>GET的请求参数附在URL上，在请求头中，POST的请求参数放在请求体中。</p>
<p>由于浏览器或操作系统对URL长度限制，因此GET的请求参数不能过长，而POST则没有限制</p></div>

<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><div class="note info"><p>Session是服务端保存状态的方式，Cookie是客户端保存状态的方式</p>
<p>Cookie保存在客户端，发起请求时将cookie放在请求头一起提交；Session保存在服务端，通过sessionId检查状态。</p>
<p>sessionId可以保存在cookie中，如果禁用了cookie，可以将sessionId放在URL中。</p></div>

<h2 id="输入URL到看到页面的过程"><a href="#输入URL到看到页面的过程" class="headerlink" title="输入URL到看到页面的过程"></a>输入URL到看到页面的过程</h2><div class="note info"><p>浏览器通过DNS解析域名获取服务端IP地址。</p>
<p>三次握手建立TCP连接，之后浏览器发起HTTP请求</p>
<p>服务端根据请求URL找到对应的请求处理器，处理之后返回响应包含处理结果和视图</p>
<p>浏览器解析并渲染视图，可能会再次请求页面中引用的其他静态资源文件</p>
<p>渲染完成，请求结束。</p></div>

<h2 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h2><div class="note info"><p>200：请求成功</p>
<p>301：永久重定向，接下来的请求都应该使用新的URL. 302：临时重定向</p>
<p>400：错误的请求，可能是请求方法错误. 401：未认证. 403：禁止访问. 404：无法找到</p>
<p>500：内部错误. 502：错误网关. 503：由于超载或系统维护服务不可用</p></div>
]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
