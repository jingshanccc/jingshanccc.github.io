<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis面试问题</title>
    <url>/posts/e745ac01.html</url>
    <content><![CDATA[<p>
<a id="more"></a>

<h2 id="为什么要使用缓存？"><a href="#为什么要使用缓存？" class="headerlink" title="为什么要使用缓存？"></a>为什么要使用缓存？</h2><ol>
<li><p>高性能</p>
<p>假设用户第一次访问数据库获取数据，这个过程是比较慢的，因为是从硬盘读取，同时如果需要获取的数据本身查询过程十分耗时，那么我们将第一次获取到的结果直接放在缓存中，下一次访问直接在缓存中获取即可，操作缓存就是操作内存，速度更块。</p>
</li>
<li><p>高并发</p>
<p>内存能够承受的请求是远远大于直接访问数据库的，所以我们将数据库的部分数据转移到缓存中，可以让部分请求直接访问内存而不经过数据库。</p>
</li>
</ol>
<details>
<summary>数据库有缓存吗？</summary>
有，以mysql为例，它会将查询sql和结果以key-value的形式缓存起来，再遇到hash值相同的sql语句就不再经过编译解析优化和查询，直接返回结果。<br/>
缺点：
    通过hash，意味着语义相同的可能有不同的表达，这样也无法命中缓存。对于频繁更新的表，缓存总是难以命中，但还是需要耗费资源维护缓存。
</details>

<h2 id="选择Redis的原因？"><a href="#选择Redis的原因？" class="headerlink" title="选择Redis的原因？"></a>选择Redis的原因？</h2><h3 id="本地缓存和分布式缓存"><a href="#本地缓存和分布式缓存" class="headerlink" title="本地缓存和分布式缓存"></a>本地缓存和分布式缓存</h3><ol>
<li><p>Java中使用map/guaua来做本地缓存，直接将数据存在jvm内存中，与jvm拥有相同的生命周期。其优点是轻量且快速。但在多实例的情况下，每个实例都需要保存自己的一份缓存，不具有一致性</p>
</li>
<li><p>Redis和Memcache实现的是分布式缓存，在多实例下，共用一份缓存，具有一致性。因此需要保证服务的高可用，架构较复杂。</p>
</li>
</ol>
<h3 id="redis和memcache"><a href="#redis和memcache" class="headerlink" title="redis和memcache"></a>redis和memcache</h3><ol>
<li>持久化：memcache不支持持久化，缓存数据只存在在内存中，断电后数据就丢失了。redis提供了持久化机制，可以将数据保存到磁盘中，重启后通过日志文件可以恢复数据。</li>
<li>数据类型：memcache只支持简单的string类型，redis除了string之外，还支持列表，哈希，集合等多种数据结构。</li>
<li>分布式：memcache不支持分布式，只能通过多个客户端使用一致性哈希来向集群中存储数据，这种方式在查询和存储时都需要计算一次。redis原生支持集群模式。</li>
<li>线程模型：memcache是多线程的，redis默认是单线程的，减少了线程切换的消耗</li>
</ol>
<h2 id="说说Redis的线程模型？"><a href="#说说Redis的线程模型？" class="headerlink" title="说说Redis的线程模型？"></a>说说Redis的线程模型？</h2><p>redis内部采用文件事件处理器，它是单线程的，通过I/O多路复用机制，监听多个socket，根据socket上的事件选择对应的事件处理器来处理。<br>文件事件处理器包括四个部分：socket、I/O多路复用程序、事件分派器、事件处理器（包括连接应答处理器，命令请求处理器，命令回复处理器）</p>
<p>redis基于reactor模式开发出自己的I/O多路复用程序，多个socket同时产生的事件将被加入到队列中，事件分派器从队列中取出事件，根据事件类型分派给不同的事件处理器。</p>
<details><summary>事件的调度和执行</summary>
redis服务器是一个事件驱动程序，有文件事件和时间事件。服务器需要一直监听socket以得到到达的文件事件，但是由于需要执行时间事件，不能一直监听，否则时间事件不能在预期时间内执行。因此，redis通过计算距离最近的时间事件，根据所剩的时间，监听文件事件，在剩余时间结束后，处理该时间段内的文件事件，同时处理该时间的时间事件。不断重复直到服务器关闭。
</details>

<h2 id="你了解Redis的数据类型吗？应用场景是什么？"><a href="#你了解Redis的数据类型吗？应用场景是什么？" class="headerlink" title="你了解Redis的数据类型吗？应用场景是什么？"></a>你了解Redis的数据类型吗？应用场景是什么？</h2><ol>
<li><p>String字符串</p>
<p>存储：字符串，整型，浮点型</p>
<p>命令：set get incr decr</p>
<p>应用场景：key-value存储，计数器</p>
<p>底层实现：简单可变字符串，使用char数组保存数据，并有长度len，空闲长度free。记录len和free属性可以实现空间预分配和惰性释放。通过len减少连续增长字符串时所需的空间重分配的操作次数，因为每次增长字符串时将多分配len字节的未使用空间。通过free优化字符串的缩短操作，不需要在每次缩短时立即释放未使用的空间，通过free记录下来等待将来使用</p>
</li>
<li><p>List列表</p>
<p>存储：列表</p>
<p>命令：lpop lpush rpop rpush lrange(实现分页查询)</p>
<p>应用场景：关注列表/粉丝列表/消息列表</p>
<p>底层实现：结构体包含链表头节点、尾节点、长度、释放/复制/比较节点函数。节点数据结构包含前置/后置指针、任意类型的值。</p>
</li>
<li><p>Set集合</p>
<p>存储：集合，去重</p>
<p>命令：sadd spop smembers sunion</p>
<p>应用场景：由于有方便的求交集差集并集的操作，可以实现共同关注等</p>
<p>底层实现：使用整形集合或字典实现。</p>
<p>​    <strong>整型集合</strong>：当集合只包含int类型时，使用intset存放，intset数据结构中包含编码格式、数组、长度。编码格式规定了能存储的数据范围，比如int_16t表示存储-32768-32767（1位符号位15位数值位），超出范围则会自动升级到32位。</p>
<p>​    <strong>字典</strong>：Dict是最上层的结构体，包含两个distht哈希表（一个用于存放数据一个用于rehash）、rehashidx、类型特定函数（键值复制释放、哈希函数、键比较函数）。distht哈希表包含distEntry数组、表的大小、已用大小、计算索引的sizemark。distEntry结构体是数组中存放的数据类型，包含key、value、next指针。</p>
</li>
<li><p>Hash映射表</p>
<p>存储：包含键值对的无序散列表</p>
<p>命令：hset hget hexists hlen</p>
<p>应用场景：存储结构化的对象 非常方便的修改某个属性</p>
<p>底层实现：使用字典或压缩列表实现。</p>
<p>​    <strong>字典</strong>。</p>
<p>​    <strong>压缩列表</strong>：结构体中包含所占字节数zlbytes、尾部到起点的字节数zltail、节点数zllen、列表末端zlend、节点数组entry。节点结构体包含的属性有前一个结点的长度previous_length、数据类型encoding、数据内容content。存放hash对象时，键一个entry值一个entry</p>
</li>
<li><p>SortedSet有序集合</p>
<p>存储：跟set相比，增加了权重参数，根据参数来排序</p>
<p>命令：zadd zrange zrem zrank zcount</p>
<p>应用场景：由于是排序的，可以实现排行榜等</p>
<p>底层实现：使用跳跃表和字典来实现。<strong>跳跃表</strong>：基于链表+索引实现，解决了数组插入时的O(n),链表查询时的O(n)。由多层链表组成，每一层都是有序链表，上一层的链表是下一层链表的子集。每一个链表结点都有两个指针，一个指向同层的下一个结点，另一个指向下一层的同一个链表节点。最上层结构体是zskiplist，包含头节点和尾节点skiplistNode、节点数量length、最大层数level。</p>
</li>
</ol>
<h2 id="Redis中Key的过期时间是怎么实现的？"><a href="#Redis中Key的过期时间是怎么实现的？" class="headerlink" title="Redis中Key的过期时间是怎么实现的？"></a>Redis中Key的过期时间是怎么实现的？</h2><p>通过set key的expiretime来设置key的存活时间，过期自动删除。redis中有两种key的过期机制。</p>
<ul>
<li>定期删除：默认每100ms<strong>随机抽取</strong>内存中的key判断是否过期决定是否删除。可以在配置文件中设置间隔时间。定期删除每次不会检查所有key，因为这样会十分耗时，因此采用随机选择部分key进行判断。</li>
<li>惰性删除：因为定期删除可能遗漏了部分key，惰性删除则在key<strong>再次被请求</strong>时，判断是否过期决定是否删除。</li>
</ul>
<p>但是在这两种过期机制下，还是会存在key到期也没被删除，定期删除没有删掉，惰性删除因为没有再次请求也没有生效，此时可能内存占用会越来越高。redis通过设置<strong>内存淘汰策略</strong>解决这一问题。</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>当内存超过了设置的最大内存限制，就会执行内存淘汰策略。</p>
<ol>
<li>allkeys-lru:从所有数据集中选择最近最久未使用的数据淘汰</li>
<li>allkeys-lfu:从所有数据集中选择访问频率最低的数据淘汰</li>
<li>allkeys-random:从所有数据集中随机选择数据淘汰</li>
<li>no-eviction：不淘汰，新写入时报错</li>
<li>volatile-lru:从已设置过期时间的数据集中选择最近最久未使用的数据淘汰</li>
<li>volatile-lfu:从已设置过期时间的数据集中选择访问频率最低的数据淘汰</li>
<li>volatile-ttl:从已设置过期时间的数据集中选择将要过期的数据淘汰</li>
<li>volatile-random:从已设置过期时间的数据集中随机选择数据淘汰</li>
</ol>
<p>lru：redis中的lru不使用常规的维护队列的方式，通过全局的时钟和key中保存的时钟，选择最久未被使用的淘汰。一般场景下，缓存中存放热点数据，为了提高缓存命中率，使用lru策略<br>lfu：将lru中的24位时钟分为两部分，前16位记录时钟，后8位记录访问频率。访问频率并不是简单的线性增长，而是设置参数lfu-log-factor和lfu-decay-time通过公式来计算实现。</p>
<p><em>当数据集中没有设置过期时间的key，前四种策略将由于不满足先决条件而和no-eviction相同</em></p>
<h2 id="redis断电之后数据如何恢复？"><a href="#redis断电之后数据如何恢复？" class="headerlink" title="redis断电之后数据如何恢复？"></a>redis断电之后数据如何恢复？</h2><p>通过redis的持久化机制，在重启之后可以恢复数据。redis提供了以下三种持久化机制。</p>
<ul>
<li>RDB快照持久化：将某一时刻的数据保存到文件中，通过配置文件可以设置在n秒内如果数据发生m次变化则触发bgsave创建快照，备份当前数据。也可以手动调用bgsave来触发持久化。rdb持久化的优点是文件小，恢复快。缺点是实时性较差，最后一次快照之后的数据将丢失。</li>
<li>AOF持久化：开启了aof持久化后，redis将把每一条改变数据的操作追加到日志文件中。这样的缺点是aof文件会不断增大，可以通过日志重写来解决，日志重写的过程将当前数据直接生成新的命令写入到新的aof文件中，合并和简化命令。</li>
<li>混合持久化：开启混合持久化后，aof重写时将当前数据以rdb格式写入到文件，在此过程中新的变化将以aof格式写入，恢复时先将重写rdb内容，再执行aof的内容。</li>
</ul>
<h2 id="了解redis的事务吗？"><a href="#了解redis的事务吗？" class="headerlink" title="了解redis的事务吗？"></a>了解redis的事务吗？</h2><p>redis事务通过MULTI、EXEC、DISCARD、WATCH来实现。只有在将命令添加进队列时发现语法错误才会导致EXEC命令报错。语法正确的指令即使是执行时出错，redis也会执行其他命令。</p>
<ul>
<li>MULTI:开启一个事务，之后可以一条条输入想要执行的命令添加到队列中</li>
<li>EXEC:执行在MULTI之后队列中添加的所有命令</li>
<li>DISCARD:回滚，取消执行MULTI开启的事务</li>
<li>WATCH:监控一个或多个key，当key发生变化时，事务将不会被执行。提供了CAS的功能，在MULTI开始之前，监控key，EXEC时判断key是否修改过。</li>
</ul>
<h2 id="说说缓存穿透和缓存雪崩"><a href="#说说缓存穿透和缓存雪崩" class="headerlink" title="说说缓存穿透和缓存雪崩"></a>说说缓存穿透和缓存雪崩</h2><ul>
<li>缓存穿透：用户请求的数据不在数据库中，自然也不在缓存中，此时每次请求该key，总是无法在缓存中找到，也无法在数据库中找到。因此每次都会访问数据库。这种现象称为缓存穿透。</li>
</ul>
<p>​    <strong>解决方法</strong>：1. 为该key设置null值，但是设置较短的过期时间，避免当数据存在时却在缓存中获取到空值。2. 使用布隆过滤器，将所有可能存在的数据哈希到一个bitmap中，不存在的数据一定会被bitmap拦截。</p>
<ul>
<li>缓存雪崩：大量的key在同一时间失效，导致请求全部落在数据库。</li>
</ul>
<p>​    <strong>解决办法</strong>：1. 预防：错开过期时间 2. 应对：限流以保证数据库不会挂掉</p>
<details>
<summary>缓存击穿</summary>
一个热点数据在失效瞬间，仍然有大量请求来获取，此时缓存失效，请求都落在数据库上。**解决方法**：1. 热点数据永不过期 2. 使用互斥锁：在请求时先查缓存，有则返回，否则尝试获取锁，成功之后查询数据库并更新缓存然后释放锁，获取锁失败说明已经有线程在查数据库准备更新缓存，因此可以通过自旋之后重试查询缓存。
</details>

<details>
<summary>布隆过滤器</summary>
单个hash函数可能出现不同数据hash值相同的情况，因此通过采用k个相互独立的hash函数解决冲突，将所有可能存在的数据hash到一个bitmap中。
</details>

<h2 id="如何解决并发竞争key问题？"><a href="#如何解决并发竞争key问题？" class="headerlink" title="如何解决并发竞争key问题？"></a>如何解决并发竞争key问题？</h2><p>多个客户端对同一个key做set操作。<br>解决方案：</p>
<ol>
<li>乐观锁：通过watch可以方便的实现乐观锁，watch监听的key在事务期间发生变化，事务将会回滚</li>
<li>时间戳：在set key时加入时间戳，通过比较key的时间戳来确定是否继续执行set操作</li>
<li>消息队列：将并发的操作加入到消息队列中，串行化执行</li>
<li>分布式锁：客户端在执行操作之前需要先获取分布式锁</li>
</ol>
<h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><blockquote>
<p>分布式锁是控制分布式系统之间同步访问共享资源的方式。在分布式系统中，多个系统共享一个资源，使用分布式锁来保证数据一致性</p>
</blockquote>
<h4 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h4><div class="note info"><p>使用set lock_key random_value nx px n完成加锁（一次原子性的setnx+expire），解锁时先get根据random_value判断是否是锁的拥有者，再进行del。为了保证原子性，使用lua脚本.</p></div>

<div class="note info"><p>使用redisson实现，方法1的实现锁不具有可重入性。redisson加解锁过程如下：</p>
<ol>
<li>加锁：通过tryAcquire来获取锁，如果返回的ttl为空表示加锁成功。加锁失败则会订阅该锁的channel，等待锁被释放的消息，再重新获取锁。tryAcquire中使用lua脚本来加锁，锁使用hash结构来实现。hexists判断锁是否存在，不存在则hset加锁成功，存在则判断是否是当前线程的锁，是则hincrby将count+1（可重入锁），否则返回锁的过期时间。</li>
<li>解锁：同样使用lua脚本。先判断锁是否存在，不存在则publish发布释放锁的消息，解锁成功。锁存在则判断是否是当前线程的锁，如果是通过hincrby将count-1，当count为0，将del锁并publish释放锁的消息，如果不是则抛出异常。</li>
</ol></div>

<h4 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h4><div class="note info"><p>redlock算法：根据<a href="http://redis.cn/topics/distlock.html/" target="_blank" rel="noopener">redis官网</a>描述总结。假定有5个redis实例，且相互独立，没有主从关系（原因是防止master节点没来得及把新set的锁复制到slave上）。</p>
<ol>
<li>尝试向五个实例获取锁</li>
<li>超过获取锁的限制时间则跳到下一个实例</li>
<li>超过半数（这里是3个）成功加锁并且消耗的总时间小于锁的过期时间则加锁成功</li>
<li>加锁失败/释放锁，将向<strong>所有实例</strong>发出解锁请求。因为可能存在某个节点set成功但是由于网络问题客户端没有接收到其响应，因此需要向所有节点发出解锁请求</li>
<li>redlock采用<strong>延时重启</strong>来解决故障重启后带来的安全性问题：A B C三个节点，客户端1请求加锁在A B上获得成功，1获取锁。然后B宕机重启，由于持久化策略等问题，导致B上的锁没有被恢复，此时客户端2请求相同的锁，在BC上获取成功，这样客户端1和2就持有了相同的锁。</li>
</ol></div>

<div class="note info"><p>zookeeper：客户端每次请求一把锁，就在zookeeper对应节点目录下创建一个有序节点，只需要比较节点的顺序就可以判断是否成功获取锁。</p></div>

<h2 id="redis单点-单机会有什么问题-挂掉怎么办？"><a href="#redis单点-单机会有什么问题-挂掉怎么办？" class="headerlink" title="redis单点/单机会有什么问题/挂掉怎么办？"></a>redis单点/单机会有什么问题/挂掉怎么办？</h2><p>为了避免redis单机挂掉的问题，我们可以搭建redis集群来保证redis服务的高可用。redis集群有以下三种模式：</p>
<ol>
<li><p>主从模式：实现读写分离，主节点的数据通过全量/增量同步发送到从节点上</p>
</li>
<li><p>哨兵模式：主从模式升级版，哨兵监听主节点的状态，发现宕机后选出新的主节点</p>
</li>
<li><p>集群模式：一个redis cluster由多个redis节点组组成，每个节点组内由主从节点，负责数据的一个/多个分片-slot。</p>
</li>
</ol>
<div class="note info"><p><strong>配置的一致性</strong>：集群中的每个节点都保存了集群的配置信息，通过一个全局的版本号epoch来保证信息的一致。各节点之间通过频繁的ping/pong消息携带的gossip部分更新自己对集群的认识。当某个节点率先感知了集群的变化后，自增自身的epoch并将其通过ping/pong消息扩散出去，其他节点发现接收到的epoch＞自身于是更新自身关于集群的信息。</p>
<p><strong>数据分片</strong>：cluster中节点组之间负责的数据互相独立，客户端需要通过一致性哈希算法将key映射到0-16383个slot中的一个上，找到对应的redis节点。当请求的key不在节点上（发生了数据迁移），会返回moved/ask消息告知客户端.</p>
<p><strong>Failover保证高可用</strong>：故障发现、故障确认、主备切换机制</p>
<ol>
<li><p>故障发现：各节点在进行ping/pong交换信息时，如果一个节点A的ping消息超时没有收到对端B的pong回复，则会在自身集群信息中将该节点状态设置为pfail，并通过和其他节点的ping/pong将此信息传递到整个集群。</p>
</li>
<li><p>故障确认：节点A在1之后，如果接收到其他节点的gossip消息中B也为pfail状态，则会将B的状态升级为fail，确认故障，然后发起slave选举流程。</p>
</li>
<li><p>slave选举：A作为B的salve在确认B为故障节点后，发起竞选：将自己的epoch自增并发送FAILOVER_AUTH_REQUEST到其他的master节点，如果master未收到过FAILOVER_AUTH_REQUEST(收到时的自身epoch小于FAILOVER_AUTH_REQUEST中的epoch)，则回复同意，否则拒绝。当A收到超过半数的master同意之后，将替代B称为master节点，更新自己的epoch，通过配置一致性完成集群结构的更新。当B回复正常后，通过与其他节点的gossip消息可以得知新的master节点为A，自己将会成为A的slave节点。</p>
</li>
</ol></div>

<details><summary>数据迁移</summary>
    当加入新的master节点/ 旧的节点组下线/负载不均衡需要调整时，会发生数据迁移，迁移过程：<br/>
    1. 设置slot原所在节点A状态为migrating,slot新节点B状态为importing.<br/>
    2. 针对A上的slot的所有key，分别发送migrate命令将数据迁移到B.<br/>
    migrating的A：如果请求的key尚未迁出则正常提供服务；如果已经迁出则使用ask回复让客户端跳转到B.<br/>
    importing的B：如果请求不是由ask跳转的则通过moved让客户端跳转到A上.<br/>
    这样的跳转控制可以让同一个key操作迁移之前在原节点执行，迁移之后在新节点执行，避免冲突。迁移完成之后，通过配置的一致性让整个集群更新配置。
</details>

<details><summary>moved和ask</summary>moved会更新client的路由缓存，即moved之后对相同的key操作会直接到新节点上，ask操作只是单次的，之后相同的key还是回到原来的节点上</details>

<h2 id="如何保证缓存和数据库的一致性？"><a href="#如何保证缓存和数据库的一致性？" class="headerlink" title="如何保证缓存和数据库的一致性？"></a>如何保证缓存和数据库的一致性？</h2><p>如果要求数据库和缓存的实时一致性，那么只能串行化地执行读写请求。一般来说允许缓存和数据库出现短暂的不一致。最经典的方式是先更新数据库，再删除缓存。读请求先查缓存，缓存没有则查询数据库，将查询结果放入缓存中，返回响应。更新时，先更新数据库，再删除缓存。</p>
<h3 id="为什么是删除缓存，而不是更新缓存？"><a href="#为什么是删除缓存，而不是更新缓存？" class="headerlink" title="为什么是删除缓存，而不是更新缓存？"></a>为什么是删除缓存，而不是更新缓存？</h3><p>在复杂一点的缓存场景中，缓存中的数据并不是简单的从数据库中直接获取。存入缓存的数据可能需要进行多表查询并进行计算得到。所以更新缓存的成本是比较高的。除此之外，缓存的数据如果来自一张频繁更新的表，但是缓存却较少的被访问，也会造成资源的浪费。因此采用删除缓存，是一种懒加载的思想，等到需要的时候发现缓存中没有再查询数据库将结果放入缓存。</p>
<h3 id="先更新数据库再删除缓存就一定能保证一致性吗？"><a href="#先更新数据库再删除缓存就一定能保证一致性吗？" class="headerlink" title="先更新数据库再删除缓存就一定能保证一致性吗？"></a>先更新数据库再删除缓存就一定能保证一致性吗？</h3><p>不一定，在更新完数据库之后，如果删除缓存失败，此时缓存中是旧的数据，而数据库是新的数据，出现了不一致。解决方法是：先删除缓存，再更新数据库。如果更新数据库失败了，再次请求则会去读取旧的数据，不会产生数据不一致。</p>
<h3 id="这样就没问题了吗？"><a href="#这样就没问题了吗？" class="headerlink" title="这样就没问题了吗？"></a>这样就没问题了吗？</h3><p>如果在并发量较低的情况下，一般不会出现问题。但是当并发量较大，对一个数据并发读写就可能出现：如果在删除完缓存之后，尚未完成更新，此时另一个请求到来，发现没缓存，于是查数据库，存入缓存，并返回结果。之后数据库完成了更新，此时数据库和缓存再次出现不一致。<strong>解决方案</strong>：串行化。一个更新数据的操作，“删除缓存+更新数据库”，将其路由到一个jvm的队列中。读取数据的操作，如果发现缓存中没有数据，则将“读取数据+更新缓存”的操作也放入一个jvm的工作队列中。一个工作线程对应一个队列，线程从队列中获取操作并执行，这样，更新数据的操作将顺序执行删除缓存，然后更新数据库，在数据库未更新完成之前，如果有读取数据的请求，发现缓存中没有数据，将进入工作队列中，等待前一个更新操作完成之后，再执行“读取数据+更新缓存”的操作，保证了数据的一致性。</p>
]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试问题</title>
    <url>/posts/f4828e27.html</url>
    <content><![CDATA[<p>

<a id="more"></a>

<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><div class="note info"><p>OSI标准是七层模型，TCP/IP中是四层模型</p>
<p>​    <strong>物理层</strong>：完成数模转换和模数转换。网卡</p>
<p>​    <strong>数据链路层</strong>：有错误检测和纠正机制。交换机，ARP协议</p>
<p>​    <strong>网络层</strong>：解决不同子网的通信问题。路由器，RIP协议</p>
<p>​    <strong>传输层</strong>：保证数据段有效到达对端。TCP,UDP协议</p>
<p>​    <strong>会话层</strong>：不同实体建立和使用连接（会话）。全双工、半双工、单工</p>
<p>​    <strong>表示层</strong>：数据的表示方式。编解码、加解密、压缩</p>
<p>​    <strong>应用层</strong>：为用户直接提供服务。FTP(21)、SSH(22)、SMTP和POP3、HTTP、DNS</p></div>

<h3 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a>什么是RIP协议？</h3><p>RIP是距离矢量路由协议，每个路由器维护一张表，记录自己和其他路由器之间的距离，在进行路由的时候优先选择距离短的。通过和相邻路由器交换信息更新表。</p>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址由网络号和主机号组成，共四个字节。根据网络号所占的字节数划分为ABCDE五类网。A类网网络号占一个字节，B类占两个字节，以此类推。</p>
<details>
    <summary>子网划分</summary>
    从主机号借用若干位成为子网号，数据报仍根据网络号找到目的网络，由路由器根据网络号和子网号找到目的子网，通过子网掩码和目的地址逐位与操作，得到子网地址。
</details>


<h3 id="什么是ARP协议"><a href="#什么是ARP协议" class="headerlink" title="什么是ARP协议"></a>什么是ARP协议</h3><p>ARP是地址解析协议，完成了IP地址到物理地址的映射。每一个主机都有一张高速缓存映射表，里面记录了所在局域网内的其他主机和路由器的IP地址和物理地址。当主机需要发送数据包时，将查找自己的ARP缓存，如果能找到目的主机的记录，则直接发送，否则将向所在局域网广播一个ARP请求包，包含自己和目的主机的IP和MAC地址。收到请求的主机将检查自己是不是目的主机，如果是则保存源主机的IP和MAC地址，然后向源主机发送ARP响应，包含自己的IP和MAC地址。如果源主机请求的目的地址不在当前网络，将通过路由器转发到其他局域网进行查找。</p>
<h3 id="什么是NAT？"><a href="#什么是NAT？" class="headerlink" title="什么是NAT？"></a>什么是NAT？</h3><p>NAT是网络地址转换，由NAT路由器将内网中的本地主机IP转换为全球IP地址，让内网中的主机和因特网中的主机进行通信。</p>
<h2 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a>什么是三次握手？</h2><div class="note info"><p>三次握手是遵循TCP协议的通信双方建立连接的过程。</p>
<p>第一次握手：客户端发起连接请求，发送SYN=1，初始化序列号为x的数据包给服务端，进入SYN_SENT状态。</p>
<p>第二次握手：服务端接收请求连接报文，并发送确认包，确认序列号为x+1，同时将SYN位置1，并初始化自己的序列号为y发送给客户端，进入SYN_RECV状态。</p>
<p>第三次握手：客户端接收到确认和请求连接报文，检查确认标志位ACK是否为1，确认序列号是否为x+1，检查正确后，发送确认报文，确认序列号为y+1，进入established状态。服务端接收到确认报文，检查ACK和ack number正确后，进入established状态。三次握手结束，连接建立。</p></div>

<h3 id="TCP建立连接可以两次握手吗？"><a href="#TCP建立连接可以两次握手吗？" class="headerlink" title="TCP建立连接可以两次握手吗？"></a>TCP建立连接可以两次握手吗？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>不可以，主要有以下两个原因。</p>
<ul>
<li><p>两次握手容易造成服务端连接资源浪费的情况，当客户端发送的第一次握手消息由于网络等原因延迟了，客户端会重新发送握手消息，然后成功完成通信并释放连接。此时延迟的握手消息到达了服务端，如果只有两次握手，服务端再接收到这个消息时就会发送确认并建立连接等待接收客户端的数据，但此时客户端并没有想要建立连接，因此服务端的连接资源也就白白浪费了。采用三次握手则可以避免这种情况。</p>
</li>
<li><p>三次握手可以确保通信双方成功互换初始序列号，这是后续通信时确认应答和超时重传的基础，保证TCP的可靠性。</p>
</li>
</ul>

</div></div>

<h3 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>发起连接的一方会生成一个32位的序列号作为初始序列号发送给对端，对端也会发送自己的初始序列号。初始序列号作为原点，对要传输的数据进行编号。根据发送序列号和确认序列号，发送方可以知道接收方已确认接收的数据，接收方可以验证哪些数据编号是合法的。</p>

</div></div>

<h3 id="TCP建立连接可以四次握手吗？"><a href="#TCP建立连接可以四次握手吗？" class="headerlink" title="TCP建立连接可以四次握手吗？"></a>TCP建立连接可以四次握手吗？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>可以，其实三次握手中的第二次握手，服务端将确认和请求连接的消息放在一个报文里，将这个过程拆分成两次握手，就是四次握手。但是这样也浪费了资源</p>

</div></div>

<h3 id="第三次握手中，如果客户端的ACK未到达服务端，会怎样？"><a href="#第三次握手中，如果客户端的ACK未到达服务端，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未到达服务端，会怎样？"></a>第三次握手中，如果客户端的ACK未到达服务端，会怎样？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>服务端如果没有接收到客户端的确认，则会重传第二次握手消息，默认可重传5次，如果都没有接收到确认，就进入CLOSED状态；如果接收到确认，就建立连接。</p>
<p>服务端进入CLOSED状态之后，再接收到客户端的数据，将会以RST包响应。</p>

</div></div>

<h3 id="建立连接后，如果客户端出现故障，会怎样？"><a href="#建立连接后，如果客户端出现故障，会怎样？" class="headerlink" title="建立连接后，如果客户端出现故障，会怎样？"></a>建立连接后，如果客户端出现故障，会怎样？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>服务端每接收到客户端一个报文之后，就会重置自己的计时器，通常是两小时，如果在这期间都没有接收到客户端的数据，则会发送一个探测报文，之后每隔75秒发送一次，如果发送了10次都没有响应，则判断客户端出现故障，就会关闭连接。</p>

</div></div>

<h2 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h2><div class="note info"><p>四次挥手是遵循TCP协议的通信双方释放连接的过程</p>
<p>第一次挥手：客户端完成了数据的传输，发起释放连接请求，FIN=1，序列号为x，进入FIN_WAIT1状态。</p>
<p>第二次挥手：服务端接收到请求后，发送确认报文，进入CLOSE_WAIT状态。客户端接收到确认报文后，进入FIN_WAIT2状态。</p>
<p>第三次挥手：服务端也完成了数据的发送，发送释放连接报文，进入LAST_ACK状态。</p>
<p>第四次挥手：客户端接收到释放连接请求，发送确认报文，进入TIME_WAIT状态，等待2MSL时间后，释放连接，进入CLOSED状态。服务端接收到确认报文后，释放连接，进入CLOSED状态。</p></div>

<h3 id="为什么不能三次挥手？服务端的CLOSE-WAIT状态有什么意义？"><a href="#为什么不能三次挥手？服务端的CLOSE-WAIT状态有什么意义？" class="headerlink" title="为什么不能三次挥手？服务端的CLOSE_WAIT状态有什么意义？"></a>为什么不能三次挥手？服务端的CLOSE_WAIT状态有什么意义？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>客户端发起释放连接的请求只能确认客户端没有数据要进行传输了，但此时服务端可能还有未发送的数据，CLOSE_WAIT状态用来等待服务端数据也发送完毕再释放连接。</p>

</div></div>

<h3 id="TIME-WAIT状态的意义？"><a href="#TIME-WAIT状态的意义？" class="headerlink" title="TIME_WAIT状态的意义？"></a>TIME_WAIT状态的意义？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>第四次挥手，客户端的ACK可能会丢失，TIME_WAIT状态用来重发可能丢失的ACK。如果服务端没有接收到ACK，则会重发FIN报文。TIME_WAIT的时长是2MSL，MSL就是报文段在网络中的最长存活时间。客户端的ACK在一个MSL内没到达服务端，服务端就会重发FIN，这个重发的FIN最长存活时间也是MSL，那么在2MSL时间内都没有接收到服务端重发的FIN，则认为ACK已经成功到达服务端。</p>

</div></div>

<h2 id="TCP如何进行流量控制？"><a href="#TCP如何进行流量控制？" class="headerlink" title="TCP如何进行流量控制？"></a>TCP如何进行流量控制？</h2><div class="note info"><p>使用滑动窗口协议来实现流量控制。接收方根据自己缓冲区的情况，动态调整接收窗口大小，并将接收窗口大小放在ACK报文中发送给发送方。发送方的发送窗口大小不能超过接收窗口，防止发送速率太快，接收方缓冲区不够导致溢出。当发送方接收到确认之后，将窗口向右滑动。</p></div>

<h3 id="什么是”零窗口“？"><a href="#什么是”零窗口“？" class="headerlink" title="什么是”零窗口“？"></a>什么是”零窗口“？</h3><p>当接收方无法接受新数据时，就会将接收窗口大小设为0，发送方将会停止发送数据，并通过1字节大小的探测报文来检查接收窗口的变化，当接收窗口&gt;0时，就恢复数据发送。</p>
<h2 id="TCP如何进行拥塞控制？"><a href="#TCP如何进行拥塞控制？" class="headerlink" title="TCP如何进行拥塞控制？"></a>TCP如何进行拥塞控制？</h2><p>拥塞控制主要通过四个算法实现，分别是慢开始、拥塞避免、快重传、快恢复。</p>
<p><img src="https://realmicah.xyz/img/interviews/congestion_control.jpg" alt="拥塞控制"></p>
<div class="note info"><p><strong>慢开始</strong>：刚开始发送数据时，将拥塞窗口大小设置为1MSS，最大报文段长度，之后每收到一个确认ACK，就将窗口增大1个MSS，这样窗口大小随着传输轮次呈指数增长。</p>
<p><strong>拥塞避免</strong>：当慢开始执行到窗口大小等于慢开始门限时，将减缓窗口增大速度，每个传输轮次线性增长。</p>
<p><strong>快重传</strong>：快重传要求接收方在接收到一个失序的报文段后立即发出重复确认。当发送方连续接收到三个重复确认，就要立即重传失序的报文段。</p>
<p><strong>快恢复</strong>：当发送方接收到三个重复确认时，就把慢开始门限减小为拥塞窗口的一半，然后执行拥塞避免算法。</p>
<p>出现<strong>重传</strong>的两种情况：</p>
<p>超时未接收到ACK：发送方在发送完一个报文段时，会启动一个计时器，当超时未接受到ACK时，则会重新传输该报文段。在这种情况下，发送方认为网络状况不佳，因此将慢开始门限设置为拥塞窗口的一半，拥塞窗口设置为1，重新执行慢开始算法。</p>
<p>接收到3个重复确认：此时由于可以接收到3个重复确认，因此网络没有出现拥塞，此时将慢开始门限减小为拥塞窗口的一半，但可以适当增大拥塞窗口，然后执行拥塞避免算法。</p></div>

<h3 id="慢开始门限有什么用？"><a href="#慢开始门限有什么用？" class="headerlink" title="慢开始门限有什么用？"></a>慢开始门限有什么用？</h3><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><div class="note info"><p>TCP面向连接，UDP面向无连接，即UDP传输数据前不需要建立连接</p>
<p>TCP是可靠的，UDP是不可靠的，因为UDP接收方不需要发送确认，也就没有确认重传等机制</p>
<p>TCP有拥塞控制，在网络拥塞时控制发送速率，UDP不会因为网络的拥塞而减小发送速率，这在实时应用中是很重要的</p>
<p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多</p>
<p>TCP是面向字节流的，一个数据包可以以字节为单位拆分成多个组发送，UDP是面向数据报文的，一个报文只能一次发完。</p>
<p>TCP的报文首部20字节，比UDP8字节开销更大。</p></div>

<h3 id="什么时候使用TCP，什么时候使用UDP？"><a href="#什么时候使用TCP，什么时候使用UDP？" class="headerlink" title="什么时候使用TCP，什么时候使用UDP？"></a>什么时候使用TCP，什么时候使用UDP？</h3><p>在实时性要求高、可以容忍传输错误的应用中，如直播、游戏、即时通信，使用UDP。其他情况使用可靠的TCP。</p>
<h3 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h3><p>以前来说不可以，HTTP需要可靠的传输协议，UDP不可靠。而新的HTTP/3基于QUIC协议，不再使用TCP，在UDP的基础上增加拥塞控制和可靠性等。</p>
<h2 id="TCP如何保证传输的可靠性？"><a href="#TCP如何保证传输的可靠性？" class="headerlink" title="TCP如何保证传输的可靠性？"></a>TCP如何保证传输的可靠性？</h2><div class="note info"><p>奇偶校验和：检查数据包是否出错</p>
<p>乱序重排：正确接收数据</p>
<p>丢弃重复包：正确接收数据</p>
<p>确认应答机制：发送确认让发送方知道数据已被成功接收</p>
<p>超时重传机制：未被接收的数据重新发送</p>
<p>流量控制：控制发送速率避免接收方缓冲区发生溢出</p></div>

<h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><div class="note info"><p>HTTP默认使用80端口，HTTPS使用443端口</p>
<p>HTTP使用明文传输，HTTPS运行于SSL协议之上，有加密和认证机制，更加安全</p>
<p>HTTPS加解密过程需要消耗更多的CPU和内存</p>
<p>HTTPS需要向证书颁发机构CA购买证书</p></div>

<h3 id="HTTPS建立连接的过程？"><a href="#HTTPS建立连接的过程？" class="headerlink" title="HTTPS建立连接的过程？"></a>HTTPS建立连接的过程？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<ul>
<li>浏览器向服务端发送连接请求，消息内容包含自己支持的加密规则（对称加密、非对称加密、摘要算法）</li>
<li>服务端接收到请求后，选择一套加密规则，生成非对称加密的公钥，和证书一起发送回浏览器</li>
<li>浏览器验证证书的有效性，随机生成用于对称加密的密钥，使用服务端的公钥加密生成密文，通过摘要算法生成摘要，一起发送给服务端</li>
<li>服务端使用私钥解密消息，通过摘要算法验证数据完整性，得到浏览器生成的密钥，然后使用密钥加密消息，并生成摘要发送给浏览器。</li>
<li>浏览器接受后使用密钥解密消息并验证完整性，成功之后，连接建立，接下来使用密钥加密数据传输保证安全性。</li>
</ul>

</div></div>

<h3 id="直接输入-www-baidu-com-是如何转为HTTPS的？"><a href="#直接输入-www-baidu-com-是如何转为HTTPS的？" class="headerlink" title="直接输入 www.baidu.com , 是如何转为HTTPS的？"></a>直接输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> , 是如何转为HTTPS的？</h3><div><div class="fold_hider"><div class="close hider_title">查看答案</div></div><div class="fold">
<p>打开浏览器的调试界面，可以看到直接使用 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 时，服务端会发回307响应，在响应头中的LOCATION指定重定向的地址为 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> ，然后浏览器重新向该地址发起请求。服务端在响应头中携带Strict-Transport-Security字段，设置过期时间，在这段时间内，再次请求该地址，浏览器会自动转换为HTTPS。</p>

</div></div>

<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><div class="note info"><p>GET一般用于向服务端获取资源，POST可能会对服务端资源进行修改。因此GET具有幂等性，即每次请求相同的URL会获得相同的响应，POST不具有幂等性。</p>
<p>GET的请求参数附在URL上，在请求头中，POST的请求参数放在请求体中。</p>
<p>由于浏览器或操作系统对URL长度限制，因此GET的请求参数不能过长，而POST则没有限制</p></div>

<h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><div class="note info"><p>Session是服务端保存状态的方式，Cookie是客户端保存状态的方式</p>
<p>Cookie保存在客户端，发起请求时将cookie放在请求头一起提交；Session保存在服务端，通过sessionId检查状态。</p>
<p>sessionId可以保存在cookie中，如果禁用了cookie，可以将sessionId放在URL中。</p></div>

<h2 id="输入URL到看到页面的过程"><a href="#输入URL到看到页面的过程" class="headerlink" title="输入URL到看到页面的过程"></a>输入URL到看到页面的过程</h2><div class="note info"><p>浏览器通过DNS解析域名获取服务端IP地址。</p>
<p>三次握手建立TCP连接，之后浏览器发起HTTP请求</p>
<p>服务端根据请求URL找到对应的请求处理器，处理之后返回响应包含处理结果和视图</p>
<p>浏览器解析并渲染视图，可能会再次请求页面中引用的其他静态资源文件</p>
<p>渲染完成，请求结束。</p></div>

<h2 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h2><div class="note info"><p>200：请求成功</p>
<p>301：永久重定向，接下来的请求都应该使用新的URL. 302：临时重定向</p>
<p>400：错误的请求，可能是请求方法错误. 401：未认证. 403：禁止访问. 404：无法找到</p>
<p>500：内部错误. 502：错误网关. 503：由于超载或系统维护服务不可用</p></div>
]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库面试问题</title>
    <url>/posts/1f02b5ce.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h2 id="事务的概念和特性？"><a href="#事务的概念和特性？" class="headerlink" title="事务的概念和特性？"></a>事务的概念和特性？</h2><p>概念：事务是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束。</p>
<p>特性</p>
<ol>
<li>原子性：事务中的所有操作，要么全部成功提交，要么全部失败回滚。逻辑上是不可分割的操作单元。事务的回滚通过回滚日志undolog实现。</li>
<li>一致性：事务的执行必须使数据库保持一致性的状态。在一致性状态下，所有事务对同一数据的读取结果相同。</li>
<li>隔离性：事务在提交之前对数据所做的修改对其他事务是不可见的。并发执行的事务互不影响。</li>
<li>持久性：成功提交的事务对数据所作的修改是永久的。</li>
</ol>
<h3 id="如何保证原子性和持久性？"><a href="#如何保证原子性和持久性？" class="headerlink" title="如何保证原子性和持久性？"></a>如何保证原子性和持久性？</h3><p>通过引入undo log来实现事务的原子性。undo log记录数据被修改前的值，通常是逻辑日志，记录每一行的修改记录。当事务执行过程中出现宕机/需要回滚，则通过undo log将数据恢复。当事务结束时，undo log不会立刻清除，而是放入待清理的链表，由purge线程判断是否有其他事务正在使用undo log中记录的表的上一个事务之前的版本信息，决定是否删除。</p>
<p>由于undo log会被删除，因此引入redo log来保证事务的持久性。</p>
<p>redo log记录修改后的数据，通常是物理日志，记录发生修改的数据页。在事务提交之前写入磁盘，即使事务提交过程中宕机，也可以通过redo log将事务执行结果刷新到数据库。未提交/回滚的事务也会记录在redo log中。</p>
<h2 id="会发生哪些并发一致性问题？"><a href="#会发生哪些并发一致性问题？" class="headerlink" title="会发生哪些并发一致性问题？"></a>会发生哪些并发一致性问题？</h2><ol>
<li>丢失修改：一个事务对数据做了修改，在事务提交之前，另一个事务也对同一个数据做了修改，则第一个事务的修改丢失了。</li>
<li>脏读：一个事务读到另一个事务未提交/回滚的修改。</li>
<li>不可重复读：在同一个事务中，某个查询语句读取某行数据和之后再次读取该行数据得到不同的结果，数据已经发生修改。</li>
<li>幻读：当同一查询执行多次，由于其他事务在这个范围内执行了插入操作，导致每次返回不同的结果集。</li>
</ol>
<h2 id="数据库的四种隔离级别？"><a href="#数据库的四种隔离级别？" class="headerlink" title="数据库的四种隔离级别？"></a>数据库的四种隔离级别？</h2><ol>
<li>读未提交：在一个事务提交之前，它的执行结果对其他事务是可见的，会出现脏读、不可重复读、幻读。</li>
<li>读已提交：一个事务只能看见已经提交的事务的执行结果。解决脏读，会出现不可重复读、幻读。</li>
<li>可重复读：可以确保同一个事务在多次读取某一数据返回相同的结果。解决脏读、不可重复读，会出现幻读。</li>
<li>串行化：强制事务串行执行，使事务之间不可能相互冲突，解决幻读问题。</li>
</ol>
<h2 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h2><ol>
<li><p>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会对数据上锁，防止其他事务读取和修改数据。应用于数据更新频繁的场景</p>
</li>
<li><p>乐观锁：操作数据时不会上所，但是更新时会判断在此期间有没有其他事务修改了数据，若被修改过，则失败重试。适用于读多写少的场景。</p>
<div class="note info"><ol>
<li>加一个版本号或时间戳字段，在数据更新时同时更新这个字段</li>
<li>先读取想要更新的字段或者所有字段，只有在字段没有变化才执行更新</li>
</ol></div>

</li>
</ol>
<h2 id="常见的封锁类型"><a href="#常见的封锁类型" class="headerlink" title="常见的封锁类型"></a>常见的封锁类型</h2><blockquote>
<p><strong>封锁</strong>：是指事务对某个数据操作之前，先向系统发出请求，对其加锁。加锁之后事务就对该数据有了一定的控制。</p>
</blockquote>
<ol>
<li><p>排它锁：又称写锁。在事务对数据加上排它锁后，只允许该事务读取和修改数据，并且其他事务不能再对数据加任何锁</p>
</li>
<li><p>共享锁：又称读锁。事务对数据加上共享锁后，拥有了读取数据的权限，但是不能修改数据。其他的事务可以再对数据加共享锁不能加排它锁</p>
</li>
<li><p>意向锁：分为意向排它锁和意向共享锁。</p>
<div class="note info"><p>一个事务在获取某个数据行的共享锁之前，必须先获得整个表的意向共享锁或者更强的锁。</p>
<p>一个事务在获得某个数据行的排它锁之前，必须先获得整个表的意向排它锁。</p>
<p>优点：如果一个事务想要对整个表加排它锁，需要先检测有没有其他事务已经获取了表的排它锁，再检测每一行有没有被加上排它锁，整个过程非常耗时。有了意向锁之后，只需要检测整个表是否被加上意向排它锁即可。</p></div>

</li>
</ol>
<h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><div><div class="fold_hider"><div class="close hider_title">查看</div></div><div class="fold">
<p>Mysql提供了两种封锁粒度：行级锁和表级锁。</p>
<p>封锁力度小表示锁定的数据单元越少，发生锁竞争的可能就越小，系统支持的并发程度越高，但是会增加系统开销，加解锁、检查锁都需要消耗资源。</p>
<p>InnoDB在查询时如果where子句不走索引的话，就会进行全盘扫描，此时将使用表级锁，保证查询结果的正确。</p>

</div></div>

<h3 id="什么是三级封锁协议？"><a href="#什么是三级封锁协议？" class="headerlink" title="什么是三级封锁协议？"></a>什么是三级封锁协议？</h3><ol>
<li>一级封锁协议：事务在修改数据之前必须先对其加排它锁，知道事务结束才能释放。解决了丢失修改问题（如果一个数据正在被修改，那么其他事务无法修改该数据，因此原事务的执行结果不会被覆盖）</li>
<li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，读完即可释放。可以解决脏读问题（如果一个数据正在被修改，此时其他事务无法读取该数据，所以在修改事务提交之前修改结果不可见）</li>
<li>三级封锁协议：在一级的基础上，事务在读取数据之前必须先对其加共享锁，直到事务结束才能释放。可以解决不可重复读问题（如果读取事务读取数据后就释放，在事务未结束时其他事务可以加排它锁来对数据进行修改，读取事务再次读取数据时，则会读到被修改的数据。三级封锁协议可以保证在整个读取事务期间数据不会被修改）</li>
</ol>
<h3 id="什么是两段锁协议？"><a href="#什么是两段锁协议？" class="headerlink" title="什么是两段锁协议？"></a>什么是两段锁协议？</h3><blockquote>
<p>事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。在事务释放锁之后，就不能再申请加锁。</p>
</blockquote>
<p>两段锁协议可以保证事务满足可串行化调度，也就是并发执行的事务结果与某个串行执行的事务结果相同。</p>
<h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC是指多版本并发控制，INNODB的MVCC，通过在每行记录后保存两个隐藏的列来实现，记录了创建时间和删除时间。这里并不是记录时间戳，而是记录事务版本号。每开启一个事务，系统的版本号就会递增。创建时间的列记录了创建时的事务版本号，删除时间的列记录了删除时的事务版本号。</p>
<p>执行插入操作时，在新创建的行中记录创建版本号；删除操作时记录删除版本号；更新时先在原数据行记录删除版本号，再新增一行并记录创建版本号；在进行查询的时候，只查找创建版本号小于当前事务版本号以及未定义删除版本号和删除版本号大于当前事务版本号的行，这样可以保证已被创建和未被删除。</p>
<h3 id="如何实现读已提交和可重复读？"><a href="#如何实现读已提交和可重复读？" class="headerlink" title="如何实现读已提交和可重复读？"></a>如何实现读已提交和可重复读？</h3><p>读已提交，每次查询都会重新生成readview，readview中有尚未提交的版本号，根据查询的记录的版本号，找到可见的版本号。由于每次查询都会重新生成readview，因此在事务执行过程中，如果有其他的事务完成了提交，再次查询，就会读到不同的数据，也就出现了不可重复读。</p>
<p>可重复读，只会在事务的第一次查询生成一个readview，沿用到事务结束，因此可以解决不可重复读。</p>
<h2 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h2><ol>
<li>第一范式：属性是不可分的。</li>
<li>第二范式：非主属性<strong>完全依赖</strong>于主属性。消除非主属性对主属性的部份依赖。B完全依赖于A表示A中的所有属性唯一确定B。</li>
<li>第三范式：非主属性<strong>直接依赖</strong>于主属性，消除传递依赖。</li>
<li>第四范式：在第三的基础上，每个列不允许有多值，比如移动电话列不允许该用户有两个手机号。</li>
<li>第五范式：#。</li>
<li>BCNF：修正的第三范式，消除主属性之间的传递依赖。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">不符合范式会出现哪些问题？</div></div><div class="fold">
<p>数据冗余：相同的数据重复出现。</p>
<p>插入异常：无法插入一个还没有课程信息的学生</p>
<p>修改异常：修改了一个记录中的信息，相同的信息却没有被修改</p>
<p>删除异常：删除一个信息，丢失其他信息，删除一个课程，将课程的学生也删除了。</p>

</div></div>

<h2 id="主键、超键、候选键、外键分别是什么？"><a href="#主键、超键、候选键、外键分别是什么？" class="headerlink" title="主键、超键、候选键、外键分别是什么？"></a>主键、超键、候选键、外键分别是什么？</h2><ol>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键</li>
<li>候选键：不含有多余属性的超键称为候选键，也就是候选键中不能再删除任何一个属性</li>
<li>主键：用户选作元组标识的候选键</li>
<li>外键：在关系模式R中的属性K是其他关系模式的主键，则K是R的外键</li>
</ol>
<blockquote>
<p>主键是候选键的子集，候选键是超键的子集。</p>
</blockquote>
<h2 id="列举几种表连接的方式？"><a href="#列举几种表连接的方式？" class="headerlink" title="列举几种表连接的方式？"></a>列举几种表连接的方式？</h2><ol>
<li><p>内连接：<code>[inner] join</code> ，只查询出两表中符合查询条件的行信息。</p>
</li>
<li><p>外连接</p>
<div class="note info"><p>左外连接：<code>left [outer] join</code>，左边的表不加限制，将所有行信息都显示，右表没有匹配的用null补上。</p>
<p>右外连接：和左外连接相反。</p>
<p>全外连接：<code>full [outer] join</code>，左右两表都不加限制，将两表所有记录都显示，不匹配的用null补上。</p></div>
</li>
<li><p>交叉连接：<code>cross join</code> ，不带<code>where</code> 子句时，返回笛卡尔积。带<code>where</code> 子句先生成笛卡尔积，再在其中找满足条件的。</p>
</li>
</ol>
<h2 id="delete-drop-truncate的区别"><a href="#delete-drop-truncate的区别" class="headerlink" title="delete/drop/truncate的区别"></a>delete/drop/truncate的区别</h2><ol>
<li>delete是DML语句，逐行的删除数据，并会记录日志，事务提交之后才真正执行。执行速度较低。</li>
<li>truncate是DDL语句，删除整个表的数据，不会记录事务日志，隐式提交。通过释放数据页的内存来删除数据。</li>
<li>drop是DDL语句，将删除整个表的结构和数据，隐式提交</li>
</ol>
<p>如果删除和事务有关，则要使用delete，如果和事务无关，则选择truncate，如果要删除整个表，就使用drop</p>
<h2 id="存储过程、触发器、视图、约束"><a href="#存储过程、触发器、视图、约束" class="headerlink" title="存储过程、触发器、视图、约束"></a>存储过程、触发器、视图、约束</h2><ol>
<li><p>存储过程是一段事先经过编译并存储在数据库的sql语句，类似于函数，通过调用这个函数获得输出结果。</p>
<div class="note info"><p>优点：</p>
<p>预先编译，提高了执行效率。</p>
<p>封装了一系列操作，对于数据交互比较多的操作，可以减少网络通信量。</p>
<p>可复用，安全性高。</p></div>
</li>
<li><p>触发器是由插入/删除/更新操作触发的操作，不能被直接调用，没有参数，用于保证数据的完整性。</p>
</li>
<li><p>视图是从数据库基本表中通过查询选出数据组成的虚拟表。对视图的修改不影响基本表。</p>
</li>
<li><p>约束有多种类型，主键约束、唯一约束、非空约束、外键约束</p>
</li>
</ol>
<h2 id="为什么要使用索引？使用索引的好处？"><a href="#为什么要使用索引？使用索引的好处？" class="headerlink" title="为什么要使用索引？使用索引的好处？"></a>为什么要使用索引？使用索引的好处？</h2><ol>
<li>加快数据的检索速度，避免全盘扫描。</li>
<li>可以显著减少查询中分组和排序的时间，因为如果order by的字段本身就是索引，那么它已经是有序的。</li>
<li>通过创建唯一性索引，可以保证数据表中每一行的唯一性</li>
<li>将随机I/O变为顺序I/O，B+树索引会把相邻的数据存储在一起</li>
</ol>
<p><strong>缺点</strong>：建立和维护索引耗费空间和时间</p>
<h2 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h2><p>和<strong>B树</strong>相比：</p>
<ol>
<li>m阶B+树所有非叶子节点都有m个子树指针，B树最多有m个子树指针，因此B+树的高度会更低。并且B+树的非叶子节点只存放关键字，B树还会存放数据，因此B+树I/O次数更少。</li>
<li>在进行范围查询时，由于B+树的所有数据都在叶子节点，并且叶子节点之间有指针，因此直接遍历叶子节点即可，而B树需要中序遍历整棵树</li>
<li>B+树的查询效率更加稳定，每次都需要从根节点到叶子节点</li>
</ol>
<p>和<strong>hash索引</strong>相比：</p>
<ol>
<li>哈希索引虽然可以以O(1)时间进行查找，但是只支持精确查找，并且在大量哈希值相等的情况下，查询效率会降低</li>
</ol>
<h2 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h2><ol>
<li>以“%”开头的LIKE语句</li>
<li>OR语句前后没有同时使用索引</li>
<li>数据类型出现隐式转化</li>
<li>对于复合索引，必须满足最左匹配原则</li>
<li>在数据量小的表中，Mysql可能判断全盘扫描更快。</li>
</ol>
<h2 id="哪些地方适合创建索引？"><a href="#哪些地方适合创建索引？" class="headerlink" title="哪些地方适合创建索引？"></a>哪些地方适合创建索引？</h2><p>经常被查询、作为表连接、ORDER BY、GROUP BY的字段。数据量小的字段、非空的字段。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol>
<li>功能类：普通索引、唯一索引、主键索引、覆盖索引（索引包含了要返回的值因此不用回表）</li>
<li>按列分：单列索引、符合索引</li>
<li>聚集索引和非聚集索引：聚集索引的顺序决定了数据的物理顺序，因此一张表只有一个聚集索引。非聚集索引只存放数据的逻辑地址。</li>
</ol>
<h2 id="存储引擎InnoDB和MyISAM的区别"><a href="#存储引擎InnoDB和MyISAM的区别" class="headerlink" title="存储引擎InnoDB和MyISAM的区别"></a>存储引擎InnoDB和MyISAM的区别</h2><ol>
<li>InnoDB支持事务、外键、行级锁和表级锁，MyISAM支持表级锁。</li>
<li>MyISAM支持压缩表，需要的内存空间更小，但是压缩后只读，更新操作需要解压后执行。</li>
<li>InnoDB支持在线热备份</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>MyISAM管理非事务表，提供高速存储和检索，对于数据量小，或者只读数据，使用MyISAM效率更高。InnoDB支持事务，在并发下有更好的性能。</p>
<h3 id="热备份和冷备份"><a href="#热备份和冷备份" class="headerlink" title="热备份和冷备份"></a>热备份和冷备份</h3><p>热备份：在数据库运行期间完成快照备份。备份时数据库仍可提供服务</p>
<p>冷备份：数据库关闭后，将数据文件复制到另一位置的备份方式</p>
<h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><ol>
<li><p>SQL优化</p>
<div class="note info"><p>分析慢查询日志，查看查询时间长、IO多的SQL语句，针对性的优化</p>
<p>使用explain分析，查看表的读取顺序、使用了哪些索引、扫描行数。</p>
<p>通过写出需要的列返回必要的列，避免使用select *</p>
<p>通过limit限制返回的行数</p>
<p>将一次大的复杂的多表查询分解成简单的单表查询</p></div>
</li>
<li><p>索引优化：避免索引失效、在合适的地方创建索引</p>
</li>
<li><p>表结构优化：遵循三大范式来进行表设计。数据量大时可以进行表切分</p>
</li>
</ol>
<h3 id="垂直切分和水平切分"><a href="#垂直切分和水平切分" class="headerlink" title="垂直切分和水平切分"></a>垂直切分和水平切分</h3><div class="note info"><p>垂直切分：按业务来切分数据库，相同的业务表存放在同一个数据库节点。垂直切分减少了单节点数据库的负载，原来只有一个数据库，所有业务读写请求都在同一个节点，负载太高。但是对于那些单表数据量就巨大的表（比如商品表、订单表），即使切分到一个数据库，仍然容易造成性能降低。</p>
<p>水平切分：按表中的字段的规则（主键求模、主键范围、日期）把数据切分到不同的数据表，达到缩表的目的。</p>
<p>先进行水平切分，因为水平切分不需要修改整个系统架构，做业务模块的拆分，工作量小。</p></div>

<h2 id="什么是主从复制？实现原理是什么？"><a href="#什么是主从复制？实现原理是什么？" class="headerlink" title="什么是主从复制？实现原理是什么？"></a>什么是主从复制？实现原理是什么？</h2><p>主从复制是指数据可以从一个Mysql数据库主服务器复制到其他的从服务器。</p>
<p>通过三个线程来实现：</p>
<ol>
<li>主服务器binary log dump 线程：将主服务器中的数据更改记录到bin log日志中</li>
<li>从服务器I/O线程：负责从主服务器读取bin log，并写入本地的relay log</li>
<li>从服务器SQL线程：负责读取relay log，解析出主服务器的数据更改，并在从服务器上重放，实现主从数据的一致性。</li>
</ol>
<h3 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h3><ol>
<li>读写分离：主服务器负责写，从服务器负责读。缓解锁竞争，即使主服务器的数据被加了锁，从服务器依然可以处理读请求。从服务器可以采用MyISAM提高查询性能，节省存储空间。</li>
<li>提高系统的可用性，当某个节点出现故障，可以进行故障切换保证服务。</li>
<li>数据实时备份</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Java后端面试</category>
      </categories>
      <tags>
        <tag>Java后端面试</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树基础</title>
    <url>/posts/75890e6e.html</url>
    <content><![CDATA[<P></p>

<a id="more"></a>

<h2 id="从2-3树开始说起"><a href="#从2-3树开始说起" class="headerlink" title="从2-3树开始说起"></a>从2-3树开始说起</h2><h3 id="🍉简介"><a href="#🍉简介" class="headerlink" title="🍉简介"></a>🍉简介</h3><p>我们知道二分搜索树在插入元素本身是有序的情况下，其将退化成一个链表，查询效率也由O(logN)退化到O(N)，为了提升效率，将二分搜索树优化为平衡二叉树，在插入删除过程中保证左右子树的高度差不超过1，让树的高度最小。但是维护平衡也需要带来更多更复杂的操作，因此引入了2-3树。</p>
<p>2-3树是一棵绝对平衡的树，它的结点可以有2个孩子或3个孩子，这也是其名字的由来，它满足二分搜索树的基本性质，其大小关系如下图</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_1.png" alt="图片"></p>
<h3 id="🍓插入操作"><a href="#🍓插入操作" class="headerlink" title="🍓插入操作"></a>🍓插入操作</h3><p>2-3树在插入结点时不能将结点插入到一个空结点上，因为要保证其绝对平衡的性质，新的结点只能通过分裂或者融合产生。</p>
<p>下面通过对上图的2-3树的构建过程，了解2-3树的插入操作。</p>
<p>依次插入16-15-13-12-11-10-8-6-5</p>
<ol>
<li><p>插入16-15-13</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_2.png" alt="图片"></p>
<p>在插入13之后，形成了一个“4结点”，于是通过<strong>分裂</strong>将其转变为3个2结点</p>
</li>
<li><p>插入12-11</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_3.png" alt="图片"></p>
<p>在插入11之后，形成了一个“4结点”，于是通过<strong>分裂</strong>将其转变为3个2结点，但也因此出现了不平衡，所以需要通过<strong>融合</strong>保证树的绝对平衡。</p>
</li>
<li><p>插入10-8</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_4.png" alt="图片"></p>
<p>和前面的过程类似，需要通过多次的<strong>分裂</strong>和<strong>融合</strong>来保证平衡</p>
</li>
<li><p>插入6-&gt;5</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_5.png" alt="图片"></p>
</li>
</ol>
<div class="note info"><p>可以发现，在插入过程中，2-3树通过融合和分裂两个操作的多次使用，来保证树的绝对平衡。其情况可总结为以下4种</p>
<p>①插入一个2结点，<strong>融合</strong></p>
<p>②插入一个3结点，且是根结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点</p>
<p>③插入一个3结点，其父亲结点是2结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点，再和父亲结点<strong>融合</strong>成一个3结点</p>
<p>④插入一个3结点，其父亲结点是3结点，先<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点，再和父亲结点<strong>融合</strong>成一个4结点，再<strong>分裂</strong>成三个2结点…</p>
<p>其实只要理解了<strong>融合</strong>和<strong>分裂</strong>两个过程，遇到具体情况再具体分析即可，不需要死记情况。</p></div>

<h2 id="与2-3树等价的红黑树"><a href="#与2-3树等价的红黑树" class="headerlink" title="与2-3树等价的红黑树"></a>与2-3树等价的红黑树</h2><h3 id="😯从2-3树到红黑树"><a href="#😯从2-3树到红黑树" class="headerlink" title="😯从2-3树到红黑树"></a>😯从2-3树到红黑树</h3><p>由于2-3树的结点并不统一，也就是2-3树的结点可能有1个元素或者2个元素，在实现上会比较复杂，于是尝试保持结点仍然只有1个元素，但是保持2-3树的思想，大体的做法是：对于2结点，不需要修改；对于3结点，将2个元素拆开，成为两个2结点；并以颜色区分2结点和3结点，2结点为黑色，3结点拆分出来的左侧（较小）的结点为红色，右侧的结点为黑色；这样实现出来的树称为红黑树。</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_6.png" alt="图片"></p>
<h3 id="🍉基本性质"><a href="#🍉基本性质" class="headerlink" title="🍉基本性质"></a>🍉基本性质</h3><p>在有了2-3树的基础之后，再来看《算法导论》这本书中对于红黑树的性质介绍，就比较容易理解了。</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_7.png" alt="图片"></p>
<ol>
<li>所有的结点或者是红色，或者是黑色。这个是红黑树本身的定义</li>
<li>根结点是黑色的。对于2-3树，它的根结点要么是2结点，要么是3结点，对于2结点，它本身就转化为黑色结点；对于3结点，我们将右侧作为父亲结点，左侧作为孩子结点，并且右侧为黑色，左侧为红色；因此根结点一定是黑色的</li>
<li>所有叶子结点（<strong>空结点</strong>）都为黑色。此处的叶子结点是空结点，而不是左右子树为空的结点。当红黑树为空树时，由性质2，可知根结点为黑色，而此时根结点为空，因此也是性质3的体现</li>
<li>红色结点的左右孩子结点都是黑色的。在2-3树中，从3结点分离出来的红色结点，它的子树根结点只能是2结点或3结点，而经过转化之后，这个子树的根结点只能变为黑色结点，参考性质2。因此红色结点的孩子结点都是黑色的</li>
<li>从每一个结点到其叶子结点所经过的黑色结点数目是相同的。原因是2-3树是一棵绝对平衡的树，因此从一个结点到其叶子结点经过的结点数是相同的，而在转化成红黑树之后，无论是2结点还是3结点，都会转化出一个黑色结点</li>
</ol>
<h4 id="题外问：为什么红黑树能保持O（logN）的复杂度？"><a href="#题外问：为什么红黑树能保持O（logN）的复杂度？" class="headerlink" title="题外问：为什么红黑树能保持O（logN）的复杂度？"></a>题外问：为什么红黑树能保持O（logN）的复杂度？</h4><p>因为红黑树的最大高度为2logN，出现在当有一条从根结点到叶子结点都是3结点的情况下，如果都是2结点，那么和平常的二叉树一样，都是logN，在全是3结点的时候，转化为红黑树时，一个3结点会成为一个红色结点和一个黑色结点，因此高度是2logN的，由于2是常数，在时间复杂度上仍然当作O（logN）级别。</p>
<h3 id="🍓插入操作-1"><a href="#🍓插入操作-1" class="headerlink" title="🍓插入操作"></a>🍓插入操作</h3><p>红黑树也是一棵二分搜索树，因此插入操作的基本步骤是相同的，首先是查找要插入的位置，然后将新结点设置为红色，这一步的原因在于如果将新结点设置为黑色，就会导致从根到叶子的路径上多一个额外的黑色结点，难以调整，而连续的两个红色结点可以通过旋转和颜色翻转来调整。第三步是自下而上的调整树，使其仍为红黑树。</p>
<p>具体的调整分为以下几种情况：</p>
<ol>
<li><p>插入到黑色结点左侧：这种情况即相当于在2-3树中插入到2结点，融合形成3结点，而3结点转化成红黑树正好是左侧为红色、右侧为黑色，因此不需要调整</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_8.png" alt="图片"></p>
</li>
<li><p>插入到黑色结点右侧：在2-3树中仍然是和2结点融合形成3结点，因此我们只需要考虑如何将其调整为3结点转化为红黑树之后的形态，而这一步调整根据我们在AVL树中的经验，可以使用<strong>左旋转</strong>来实现。</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_9.png" alt="图片"></p>
<p>对应的代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Node x = node.right; <span class="comment">//42</span></span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    node.right = x.left;</span><br><span class="line">    x.left = node;</span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    x.color = node.color; <span class="comment">//当前子树的根结点从node变为x, 因此x的颜色需要变为node的颜色</span></span><br><span class="line">    node.color = RED;<span class="comment">//在2-3树中的3结点转化后,左侧的结点为红色结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//返回子树新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>插入到左孩子为红色结点的黑色结点右侧：左孩子为红色结点的结点对应于2-3树中的3结点，在其右侧插入新结点后，融合形成一个”4结点“，经过分裂成为3个2结点，也就是黑色结点，其中子树根结点需要保持原来的颜色(（红色）。因此整个过程等同于根结点和其孩子结点交换颜色，称为<strong>颜色翻转</strong></p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_10.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    node.left.color = BLACK;</span><br><span class="line">    node.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>插入到左孩子为红色结点的黑色结点左侧：相当于在2-3树中的3结点左侧插入一个新结点，为了构造出“4结点”分裂后的树，需要先经过一次<strong>右旋</strong>，由于根结点变为37，因此37需要保持原来根结点42的黑色，而42为了表示其作为“4结点”的一部分，需要变为红色。在经过右旋之后，就成为了情况3，因此之后需要经过一次<strong>颜色翻转</strong></p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_11.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node -&gt; 42</span></span><br><span class="line">    Node x = node.left; <span class="comment">//37</span></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    node.left = x.right;</span><br><span class="line">    x.right = node;</span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    x.color = node.color;</span><br><span class="line">    node.color = RED;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>插入到左孩子为红色结点的黑色结点中间：相当于在2-3树的3结点中间插入一个新结点，综合前面几种情况，可以比较快地构造出“4结点”分裂后的树，首先是先对37所在子树进行一次<strong>左旋</strong>，就得到了<strong>情况4</strong>，之后经过<strong>右旋</strong>，就得到了<strong>情况3</strong>，最后通过<strong>颜色翻转</strong>就可以调整为红黑树</p>
<p><img src="https://realmicah.xyz/img/DataStructure/RBT_12.png" alt="图片"></p>
</li>
</ol>
<p>可以发现，情况4和5可以通过旋转转换为情况3，因此上述的5种情况，其处理的方式可以在统一的流程里实现，即总是经过左旋-&gt;右旋-&gt;颜色翻转就可以完成对树的调整。</p>
<div class="note info"><p>当前结点右孩子为红色结点，左孩子为黑色结点，需要左旋——对应情况2</p></div>

<div class="note success"><p>当前结点左右孩子都为红色结点，需要颜色翻转——对应情况3</p></div>

<div class="note warning"><p>当前结点左孩子为红色结点，左孩子的左孩子为红色结点，需要右旋——情况4</p></div>

<p>于是，在对红黑树进行插入操作的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">    root.color = BLACK; <span class="comment">//保持根结点为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++; <span class="comment">//维护结点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, RED);<span class="comment">//新结点总是红色的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分搜索树的查找并插入</span></span><br><span class="line">    <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;<span class="comment">//插入到右子树</span></span><br><span class="line">        node.right = add(node.right, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;<span class="comment">// 插入到左子树</span></span><br><span class="line">        node.left = add(node.left, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//维护红黑树</span></span><br><span class="line">    <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;<span class="comment">//右孩子为红色 左孩子为黑色</span></span><br><span class="line">        leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;<span class="comment">//左孩子和左孙子为红色</span></span><br><span class="line">        rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.right))&#123;<span class="comment">//左右都红</span></span><br><span class="line">        filpColors(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="noopener">数据结构之红黑树</a></li>
<li><a href="https://class.imooc.com/datastructure" target="_blank" rel="noopener">liuyubobobo《算法和数据结构》</a></li>
<li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Java异常体系</title>
    <url>/posts/f885a170.html</url>
    <content><![CDATA[<p></p>

<a id="more"></a>

<h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>Java中的异常都是Throwable的子类，分为Error和Exception，Error用来表示JVM无法处理的错误，Exception分为受检异常和不受检异常，又叫编译期异常和运行时异常，其区别是编译期异常如果不处理会编译失败，运行时异常可以通过编译。</p>
<p>运行时异常时RuntimeException及其所有子类，除此之外都是编译期异常。其体系结构如下图：</p>
<p><img src="https://realmicah.xyz/img/notes/java_exception_1.png" alt="图片"></p>
<p>Error下有OutOfMemoryError和StackOverflowError，Exception下有RuntimeException和IOException。常见的Runtime有NumberFormatException，ClassNotFoundException，ClassCastException，CloneNotSpportException，IndexOutOfBoundException，常见的IOException有FileNotFoundException，FileExistsException，EncodeException，DecodeException，SocketException等。</p>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><ol>
<li><p>逻辑：如果有finally，执行完try会执行finally，如果有finally有return或者让程序结束的语句，则直接结束，否则会回到try中执行。</p>
</li>
<li><p>字节码：先是try中的翻译成机器指令(比如4-8条)，然后是finally块的指令(比如9-10条)，然后是return(11条)。接下来的字节码是catch中的指令(12-14)，然后是final的指令(15-16跟第一个finally一样的)，最后是goto指令(17)。每个catch有这么一段，goto指令都指向最后一句return(38)。最后还会有未被catch的其他异常，字节码结构为astore存储异常(33)，finally的指令(34-35)，aload取出异常，然后是抛出异常的athrow指令，最后一句是return(38条).也就是所有catch之后goto的位置。接下来是异常表Exception Table决定在抛异常后跳转到的位置，格式如下：</p>
<table>
<thead>
<tr>
<th align="center">from指令开始行</th>
<th align="center">to指令最后行</th>
<th align="center">target跳转到目标指令行号</th>
<th align="center">type异常类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">Exception1–异常1</td>
<td align="center">在try中抛出了异常Exception1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">18</td>
<td align="center">Exception2–异常2</td>
<td align="center">在try中抛出了异常Exception2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在try中抛出了未被catch的异常</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">17</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理Exception1时抛出了其他异常</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">23</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理Exception2时抛出了其他异常</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">37</td>
<td align="center">33</td>
<td align="center">any–其他异常</td>
<td align="center">在处理其他异常的时候抛出了异常，准确来说是处理其他异常时finally抛出的异常</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h3><ol>
<li>throw：用在方法体内，抛出异常，在运行时是一定会抛出的，由上层调用者处理抛出的异常</li>
<li>throws：用在方法声明中，表示在运行时可能抛出异常，由上层调用者处理</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>本地配置Git多账户</title>
    <url>/posts/372eebb7.html</url>
    <content><![CDATA[<p>

<a id="more"></a>

<h2 id="1-生成公钥和私钥"><a href="#1-生成公钥和私钥" class="headerlink" title="1. 生成公钥和私钥"></a>1. 生成公钥和私钥</h2><div class="note info"><p>在命令行窗口或<code>git bash</code>下输入命令，默认生成路径为当前路径，建议在系统<code>.ssh</code>文件夹（默认是<code>C:\Users\Administrator\.ssh</code>）下使用命令行或<code>git bash</code></p></div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"a@email.com"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://realmicah.xyz/img/notes/multi_git_1.png" alt="图片"></p>
<ol>
<li>进行多用户配置时需要针对不同的账号设置不同的文件名，比如<code>id_rsa_a</code>和<code>id_rsa_b</code></li>
</ol>
<h2 id="2-配置ssh-agent"><a href="#2-配置ssh-agent" class="headerlink" title="2. 配置ssh-agent"></a>2. 配置ssh-agent</h2><div class="note info"><p><code>ssh-agent</code>即ssh代理，管理着本地的所有密钥。当我们进行多用户配置时，需要将多个不同的密钥添加到ssh代理中。启动ssh-agent可能报错，需要用管理员权限打开PowerSheel，执行<code>Set-Service -Name ssh-agent -StartupType automatic</code></p></div>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-<span class="keyword">add</span> id_rsa_a</span><br></pre></td></tr></table></figure>

<h2 id="3-添加公钥到Github账户"><a href="#3-添加公钥到Github账户" class="headerlink" title="3. 添加公钥到Github账户"></a>3. 添加公钥到Github账户</h2><p>路径为<code>settings-&gt;SSH and GPG keys-&gt;New SSH key</code><a href="https://github.com/settings/keys" target="_blank" rel="noopener"></a>，将<code>.ssh</code>文件夹下的<code>id_rsa.pub</code>文件内容粘贴到文本框中，完成添加</p>
<h2 id="4-config文件配置"><a href="#4-config文件配置" class="headerlink" title="4. config文件配置"></a>4. config文件配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//如果不存在，则创建config文件</span><br><span class="line">touch config</span><br></pre></td></tr></table></figure>

<ol>
<li>配置config文件内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#该文件用于配置私钥对应的服务器</span></span><br><span class="line"><span class="comment">#account1(email)</span></span><br><span class="line"> Host git@github.com</span><br><span class="line"> HostName https://github.com</span><br><span class="line"> User a //这里填写username</span><br><span class="line"> IdentityFile id_rsa_a</span><br><span class="line"></span><br><span class="line"><span class="comment">#account2(email)</span></span><br><span class="line"> Host git@gitlab.com</span><br><span class="line"> HostName https://gitlab.com</span><br><span class="line"> User b//这里填写username</span><br><span class="line"> IdentityFile id_rsa_b</span><br></pre></td></tr></table></figure>

<h2 id="5-测试是否可用"><a href="#5-测试是否可用" class="headerlink" title="5. 测试是否可用"></a>5. 测试是否可用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">//<span class="keyword">if</span> success will <span class="built_in">return</span></span><br><span class="line">//Hi a! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">//else return </span></span><br><span class="line"><span class="string">//some errors</span></span><br></pre></td></tr></table></figure>

<h2 id="6-切换账号"><a href="#6-切换账号" class="headerlink" title="6. 切换账号"></a>6. 切换账号</h2><ol>
<li><p>在<code>.ssh</code>文件夹下，创建脚本文件用于切换账号，避免每次都手写切换代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建切换到a账户脚本</span><br><span class="line">touch changeToA.sh</span><br><span class="line">//填入内容</span><br><span class="line">git config --global user.name <span class="string">"a"</span></span><br><span class="line">git config --global user.email  <span class="string">"a@email.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行脚本以切换账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./changeToA.sh</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>开发环境相关</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>1014. 最佳观光组合</title>
    <url>/posts/6cc1ef4f.html</url>
    <content><![CDATA[<blockquote>
<p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。</p>
<p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p>
<p>返回一对观光景点能取得的最高分。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">    输入：[<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">    输出：<span class="number">11</span></span><br><span class="line">    解释：i=<span class="number">0</span>,j=<span class="number">2</span>,A[i]+A[j]+i-j=<span class="number">8</span>+<span class="number">5</span>+<span class="number">0</span>-<span class="number">2</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>在数组中寻找的问题通常最直观的思路是暴力的遍历，这道题同样可以使用这种方法，从前往后枚举每一个元素，并对该元素遍历除了本身之外的其他所有元素，在这个过程中更新最大值<code>max</code>。由于数据规模是<code>50000</code>，因此这种<code>o(n²)</code>的做法是会超时的。</p>
<div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//暴力-超时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                max = Math.max(max, A[i]+A[j]-Math.abs(i-j));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>在暴力做法中，对于得分公式<code>A[i] + A[j] + i - j</code>，我们将其划分成了<code>A[i] + i</code>和<code>A[j]-j</code>两部分，在外层循环确定一个<code>A[i]+i</code>，在内层循环中枚举所有<code>A[j]-j</code>，以此找到最大值。这导致了时间复杂度是<code>O(n²)</code>的，那么我们如何将这两层循环减为一层呢？答案是从这两部分出发，只要两部分都是最大值，那么组合结果一定是最大值。我们可以在遍历过程中，同时维护原本外层循环的<code>A[i]+i</code>始终为最大值即可通过一层循环求出结果。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历的同时维护a始终为最大的A[i]+i值</span></span><br><span class="line">    <span class="keyword">int</span> a = A[<span class="number">0</span>] + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max = Integer.max(max, a + A[i] - i);</span><br><span class="line">        a = Integer.max(a, A[i] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>739-每日温度</title>
    <url>/posts/f2adbb58.html</url>
    <content><![CDATA[<blockquote>
<p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>比较直观的做法就是对于每个位置，往后遍历，当遇到第一个比自身大的元素时就停下来，记录位置；如果直到最后都没有遇到，则表示气温在这之后都不会升高。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//暴力</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T[j] &gt; T[i])&#123;</span><br><span class="line">                res[i] = j-i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>暴力遍历的方式虽然可以获得一个accept，但是效率是非常低的。因为每一次我们都是重新开始遍历，没有利用之前的结果。因此有了以下两种优化方式。</p>
<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>单调栈的含义是，一个栈中从栈顶到栈底一直保持着递增/递减的性质。当遇到新的元素入栈时，如果破坏了性质，则要通过出栈直到剩余的元素和新元素仍保持性质。</p>
<p>本题中，通过维护一个递减的单调栈，可以求出结果。将数组中元素（下标）逐个入栈，当<strong>新元素比栈顶元素大</strong>时，对于栈顶元素来说，即遇到了<strong>第一个比它大</strong>的元素，也就是气温升高，因此将栈顶出栈，并记录结果（下标差）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单调栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> index = stack.pop();</span><br><span class="line">            res[index] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="逆向-跳跃"><a href="#逆向-跳跃" class="headerlink" title="逆向+跳跃"></a>逆向+跳跃</h4><p>对于数组的最后一个元素，由于其后面没有元素，因此该位置结果为0。基于最后一个位置，我们尝试不断地推出前一个元素的结果。先看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="keyword">null</span> || T.length == <span class="number">0</span>) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">int</span> n = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跳跃</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T[j] &gt; T[i])&#123;</span><br><span class="line">                res[i] = j - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j += res[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层for循环从后往前遍历，对于每一个位置<code>i</code>，内层while循环起点是后一个元素<code>j</code>，如果<code>T[j] &gt; T[i]</code>，即气温升高，则记录结果（下标差）；如果位置<code>j</code>不大于<code>i</code>，按照暴力的逻辑，我们会逐个往后遍历，而这里我们通过判断已求得的结果<code>res[j]</code>是否为0来进行“跳跃”。对于<code>res[j]</code>：</p>
<ul>
<li><code>res[j] == 0</code>，即<code>j</code>之后气温不再升高，那么由于<code>T[i]&gt;=T[j]</code>，可得<code>res[i] = 0</code></li>
<li><code>res[j] &gt; 0</code>，即<code>j</code>之后<code>res[j]</code>天气温升高，在<code>[j...j+res[j]]</code>间没有比<code>T[i]</code>大的值，可以进行跳跃，加快效率，在对新的<code>j</code>进行判断</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题46. 把数字翻译成字符串</title>
    <url>/posts/13cdcb1b.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>因为只有<code>26</code> 个小写字母，即数字范围为<code>[0-25]</code>可以翻译为一个字母，因此一个数字的翻译方式最多有两种，一种是单独翻译成一个字母，第二种是和前一个数字组合翻译。而两个数字能够组合翻译的条件是其组成的数字范围在<code>[10-25]</code>之间，因为<code>01</code>、<code>02</code>是不合法的。举个例子：</p>
<ul>
<li>如果只有一位数<code>1</code>，那么他只能有<strong>壹</strong>种翻译结果<code>b</code>；</li>
<li>如果有两位数<code>12</code>，除了各自单独翻译这一种方法之外，由于组合的数字<code>12</code>在<code>[10-25]</code>之间满足要求，可以组合翻译，翻译种数为<code>1+1=2</code>；</li>
<li>如果有三位数，如<code>121</code>，在两位数<code>12</code>的基础上，如果对第三位单独翻译，那么剩下的两位数<code>12</code>有<strong>两</strong>种不同的翻译；因为第二位<code>2</code>和第三位<code>1</code>组合得到<code>21∈{10, 25}</code>，因此他们可以组合翻译，那么剩下第一位<code>1</code>，它只有<strong>壹</strong>种翻译，所以三位数<code>121</code>总共有<code>2+1=3</code>种翻译；</li>
<li>如果有四位数<code>1212</code>，在三位数的基础上，如果对第四位单独翻译，那么剩下的三位数<code>121</code>有<strong>叁</strong>种翻译；因为第三位<code>1</code>和第四位<code>2</code>组合的数字<code>12∈{10, 25}</code>，可以组合翻译，那么剩下两位数<code>12</code>，它有<strong>两</strong>种翻译；于是对于四位数<code>1212</code>，共有<code>3+2=5</code>种翻译。</li>
</ul>
<p>于是我们可以这样求解，从数字<code>num</code>的第一位（最高位）开始，遍历每一位，当前位的翻译种数至少和它前一位的种数相同（当前位单独翻译）；除此之外，如果当前位和前一位组成的数字在<code>[10-25]</code>之间，那么翻译种数需要再加上前两位的种数（当前位和前一位组合翻译）。</p>
<p>这样的过程不断在使用之前的结果来推导出新的结果，也就是<strong>动态规划</strong>的思想。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>为了方便地从数字的高位遍历到低位，我们先将数字转换成字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(num);</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//动态规划，设dp[i]为前i个数字的翻译种数。对于i,两种情况：</span></span><br><span class="line">    <span class="comment">//1.自己翻译成一个字母,这样和上一位的种数是相同的;</span></span><br><span class="line">    <span class="comment">//2.如果和上一位组合的数字在10和25之间,可以组合翻译,这样种数就是前一位种数+前两位种数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">'1'</span> || (s.charAt(i)&lt;<span class="string">'6'</span> &amp;&amp; s.charAt(i-<span class="number">1</span>)==<span class="string">'2'</span>))&#123;</span><br><span class="line">            dp[i] += i-<span class="number">2</span> &lt; <span class="number">0</span> ? <span class="number">1</span> : dp[i-<span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>由于我们每次都只用到前一位和前两位的结果，因此可以对空间复杂度进行优化，这种优化方式称为滚动数组。仅仅使用两个变量保存结果。</p>
<p>这里还有一个优化是我们将当前位<code>i</code>的结果记录在<code>i+1</code>的位置上，这样就不需要每次都进行 <code>i-2 &lt; 0</code>的检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(num);</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">1</span>;<span class="comment">//前一位种数</span></span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">1</span>;<span class="comment">//前两位种数</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//中间变量-备份</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i ++)&#123;</span><br><span class="line">        temp = one;<span class="comment">//暂存前一位种数</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>) == <span class="string">'1'</span> || (s.charAt(i-<span class="number">2</span>) == <span class="string">'2'</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) &lt; <span class="string">'6'</span>))&#123;</span><br><span class="line">            one += two;</span><br><span class="line">        &#125;</span><br><span class="line">        two = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>990. 等式方程的可满足性</title>
    <url>/posts/19551cf1.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>看懂题目之后一顿狂喜，<del>苦学已久的</del>并查集终于要派上用场了。</p>
<p>题目的意思就是，给定的数组里每个字符串都是<code>a==b</code>或者<code>a!=b</code> ，其中a，b代表变量，要求赋值之后所有方程都成立。例如，<code>[a == b, b == c, c == d, a != d, e == f, b != e]</code>，所有等式要成立要求<code>[a=b=c=d ,e=f]</code>（如下图）</p>
<p><img src="https://www.realmicah.xyz/img/Leetcode/990.jpg" alt="UnionFindSet"></p>
<p>由于<code>b!=e</code>中<code>b</code>和<code>e</code>属于在形成的两条等式里（颜色不同），符合要求，但对于不等式<code>a!=d</code>，发现它在形成的同一条等式里（颜色相同），因此不满足要求。</p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>可以将并发集中的元素看作一棵树，像上图所示，满足相同性质（本题是相等）的节点在同一棵树上，拥有相同的根节点。有以下两个基本操作：</p>
<ol>
<li>并：将满足性质的节点（树）合并为同一棵树。</li>
<li>查：查找某个节点的根节点，可以用来判断两个节点是否满足相同性质。</li>
</ol>
<p>因此本题的解法是先将所有等式两边的节点添加到并查集中，然后判断不等式两边的节点是否在同一棵树上，如果在，则表示他们必须相等，因此不等式也就不成立了。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>并查集可以使用一个数组<code>parent</code>来实现，以0-25来代表26个小写字母，数组中每个位置存放该位置（字母）的父亲节点，如<code>[1,2,3,3,5,5]</code>，位置0值为1，表示a的父亲节点是b，位置1值为2，表示b的父亲节点是c，位置3值为3，表示d的父亲节点是d，则d为和d相等的节点形成的树的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        parent[i] = i;<span class="comment">//初始每个节点的父亲节点是自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            union(a,b, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String s: equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(a,parent) == find(b,parent))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank)</span></span>&#123;</span><br><span class="line">    parent[find(a, parent)] = find(b, parent);<span class="comment">//合并a,b形成的树--a的根节点的父亲节点指向b的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] != index)&#123;<span class="comment">//当父亲节点是自身时跳出循环</span></span><br><span class="line">        parent[index] = parent[parent[index]];<span class="comment">//让父亲节点指向爷爷节点</span></span><br><span class="line">        index = parent[index];<span class="comment">//此时index为爷爷节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;<span class="comment">//循环结束时index为根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>优化是对于并查集的优化，通常有两种策略：加权合并规则法、路径压缩法。这里介绍基于树高度的路径压缩法。</p>
<p>增加<code>rank</code>数组记录每个节点所在树的高度，在进行合并时，将选择合并后树高度最低的方案。这样在进行查找操作时，迭代次数少（递归深度低），达到优化目的。这种优化在数据量大时优化效果明显。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//基于rank的路径压缩</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;<span class="comment">//初始化树高度为1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            union(a,b, parent, rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String s: equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(a,parent) == find(b,parent))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank)</span></span>&#123;</span><br><span class="line">    <span class="comment">// parent[find(a, parent)] = find(b, parent);</span></span><br><span class="line">    <span class="keyword">int</span> aRoot = find(a,parent);</span><br><span class="line">    <span class="keyword">int</span> bRoot = find(b,parent);</span><br><span class="line">    <span class="keyword">if</span>(aRoot == bRoot)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让高度低的并到高度高的--高度越小 find越快</span></span><br><span class="line">    <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])&#123;</span><br><span class="line">        parent[aRoot] = bRoot;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[aRoot] &gt; rank[bRoot])&#123;</span><br><span class="line">        parent[bRoot] = aRoot;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//高度相同</span></span><br><span class="line">        parent[aRoot] = bRoot;</span><br><span class="line">        rank[bRoot] ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] != index)&#123;</span><br><span class="line">        parent[index] = parent[parent[index]];</span><br><span class="line">        index = parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>127. 单词接龙</title>
    <url>/posts/527f7711.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>算法的主要过程是对<code>beginWord</code>每次替换一个字母，成为一个新的单词，判断是否是<code>endWord</code> 。题目要求找到最短转换序列的长度，也就是最少的转换次数，因此可以考虑采用广度优先搜索。因为每次替换一个位置的字母，有25种选择，新的单词必须存在于给出的<code>wordList</code>种，共有单词的长度<code>len</code>个位置。</p>
<p>整个算法其实是在构建一张无向图，假设<code>beginWord</code>为<code>hit</code>，<code>endWord</code>为<code>hot</code>，<code>wordList</code>为<code>[hat,bat,hot]</code>。从<code>beginWord</code>开始，对于第一个位置<code>h</code>，有25种替换选择，但其中只有选择<code>b</code>所生成的新单词<code>bat</code>在<code>wordList</code>中，因此需要往队列<code>queue</code> 中添加<code>bat</code>，第二个位置<code>i</code>，同样有25种选择，其中只有选择<code>a</code>和<code>o</code> 所生成的新单词在<code>wordList</code>中，因此需要将<code>hat,hot</code>放入queue中。但在这里我们发现新生成的单词<code>hot</code> 即为<code>endWord</code>，此时即是最少的转换次数为1次。</p>
<p>理解上述过程需要你对广度优先搜索有一定的熟悉度，比如所用的队列、何时更新转换次数等。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>代码的整个框架还是比较常规的广度优先搜索，主要是其中进行替换时需要替换<code>len</code>个位置，以及每个位置可从<code>a</code>到<code>z</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    HashSet&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(words.size()== <span class="number">0</span> || !words.contains(endWord))&#123;<span class="comment">//不存在endword</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    words.remove(beginWord);</span><br><span class="line"></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//存放已经使用过的</span></span><br><span class="line">    visited.add(beginWord);</span><br><span class="line">    <span class="keyword">int</span> len = beginWord.length();</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">            String curWord = queue.poll();</span><br><span class="line">            <span class="keyword">char</span>[] chars = curWord.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;<span class="comment">//当前单词的每个位置</span></span><br><span class="line">                <span class="keyword">char</span> oldChar = chars[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> m = <span class="string">'a'</span>; m &lt;= <span class="string">'z'</span>; m++)&#123;<span class="comment">//从a-z依次替换</span></span><br><span class="line">                    <span class="keyword">if</span>(m == oldChar)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[j] = m;<span class="comment">//替换当前位置</span></span><br><span class="line">                    String newWord = String.valueOf(chars);</span><br><span class="line">                    <span class="keyword">if</span>(words.contains(newWord))&#123;<span class="comment">//新单词存在于wordList中</span></span><br><span class="line">                        <span class="keyword">if</span>(newWord.equals(endWord))&#123;<span class="comment">//找到了</span></span><br><span class="line">                            <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(newWord))&#123;<span class="comment">//未使用过</span></span><br><span class="line">                            queue.add(newWord);</span><br><span class="line">                            visited.add(newWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[j] = oldChar;<span class="comment">//还原当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step ++;<span class="comment">//此时更新step-在上面整个循环中完成的是将一次替换的所有结果存放到了queue中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>287. 寻找重复数</title>
    <url>/posts/25e6dcf4.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
</blockquote>
<div class="note info"><p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>比较直接的想法有先排序再遍历（破坏输入）、hashSet去重（<code>O(n)</code>额外空间），都不是很好。</p>
<p>再仔细地分析题目，可以发现有两个重要的信息：数组长度为 <code>n + 1</code>、数字范围为<code>[1...n]</code>。应用排序的思路，数组的每一个位置上应该出现的数字为该位置下标+1，我们在遍历数组通过交换位置将数字放到应该在的位置的过程中，可以找出重复的元素，其具体表现为：当遍历到位置<code>i</code>时，如果当前位置的数字没有出现在应该在的位置（<code>nums[i] != i + 1</code>），通过交换 <code>nums[i]</code>和 <code>nums[nums[i] - 1]</code> ，让数字出现在应该在的位置，而当位置（<code>nums[i] - 1</code> ）已经存放了正确的数字时，表示出现了重复。例如，对于数组<code>[1,1,2,2]</code>，当 <code>i = 1</code>时，<code>nums[1] = 1 != 1+1</code>，需要交换位置，而此时，<code>nums[1] - 1 = 0</code> 位置上已经存放了正确的数字 <code>1</code>，于是可以得到重复的数字为1。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>需要注意的是，在成功交换之后，需要重新判断位置<code>i</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解法1：先sort再for</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// for(int i = 0 ; i &lt; nums.length-1 ;i ++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[i] == nums[i + 1])&#123;</span></span><br><span class="line">        <span class="comment">//         return nums[i];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解法2：让元素去到其该去的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(temp == nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                i--;<span class="comment">//成功交换后需要重新判断位置i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-二分法"><a href="#📈-二分法" class="headerlink" title="📈 二分法"></a>📈 二分法</h3><p>（这道题能想到这个做法也是对二分查找运用得登峰造极了😂）</p>
<p>具体的做法是：左右边界分别为1和n。通过记录数组中小于等于中位数<code>mid</code> 的个数，判断重复元素出现在左半部还是右半部，然后更新左右边界。例如：在数组<code>[3,1,2,2,4]</code>中<code>mid = 2</code>，数组中&lt;=2的有3个，因此重复的出现在<code>[1...2]</code>范围中；在数组<code>[3,1,2,3,4]</code> 中&lt;=2的有2个,所以重复的出现在<code>[2+1,...4]</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分-不断排除不会存在重复的一边</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i &lt;= mid)&#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; mid)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>152. 乘积最大子数组</title>
    <url>/posts/27e1a968.html</url>
    <content><![CDATA[<blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [-<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [-<span class="number">2</span>,-<span class="number">1</span>] 不是子数组。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>221. 最大正方形</title>
    <url>/posts/37cbfc16.html</url>
    <content><![CDATA[<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>在二维数组求解比较容易想到<strong>动态规划</strong>的思想，可能主要是机器人运动范围和岛屿数量这类问题的原因。于是开始考虑 <code>dp[i][j]</code>代表什么，由于题目求只包含 1 的最大正方形，因此可以考虑让 <code>dp[i][j]</code>代表以该位置为<strong>右下角</strong>的最大正方形<strong>边长</strong>。右下角是由于动态规划思想从之前的结果推得这次的结果，那么右下角就是最后离开这个正方形的地方。边长是由于可以通过边长求得面积。</p>
<p>接下来考虑递推关系式，当当前位置为 0 时，<code>dp[i][j]</code> 也为0，因为没有以这个位置为右下角的正方形。当当前位置为 1 时，就比较复杂，需要一波分析。分析也不是毫无头绪和方向的，在二维数组的动态规划问题中，一般只有三个位置需要考虑，左侧、上方、左上角。</p>
<h2 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        max = Math.max(max, dp[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        max = Math.max(max, dp[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                max = Math.max(max, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max*max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>1022. 从根到叶的二进制数之和</title>
    <url>/posts/39280e8c.html</url>
    <content><![CDATA[<blockquote>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>以 10^9 + 7 为模，返回这些数字之和。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：(<span class="number">100</span>) + (<span class="number">101</span>) + (<span class="number">110</span>) + (<span class="number">111</span>) = <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>树中的路径问题，可以使用深度优先搜索来解决。本题中，需要求每一从根节点到叶子路径组成的二进制数的和。深搜过程中，需要保存已经得到的当前路径，到达根节点的标志是左右子树都为空，将二进制转为十进制我最开始无耻地使用 <code>Integer.parseInt(s,2)</code>，因为保存当前的路径直接用了字符串😂。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s+=root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        sum += (Integer.parseInt(s,<span class="number">2</span>)%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(root.left, s);</span><br><span class="line">        dfs(root.right, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上面的方法，<code>Integer.parseInt</code>的方式本身耗时，并且每次都从头求，没有利用到之前的记录，因此效率较低。因此在二进制转十进制这一部分进行优化。</p>
<p>我们发现，每加上一个节点值，当前路径的二进制数左移一位，然后加上当前节点。举个例子：示例中，对于路径 <code>110</code>，加入第一个节点值时当前节点二进制数为 <code>1</code>，十进制为 1，第二个节点时，原来二进制数左移1位，对应于十进制乘2，为2，然后加上第二个节点值 1，得到 <code>11</code>，十进制为3，第三个节点，左移1位，加上节点值，得到 <code>110</code>，十进制为3*2+0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur*<span class="number">2</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        sum += cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(root.left, cur);</span><br><span class="line">        dfs(root.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>538. 把二叉搜索树转换为累加树</title>
    <url>/posts/7da63a80.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉搜索树，把它转换为累加树，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
</blockquote>
<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">            /   \</span><br><span class="line">           <span class="number">2</span>     <span class="number">13</span></span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             <span class="number">18</span></span><br><span class="line">            /   \</span><br><span class="line">          <span class="number">20</span>     <span class="number">13</span></span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>根据题意，需要求每个节点比它大的所有节点值的和，对于一棵二叉搜索树，当题目所求和大小关系有关时，应该想到<strong>中序遍历</strong>。在二叉搜索树的中序遍历序列中，每个节点比它大的所有节点都在它的右侧。</p>
<p>如示例中，中序遍历序列为 <code>[2,5,13]</code>，对于2，需要加上 <code>5+13</code> ，对于5，需要加上 <code>13</code>。我们可以发现，第一个节点加上了整个序列之和减去自身的值，接下来的节点也是类似。因此最直接的思路是先求所有节点之和 <code>add</code>，然后根据中序遍历顺序，<code>add</code>作为所有大于当前节点的值的和，修改每个节点的值并更新<code>add</code>即可。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrderForAdd(root);<span class="comment">//求和</span></span><br><span class="line">    inOrderForConvert(root);<span class="comment">//加值</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderForAdd</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderForAdd(node.left);</span><br><span class="line">        add+=node.val;</span><br><span class="line">        inOrderForAdd(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderForConvert</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderForConvert(node.left);</span><br><span class="line">        add-=node.val;</span><br><span class="line">        node.val+=add;</span><br><span class="line">        inOrderForConvert(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述思路虽然直接，但是有些迂回了。我们需要转换一下想法，中序遍历是递增的，因此我们遍历的时候第一个到达的节点是最小值，需要加上其他所有值，这也导致了我们需要先进行一次遍历求得所有和。反过来向，如果能将中序遍历改造成递减的，那么第一个到达的节点是最大值，不需要加其他值，下一个节点只需要加上前一个节点即可，于是我们只需要遍历一次即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        convertBST(root.right);<span class="comment">// 反向中序遍历</span></span><br><span class="line">        root.val += add;</span><br><span class="line">        add = root.val;<span class="comment">//更新add</span></span><br><span class="line">        convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>530. 二叉搜索树的最小绝对差</title>
    <url>/posts/56aa34eb.html</url>
    <content><![CDATA[<blockquote>
<p>给你一棵所有节点非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
</blockquote>
<div class="note info"><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 <span class="number">1</span>，其中 <span class="number">2</span> 和 <span class="number">1</span> 的差的绝对值为 <span class="number">1</span>（或者 <span class="number">2</span> 和 <span class="number">3</span>）。</span><br></pre></td></tr></table></figure></div>

<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树的问题通常使用递归来解决，需要考虑的是在递归过程中需要收集什么信息，足以判断是否符合题意条件。</p>
<p>对于以某一个节点为根的树，它任意两个节点差值的最小值在其左子树求得的最小值、右子树求得的最小值、其<strong>前驱</strong>和<strong>后继</strong>节点与根节点的差值中产生（因为这是一棵二分搜索树）。</p>
<p><strong>前驱节点</strong>：位于左子树的最右位置。数值上是左子树的最大值。</p>
<p><strong>后继节点</strong>：位于右子树的最左位置。数值上是右子树的最小值。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>当节点为空/没有前驱后继节点时，返回整型最大值以避免影响判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分搜索数, 前驱和后继是和根差值最小的</span></span><br><span class="line">    <span class="comment">//左子树上的和右子树上的和当前的求最小的</span></span><br><span class="line">    <span class="keyword">return</span> process(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = process(node.left);</span><br><span class="line">    <span class="keyword">int</span> right = process(node.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = Integer.MAX_VALUE;</span><br><span class="line">    TreeNode precursor = pre(node.left);</span><br><span class="line">    <span class="keyword">if</span>(precursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = Math.min( cur, Math.abs(node.val - precursor.val));</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode successor = suc(node.right);</span><br><span class="line">    <span class="keyword">if</span>( successor != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = Math.min( cur, Math.abs(node.val - successor.val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(left, Math.min(right, cur));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前驱</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">pre</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求后继</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">suc</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>二分搜索树还有一个重要性质是其中序遍历序列是递增的。于是这道题可以通过在中序遍历时计算当前和前一个节点的差值与上一次的差值比较更新结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            min = Math.min(min, Math.abs(node.val- pre.val));</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.04. 检查平衡性</title>
    <url>/posts/4ad52213.html</url>
    <content><![CDATA[<blockquote>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回 <span class="keyword">true</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">4</span>   <span class="number">4</span></span><br><span class="line">返回 <span class="keyword">false</span> 。</span><br></pre></td></tr></table></figure></div>



<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树递归问题，在递归过程中我们将到达一个节点三次，在这三次过程中，我们需要收集树的信息并判断是否符合要求的条件，具体地说，在这个问题中，判断以当前节点为根节点的树是否是平衡的，需要知道左子树是否平衡、右子树是否平衡，当左右都平衡的时候，需要知道当前节点是否平衡——左子树和右子树的高度差。因此我们需要的信息是，左子树的高度以及是否平衡、右子树的高度是否平衡。</p>
<p>于是我们确定了递归需要返回的信息是<strong>树的高度和是否平衡</strong>。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//高度差小于1 -- 需要的值有 当前树的高度,是否平衡</span></span><br><span class="line">    <span class="keyword">return</span> process(root).isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Data <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Data left = process(node.left);</span><br><span class="line">    <span class="keyword">if</span>(!left.isBalanced)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Data right = process(node.right);</span><br><span class="line">    <span class="keyword">if</span>(!right .isBalanced)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(right.h - left.h) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Data(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Data(Math.max(left.h, right.h)+<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">    Data(<span class="keyword">int</span> h , <span class="keyword">boolean</span> isBalanced)&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">        <span class="keyword">this</span>.isBalanced = isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>在把思路理清并写出了上面的代码之后，可以再简化代码，具体的是简化返回的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//高度差小于1 -- 需要的值有 当前树的高度,是否平衡</span></span><br><span class="line">    <span class="keyword">return</span> process(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = process(node.left);</span><br><span class="line">    <span class="keyword">if</span>( left == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = process(node.right);</span><br><span class="line">    <span class="keyword">if</span>( right == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(right - left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员面试经典</category>
        <category>Leetcode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>程序员面试经典</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题11. 旋转数组的最小数字</title>
    <url>/posts/639f1318.html</url>
    <content><![CDATA[<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。例如，数组<code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1.</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>暴力解法就不详述了，遍历可以得到降序的元素。</p>
<p>这题和 Leetcode第 <a href="/posts/e3f3cf8a.html" title="153. 寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a> 题类似，建议先阅读这一篇，解法类似，区别在于这里数组的元素可能出现<strong>重复</strong>，因此缩小区间的时候需要考虑重复元素的情况。</p>
<p>本题中，中间位置元素和最右边的元素有大于小于等于三种关系：</p>
<ol>
<li>当 <code>nums[mid] &lt; nums[right]</code>，区间 <code>[mid...right]</code>保持<strong>升序</strong>，因此最小值在左侧，<code>right = mid</code></li>
<li>当 <code>nums[mid] &gt; nums[right]</code> ，区间 <code>[mid...right]</code> 出现<strong>降序</strong>，因此最小值在右侧，<code>left  = mid + 1</code> </li>
<li>当 <code>nums[mid] == nums[right]</code>，无法确认最小值出现在哪一侧，但是我们希望可以缩小区间。由于中间元素和右边相等，因此可以将右边界左移，就算当前右边界是最小值，但是我们保留了中间元素，所以不会出现问题。</li>
</ol>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span> , r = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r)&#123;<span class="comment">//跳出循环时 l = r，区间剩下的元素就是最小值</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[r] &gt; numbers[mid])&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[r] &lt; numbers[mid])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>572. 另一个树的子树</title>
    <url>/posts/689f55a9.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个非空二叉树 s 和 t ，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<pre><code>给定的树 s:
     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</code></pre><p>示例 2:</p>
<pre><code>给定的树 s：
     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：
   4
  / \
 1   2
返回 false。</code></pre></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树的问题，通常可以使用递归来求解，因为树本身具有天然的递归结构。通常的做法是，判断当前树/当前树的左子树/当前树的右子树是否符合条件。求解这类问题的时候，可以先不考虑具体的边界/递归终止问题，只需要先把框架写出来，用几个示例套入框架，可以较快地确定递归终止条件。</p>
<p>本题中，求一棵树是否为另一颗树的子树，根据上述的思路，可以先得到 <code>return isSub(s, t) || isSubTree(s.left , t) || isSubTree(s.right, t);</code> 这样的框架。然后我们需要写 <code>isSub(s , t)</code> 的逻辑，这个函数处理传入的两个树是否相等，需要满足以下三个条件：1. 节点值相等，即<code>s.val = t.val</code> 2. 节点左子树相等，即<code>isSub(s.left, t.left)</code> 3. 节点右子树相等，即<code>isSub(s.right, t.right)</code> 。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>于是我们综合上面的过程，再套入示例（这个过程最好自己实操一下），确定边界和终止条件。可以写出如下的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//s当前节点-t, s.left-t, s.right-t</span></span><br><span class="line">     <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> isSub(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span> &amp;&amp; s == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.val == t.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSub(s.left , t.left) &amp;&amp; isSub(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题10- I. 斐波那契数列</title>
    <url>/posts/18deca0d.html</url>
    <content><![CDATA[<blockquote>
<p>写一个函数，输入 n ，求斐波那契数列的第 n 项。斐波那契数列定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>, F(<span class="number">1</span>) = <span class="number">1</span>, F(N) = F(N-<span class="number">1</span>)+F(N-<span class="number">2</span>),N&gt;<span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<p>答案需要取模 1e9+7(1000000007)，如计算结果为1000000008，则返回1.</p>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>这道题最直接的思路就是通过递归来求解，它的递归过程和终止条件都已经给出。因此我们可以直接写出这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;<span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)%<span class="number">1000000007</span> + fib(n - <span class="number">2</span>)%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>但是简单的这样递归时间复杂度是O(ф^n)，ф是黄金分割比，是一个指数级别的时间复杂度。原因是这样的求解过程中出现了大量的重复计算。</p>
<p><img src="https://realmicah.xyz/img/%E5%89%91%E6%8C%87Offer/10/1-1.jpg" alt="重复计算"></p>
<p>对数字n，求解fib(n-1)、<strong>fib(n-2)</strong>，之后对n-1，求解<strong>f(n-2)</strong>、<strong>f(n-3)</strong>，对n-2，求解<strong>f(n-3)</strong>、f(n-4)……因此我们可以通过先解决小问题，再求解大问题，先求解 1,2,3….直到n。这样就可以避免重复求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>; <span class="comment">//记录中间结果</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">        b = a;<span class="comment">//往后移动</span></span><br><span class="line">        a = sum;<span class="comment">//往后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>983. 最低票价</title>
    <url>/posts/dcddc4fc.html</url>
    <content><![CDATA[<blockquote>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：days = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">20</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">1</span> 天生效。</span><br><span class="line">在第 <span class="number">3</span> 天，你花了 costs[<span class="number">1</span>] = $<span class="number">7</span> 买了一张为期 <span class="number">7</span> 天的通行证，它将在第 <span class="number">3</span>, <span class="number">4</span>, ..., <span class="number">9</span> 天生效。</span><br><span class="line">在第 <span class="number">20</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">20</span> 天生效。</span><br><span class="line">你总共花了 $<span class="number">11</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>分析题目，针对于某一天，它是否花费决定于上一次花费购买的类型，比如在第31天，它的上一次购买可能是1天前、7天前、30天前。第 <code>31-30</code> 天可以购买30天的通行证，这样可以在 <code>[1...30]</code>天旅行；第 <code>31-7</code> 天可以购买7天的通行证，这样可以在 <code>[24...30]</code>天旅行；第 <code>31-1</code> 天可以购买1天的通行证，这样可以在 <code>[30...30]</code>天旅行；因此第31天可以有3种购买方式产生3种花费，在这三种花费中选择最低的价格。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(days == <span class="keyword">null</span> || days.length == <span class="number">0</span> || costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days[days.length-<span class="number">1</span>] + <span class="number">1</span>]; <span class="comment">//最大天数</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//第一天</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : days)&#123;</span><br><span class="line">        dp[i] = -<span class="number">1</span>; <span class="comment">//标志需要旅游的天数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == <span class="number">0</span>)&#123;<span class="comment">//不需要旅游的</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = dp[i-<span class="number">1</span>] + costs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c7 = dp[i-<span class="number">7</span>] + costs[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> c30 = dp[i-<span class="number">30</span>] + costs[<span class="number">2</span>];</span><br><span class="line">            dp[i] = Math.min(c1, Math.min(c7, c30));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/posts/ea4681d0.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>递归借用系统栈，在遍历时每个节点都会访问三次，因此只要在不同的时机打印出节点的值，即可完成三种遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurTraversal</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(node.val);<span class="comment">//前序</span></span><br><span class="line">        recurTraversal(node.left);</span><br><span class="line">        System.out.print(node.val);<span class="comment">//中序</span></span><br><span class="line">        recurTraversal(node.right);</span><br><span class="line">        System.out.print(node.val);<span class="comment">//后序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h2><ol>
<li><p>前序遍历：前序遍历的顺序是根-左-右，借助栈后进先出的特点，在压栈时先压右再压左，则出栈时先出左再出右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node); <span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">while</span>(!stack,isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：中序遍历的顺序是左-根-右。对于整个二叉树，最左的节点第一个被打印，因此我们从根节点开始，不断入栈左节点（第一次访问），当左节点为空时，说明走到了最左节点，出栈（第二次访问），将其右节点入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//还有左节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left; <span class="comment">//向左走</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有左节点</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：后序遍历的顺序是左-右-根。前序遍历是根左右，我们将前序遍历中压栈顺序改为先压左再压右，则出栈顺序变为根右左，其逆序就是左右根。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            node = in.pop();</span><br><span class="line">            out.push(node);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                in.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                in.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!out.isEmpty())&#123;</span><br><span class="line">            System.out.print(out.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层序遍历：逐层打印节点，借助队列实现。每个节点出队时将左右子节点入队，由于队列先进先出，将按入队顺序出队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            System.out.print(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>98. 验证二叉搜索树</title>
    <url>/posts/5e0c5aa8.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。假定一个二叉搜索树有以下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数</li>
<li>所有左子树和右子树自身必须也是二叉搜索树</li>
</ul>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>二叉树由于天然的具有递归结构，因此大多数问题都可以通过<strong>递归</strong>来解决。本题需要判断当前树是否为二叉搜索树，则当当前节点为二叉搜索树、其左子树为二叉搜索树、其右子树为二叉搜索树时返回 <code>true</code> 。需要注意的是，作为一棵二叉搜索树，它左子树的所有节点都必须小于它，因此不能仅仅判断它和它的左子节点，这样只能判断父子关系而没有判断爷孙关系。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(TreeNode node, <span class="keyword">long</span> min , <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.val &lt; min || node.val &gt; max)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid(node.left, min, node.val) &amp;&amp; valid(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-中序遍历"><a href="#✍️-中序遍历" class="headerlink" title="✍️ 中序遍历"></a>✍️ 中序遍历</h3><p>对于一颗二叉搜索树，它的中序遍历序列是递增的。根据这个特征，我们在中序遍历的时候判断当前值是否大于上一个值即可。如果对树的遍历还不熟悉，可以查看这篇文章 <a href="/posts/ea4681d0.html" title="二叉树的遍历">二叉树的遍历</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归版</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &gt;= root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非递归版</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题06. 从尾到头打印链表</title>
    <url>/posts/9649f58.html</url>
    <content><![CDATA[<blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>对于链表的操作，无法方便地使用下标来获取元素，因此，必然需要从头节点开始通过next指针操作。但是需要从尾到头打印，也就是头节点最后被打印，尾节点第一个被打印。因此我们可以利用栈的后进先出的特点，帮助我们完成这道题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    ListNode cur = head;<span class="comment">//不修改输入</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur.val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; stack.size(); i++)&#123;</span><br><span class="line">        res[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>使用栈需要额外的空间复杂度，我们注意到返回结果是一个数组，而数组可以方便地使用下标来存取元素。因此我们先遍历链表获得链表的长度，初始化数组，再次遍历链表，将第一个节点值放在数组的最后一个位置，第二个节点放在倒数第二个位置，…以此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        size ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        res[--size] = cur.val;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题05. 替换空格</title>
    <url>/posts/48c165ca.html</url>
    <content><![CDATA[<blockquote>
<p>请实现一个函数，把字符串中的每个空格替换成“%20%”。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"we are happy"</span></span><br><span class="line">输出：<span class="string">"we%20are%happy"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>遍历字符串，如果遇到空格就替换成%20%</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"%20"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> sb.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="💡-耍赖"><a href="#💡-耍赖" class="headerlink" title="💡 耍赖"></a>💡 耍赖</h3><p><code>return s.replaceAll(&quot; &quot; , &quot;%20%&quot; );</code></p>
]]></content>
      <tags>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题04. 二维数组中的查找</title>
    <url>/posts/dda4a850.html</url>
    <content><![CDATA[<blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrix: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br><span class="line">给定 target = <span class="number">5</span>，返回 <span class="keyword">true</span>。</span><br><span class="line">给定 target = <span class="number">20</span>，返回 <span class="keyword">false</span>。</span><br></pre></td></tr></table></figure>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>遍历二维数组的每一个位置，判断是否和 <code>target</code> 相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代码的鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; matrix.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😂<del>就这都能双一百你敢信？</del></p>
<p><img src="http://119.3.165.25/img/%E5%89%91%E6%8C%87Offer/04/1.png" alt="图片"></p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>暴力解法没有利用题目提供的每行有序和每列有序的特性。查找的过程无非是判断数字之间的大小关系，并且最好通过大小关系可以帮我们减小查找的范围，就像二分查找，每次可以排除一般的查找范围。</p>
<p>这个二维数组拥有以下特征：对于每一个元素，它所在的行，左侧的元素都比它小，右侧的元素都比它大；它所在的列，上方的元素比它小，下方的元素比它大。要确保所有位置都被考虑到，因此需要确定从四个顶点的哪一个开始。如果从左上角开始，根据target和左上角元素的大小关系，我们无法缩小范围，因为对于左上角来说，只有右侧和下侧，都是比它大的。右小角同理。而对于右上角来说，比它小的在左侧，比它大的在下方，因此如果target比它大，则会出现在下方，我们可以不再考虑当前行；如果比它小，则会出现在左侧，我们可以不必考虑当前列。达到缩小查找范围的目的。左下角同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代码的鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> curRow = <span class="number">0</span>, curCol = col-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( curRow &lt; row &amp;&amp; curCol &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[curRow][curCol] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[curRow][curCol] &lt; target)&#123;</span><br><span class="line">            curRow ++;<span class="comment">//下一行</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curCol --;<span class="comment">//前一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>剑指Offer</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-03. 数组中重复的数字</title>
    <url>/posts/2f50b40c.html</url>
    <content><![CDATA[<blockquote>
<p>找出数组中的重复数字</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内，其中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中的任意一个重复的数字。</p>
</blockquote>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>重复的数字在数组中出现次数会大于1。在遍历数组的过程中，使用HashSet来记录出现过的数字，当HashSet中存在该元素时，说明重复，返回该元素即可。由于数字范围在 0~n-1 范围内，因此可以使用一个数组来记录某个元素出现的次数达到优化的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(freq[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            freq[i] ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-优化"><a href="#✍️-优化" class="headerlink" title="✍️ 优化"></a>✍️ 优化</h3><p>暴力解法的实践和空间复杂度均达到了O(N)，本题由于数组数字范围和长度相同，因此可以将原数组作为哈希表，达到优化空间的目的，但是会<strong>修改输入</strong>。</p>
<p>由于数字范围和数组长度一致，如果没有重复数字，那么每个位置上在排序后的状态下数字和位置是一一对应的，但是我们并不做排序这个工作，因为这样时间复杂度是O(nlogn)级别的。我们只是利用这一特征，遍历数组时，如果当前数字和位置不对应，则将当前数字交换到它应该在的位置上。如果应该在的位置上已经有了正确的数字，那么说明当前数字就是重复的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = nums[nums[i]];</span><br><span class="line">            nums[nums[i]] = nums[i];</span><br><span class="line">            nums[i] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>数组</tag>
        <tag>哈希</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 跳跃游戏 II</title>
    <url>/posts/f579176b.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>采用广度优先遍历的方式，记录从当前位置可以到达的所有位置，当可以到达最后一个位置时，返回结果。同时需要使用记录下一位置是否已经使用过用于<strong>剪枝</strong>，查找可以到达的下一个位置时，使用从大到小查找的<strong>贪心</strong>策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//bfs找到最快到达n-1的</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];<span class="comment">//记录是否使用过</span></span><br><span class="line">    used[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[index]; j &gt; <span class="number">0</span>; j--)&#123;<span class="comment">//从大到小,一种贪心,一定程度提高效率,没有这个策略会超时</span></span><br><span class="line">                <span class="keyword">if</span>(j + index &gt;= n-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!used[j + index])&#123;</span><br><span class="line">                    queue.add(j + index);</span><br><span class="line">                    used[j+index] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述过程中，每一次都把接下来可以到达的、未使用过的<strong>所有</strong>位置放入队列，因此我们可以考虑如何在所有位置中选出最优的位置，最优的依据是：当前位置的能够到达的所有位置中，能够到达最远的位置。听起来有点绕，看个例子：</p>
<blockquote>
<p>对于示例 <code>[2,3,1,1,4]</code>，从下标 0 开始，可以到达的所有位置是：下标 1 ，2。在1和2中，最优的位置是 1，原因是：<code>nums[1] = 3</code>，即从下标 1 可以到达最远位置是 <code>1 + 3 = 4</code> ，而从下标 2 可以到达的最远位置是 <code>2 + 1 = 3</code>。</p>
</blockquote>
<p>根据这样的思路，其实很容易写成复杂度更高的，如果把找出最优位置的过程写成内层循环那就得不偿失了。那么还能通过什么方式来知道最优位置呢？答案是需要换个思路。我们的终止条件是到达数组<strong>最后一个位置</strong>，因此在查找过程中维护当前所能到达的最右边界，而最右边界的选取则采用上述的贪心策略。</p>
<p><code>maxRight</code> 记录位置 <code>cur</code> 能到达的最远位置,  <code>[cur...end]</code>是所有能到达的下一位置，在这个区间内表示的是同一次跳跃，而当 <code>cur</code> 超过 <code>end</code>时，表示这次跳跃能够到达的所有位置已经查找结束，因此 <code>step + 1</code> ，同时将 <code>end</code> 更新为 <code>[cur...end]</code> 所能到达的最远位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length-<span class="number">1</span>;<span class="comment">//遍历到最后一个位置的前一个位置</span></span><br><span class="line">    <span class="comment">//贪心 </span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>, maxRight = <span class="number">0</span>, step = <span class="number">0</span> , cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( end &lt; n)&#123;</span><br><span class="line">        maxRight = Math.max(maxRight, cur + nums[cur]);</span><br><span class="line">        <span class="keyword">if</span>(cur == end)&#123;</span><br><span class="line">            end = maxRight;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode周赛-187</title>
    <url>/posts/2b34ab19.html</url>
    <content><![CDATA[<p/>

<a id="more"></a>

<h3 id="旅行终点站"><a href="#旅行终点站" class="headerlink" title="旅行终点站"></a>旅行终点站</h3><blockquote>
<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法"><a href="#💡-解法" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>终点站不会出现在任何线路的起点，因此将所有终点存入一个set，然后将出现在起点的站点从set中删除，最终剩下的就是终点站。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">destCity</span><span class="params">(List&lt;List&lt;String&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; city = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; cs : paths)&#123;</span><br><span class="line">        city.add(cs.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; cd : paths)&#123;</span><br><span class="line">        <span class="keyword">if</span>(city.contains(cd.get(<span class="number">0</span>)))&#123;</span><br><span class="line">            city.remove(cd.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> city.iterator().next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="是否所有-1-都至少相隔-k-个元素"><a href="#是否所有-1-都至少相隔-k-个元素" class="headerlink" title="是否所有 1 都至少相隔 k 个元素"></a>是否所有 1 都至少相隔 k 个元素</h2><blockquote>
<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<p><strong><img src="https://realmicah.xyz/img/LeetcodeContest/187/2-1.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,0,1,0,0,1], k &#x3D; 2</span><br><span class="line">输出：true</span><br><span class="line">解释：每个 1 都至少相隔 2 个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://realmicah.xyz/img/LeetcodeContest/187/2-2.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,0,1,0,1], k &#x3D; 2</span><br><span class="line">输出：false</span><br><span class="line">解释：第二个 1 和第三个 1 之间只隔了 1 个元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], k &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,1], k &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法-1"><a href="#💡-解法-1" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>只要所有1之间最小的间隔等于k即可。换句话说，如果还没出现k个0就再次出现1，返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kLengthApart</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span> &amp;&amp; distance &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        distance = nums[i]==<span class="number">0</span> ? distance + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a>绝对差不超过限制的最长连续子数组</h2><blockquote>
<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
</blockquote>
<div class="note info"><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-解法-2"><a href="#💡-解法-2" class="headerlink" title="💡 解法"></a>💡 解法</h3><p>最长连续子数组问题，都可以通过暴力枚举以每一个位置开头的最长连续子数组来求解。要求子数组任意两个元素之间绝对差小于等于<code>limit</code>，而最大的绝对差来自最大值和最小值的差，因此需要动态维护子数组中的最大值和最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[i];</span><br><span class="line">        <span class="keyword">int</span> max = nums[i];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[j]-min) &gt; limit || Math.abs(max-nums[j]) &gt; limit)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">                min = Math.min(min, nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(count, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交之后会获得一个<strong>超时</strong>的结果😂。</p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述过程中，由于没有利用到上一次求取过程中的信息，每一个位置的求解都需要遍历该位置元素之后的整个数组，因此是O(N²)的复杂度。解题和优化的思路和Leetcode第 <a href="/posts/4bff4329.html" title="3. 无重复字符的最长子串">3. 无重复字符的最长子串</a> 题类似，既然开头行不通，那么我们可以反过来求解以每一个位置为结尾的满足要求的最长连续子数组。遍历每一个位置，从右向左查找满足条件的。<code>[left...i-1]</code>一定是满足条件的，通过 <code>i</code> 和其左边的数字，更新left，表示包含 <code>i</code> 之后，符合条件的最左下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//满足条件的最小下标数组值。</span></span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length; ++ i)&#123;</span><br><span class="line">        <span class="comment">//队列维护</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j --)&#123;</span><br><span class="line">            <span class="comment">//如果存在相同的值，直接跳过，不处理left</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右往左处理，如果有不满足，直接更新left.</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[j] - nums[i])&gt; limit)&#123;</span><br><span class="line">                left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>文中题目以及图片来自 <a href="https://leetcode-cn.com/contest/weekly-contest-187/" target="_blank" rel="noopener">Leetcode 第 187 场周赛</a> .</p></div>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和</title>
    <url>/posts/a42162e0.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>具有最大和的连续子数组一定是以数组中的某个元素开头的，因此我们只要求得每个位置的最长连续子数组自然也可以得到结果。稍加分析之后，信心满满的写下了这样的代码。<div><div class="fold_hider"><div class="close hider_title">展开</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>跑一下发现连测试用例都过不了。错误的原因在于：当下一个数为负时并<strong>不能跳出循环</strong>，因为可能后面还会有更大的正数，即使加上这个负数，但是由于后面正数更大，自然应该继续累加。</p>
<blockquote>
<p>对于 <code>[1,-3,4]</code>，即使 <code>1</code> 后面是 <code>-3</code>，但是如果就此跳出循环，则求得的最大和为<code>1</code>，但是正确的最大和是 <code>1 + -3 + 4 = 2</code>。</p>
</blockquote>
<p>于是我们尝试修改代码，由于我们只需要求得最大和是多少，因此在内层循环累加的过程中不断更新结果，那么最大值一定能够被找到。<div><div class="fold_hider"><div class="close hider_title">改正之后的代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">            res = Math.max(res, sum+=nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="📈-优化"><a href="#📈-优化" class="headerlink" title="📈 优化"></a>📈 优化</h3><p>上述的思路，为了知道以某个位置的元素为开头的最大和，我们遍历了后续的所有元素，通过<strong>枚举</strong>来求得最大值，而这仅仅能求得这一个位置。这也导致算法的时间复杂度是O(N²)的。于是我们换个思路，当我们考虑以当前位置的元素作为结尾时的最大和，可以根据<strong>前一个位置</strong>求得的最大和 <code>sum</code> 的<strong>正负</strong>，来决定当前位置是加在前一个元素之后，还是自己成为一个新的子数组。当 <code>sum &gt; 0</code>，对于当前数，加上这个 <code>sum</code>，有增加的效果；当 <code>sum &lt;= 0</code> ，对于当前数，加上这个 <code>sum</code> ，有减小的效果，因此可以丢弃之前的 <code>sum</code> ，重新开始计算。</p>
<div class="note success"><p>根据前一个位置的结果得到当前位置的结果，这是典型的<strong>动态规划</strong>思想。</p></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]&gt;<span class="number">0</span> ? dp[i-<span class="number">1</span>]+nums[i] : nums[i];</span><br><span class="line">        res = Math.max(dp[i],res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的，因为我们只需要知道前一个位置的结果，因此使用一个变量 <code>sum</code> 记录，优化空间复杂度。<div><div class="fold_hider"><div class="close hider_title">查看</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum = sum &gt; <span class="number">0</span> ? sum+num : num;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/posts/4bff4329.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
</blockquote>
<a id="more"></a>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>只要我们知道了以每一个位置为开头的无重复最长子串，就可以求得整个字符串的无重复最长子串。这样的做法时间复杂度是O(n²)的。</p>
<p>过程：从一个位置开始，不断向后查找，当出现重复字符时，停下，记录子串长度。判断重复这里我使用一个HashSet来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴力的做法是：判断以每一个位置为起点的最长无重复字符</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; s.length(); start++)&#123;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(s.charAt(start));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end = start+<span class="number">1</span>; end &lt; s.length(); end++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(end)))&#123;</span><br><span class="line">                set.add(s.charAt(end));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//res = Math.max(res,set.size());//由于可能只有一个字符，无法进入内层循环因此不能在这里更新</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,set.size());<span class="comment">//在内层循环结束后更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-优化"><a href="#✍️-优化" class="headerlink" title="✍️ 优化"></a>✍️ 优化</h3><p>在上述的过程中，我们每次找完一个位置的子串之后就将之前的记录全部清除（<code>set = new HashSet&lt;&gt;();</code>)，再次从起点 <code>start</code> 的下一个位置开始查找，导致时间复杂度是O(N²)级别的。其实当出现重复时，<code>[start...end)</code> 左闭右开区间上，全都不是重复的，则<code>[start + 1...end)</code> 也是不重复的，那么我们可以保留 <code>end</code>位置，利用上一次记录的结果，不再从 <code>start + 1</code>的位置重新开始查找。这个过程我们就维护了一个<strong>滑动窗口</strong> <code>[start...end)</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>( left &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; n &amp;&amp; !set.contains(s.charAt(right)) )&#123;</span><br><span class="line">            set.add(s.charAt(right));</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">            set.remove(s.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>更进一步的，当字符串中的出现字符的范围较小时，使用一个int数组来达到优化的效果。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>, right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>( left &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; n &amp;&amp; record[s.charAt(right)] == <span class="number">0</span>)&#123;<span class="comment">//未重复,右移</span></span><br><span class="line">            record[s.charAt(right++)] ++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">            record[s.charAt(left++)]--;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></div>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/posts/3abd6d1e.html</url>
    <content><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>题目要求时间复杂度为O(logn)，因此考虑使用二分查找的方法。二分查找要在有序的数组中进行，往这个方向思考，我们可以发现虽然给定的数组整体并不是有序的，但是它被分为两部分有序的数组，分界点在最大值/最小值。想到了这一点，整个问题转变为在两个有序数组中查找目标值，是一个简单的二分查找过程。而求分界点的方法和Leetcode <a href="/posts/e3f3cf8a.html" title="153. 寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a> 问题相同。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先找到最高点，然后就可以划分为在有序数组中的查找问题</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//因为mid可能一直取left导致死循环,因此+1向上取整 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[left])&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123;<span class="comment">//在右有序数组</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,target,left+<span class="number">1</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//在左有序数组</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,target,<span class="number">0</span>,left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>153. 寻找旋转排序数组中的最小值</title>
    <url>/posts/e3f3cf8a.html</url>
    <content><![CDATA[<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></div>

<h3 id="👊-暴力解法"><a href="#👊-暴力解法" class="headerlink" title="👊 暴力解法"></a>👊 暴力解法</h3><p>对数组进行遍历，找到比前一个位置元素小（<strong>降序</strong>）的位置，即为最小值。如果没有降序，意味着数组没有旋转，旋转点为最后一个位置。那么最小值将是第一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; min)&#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️-二分查找"><a href="#✍️-二分查找" class="headerlink" title="✍️ 二分查找"></a>✍️ 二分查找</h3><p>对于有序数组的查找问题，我们总是可以考虑采用二分来解决。二分的基本思路是：根据中间位置的元素和其他位置元素的大小关系，修改左右边界，达到减小区间（<strong>减治</strong>）的目的。在这个问题中，我开始的想法是让中间数和其左右位置比较，但很快就推翻了这个想法，因为这样的比较无法修改边界，也就无法达到减治的目的。<del>其实数组中每个位置的元素，和其左右位置的关系都是相同的，都是大于其左边的小于其右边的。只有最小值的特征是相反的。</del>（这是一段废话，人家本来就说是升序的数组）。不过解题的过程大多数时候是这样的，不断地试错，找到最正确的方法。</p>
<p>思考到这里，我们应该就可以想到让中间数和左右边界作比较。</p>
<div class="note danger"><p>中间数和左边界</p>
<ul>
<li><p>当<code>nums[mid] &lt; nums[left]</code>，能否确定最小值在左侧？——可以，此时说明区间<code>[left...mid]</code>出现了降序</p>
</li>
<li><p>当<code>nums[mid] &gt; nums[left]</code>，能否确定最小值在右侧？——不能，当没有旋转的时候，最小值会在左侧</p>
</li>
</ul></div>

<div class="note success"><p>中间数和右边界</p>
<ul>
<li><p>当<code>nums[mid] &lt; nums[right]</code>，能否确定最小值在左侧？——可以，此时说明区间<code>[mid...right]</code>保持升序</p>
</li>
<li><p>当<code>nums[mid] &gt; nums[right]</code>，能否确定最小值在右侧？——可以，此时说明区间<code>[mid...right]</code>出现了降序</p>
</li>
</ul></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>经过上面的分析，我们可以尝试写出代码。二分法的代码过程，需要关注的点在循环终止条件以及最后返回什么。在这道题中，最小值一定在数组中，而我们一直在删去不可能存在最小值的区间，当区间只剩下一个元素，那么它一定是最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;<span class="comment">//考虑终止条件</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">// +1是因为mid一定不会是最小值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/posts/c8c06f39.html</url>
    <content><![CDATA[<blockquote>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<a id="more"></a>

<div class="note info"><p><strong>示例：</strong></p>
<p><strong>输入：</strong>1-&gt;2-&gt;4，1-&gt;3-&gt;4</p>
<p><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div>

<h3 id="💡思路"><a href="#💡思路" class="headerlink" title="💡思路"></a>💡思路</h3><p>这道题属于归并排序的应用，数组的归并过程是：使用两个索引<code>i , j</code>指向两个数组的左边界，每次根据两个数组中各自索引位置的元素大小来将一个元素放到结果数组中然后对应索引前进。当然了，我们还需要一个索引<code>k</code>来标识元素应该放到结果数组中的哪个位置。<div><div class="fold_hider"><div class="close hider_title">点击此处查看数组的归并</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length+arr2.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;<span class="comment">//终止条件是arr1用完或arr2用完</span></span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt; arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;<span class="comment">//arr2用完</span></span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;<span class="comment">//arr1用完</span></span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="🧾代码"><a href="#🧾代码" class="headerlink" title="🧾代码"></a>🧾代码</h3><p>了解了数组的归并过程，做这道题也就非常简单了。由于链表不像数组那样通过索引来方便的获取/修改该位置的元素，因此我们需要通过链表的<code>next</code>指针来推进归并过程。对于链表操作需要注意的是指针之间的引用关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本着不修改输入的原则,我们应该使用两个指针指向输入,避免对l1,l2直接修改</span></span><br><span class="line">    ListNode h1 = l1, h2 = l2;</span><br><span class="line">    <span class="comment">//初始化一个虚拟头节点,作为结果链表</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.val &lt; h2.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(h1.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            h1 = h1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(h2.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            h2 = h2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur.next = h1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur.next = h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>归并排序</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>202. 快乐数</title>
    <url>/posts/827e2fc4.html</url>
    <content><![CDATA[<blockquote>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。</p>
<p>如果 <code>n</code>  是快乐数就返回True；不是，则返回False。</p>
</blockquote>
<a id="more"></a>

<div class="note info"><p>示例：</p>
<p>输入： 19<br>输出： true<br>解释： 1²+9² = 82，8²+2² = 68，6²+8² = 100，1²+0²+0² = 1.</p></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p>第一步是写一个求平方和的方法。</p>
<p>如何得到结果？——不断求平方和直到平方和为1的时候返回True。</p>
<p>可以推断的是，不断求平方和的过程中，数字不会一直变大到无穷大，每一个位置上数字的范围是0-9，平方和的最大值是每一个位置都取9的情况，以3位数为例，999的平方和为9² + 9² +9²  = 243，4位数时，9999的平方和为9² + 9² +9² +9²  = 325。再往下演算可以知道，数字不会一直变大。</p>
<p>可能出现的情况？</p>
<ol>
<li>在有穷步之后，得到1。如示例</li>
<li>出现循环，也就是在求平方和过程中，回到了曾经到达过的某个值。</li>
</ol>
<p>于是，我们找到了可以终止循环的条件——重复出现的平方和。</p>
<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><p>经过上面的分析，这里我们使用一个set来判断是否重复出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(n);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">		n = getSquare(n);</span><br><span class="line">        <span class="keyword">if</span>(set.contains(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平方和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSquare</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        sum += m * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="📈-进阶"><a href="#📈-进阶" class="headerlink" title="📈 进阶"></a>📈 进阶</h3><p>当给定数字不是快乐数时，在不断求解下一个数的过程中会形成环，尽管我们没有保存到每一个平方数，但是依然可以将求解过程看成在一个链表找下一个节点的过程，那么问题可以转换为证明<strong>链表存在环</strong>问题，因此可以使用<strong>快慢指针</strong>来解决。<strong>快慢指针</strong>的过程为：快指针一次走两步，慢指针一次走一步，如果链表存在环，那么快慢指针最终会到达同一个节点。</p>
<p>当给定数字为快乐数时，快指针会更早到达1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> slow = n, fast = getSquare(n);</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">        fast = getSquare(fast);</span><br><span class="line">        fast = getSquare(fast);</span><br><span class="line">        slow = getSquare(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>704. 二分查找</title>
    <url>/posts/41f30363.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
</blockquote>
<a id="more"></a>

<div class="note default"><p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p></div>

<h3 id="💡-思路"><a href="#💡-思路" class="headerlink" title="💡 思路"></a>💡 思路</h3><p> <del>不用什么思路，直接二分就完了</del>😝</p>
<h5 id="二分基本步骤"><a href="#二分基本步骤" class="headerlink" title="二分基本步骤"></a>二分基本步骤</h5><ol>
<li>确定左右边界，考虑开闭区间。这里我的左右边界分别是 <code>left = 0</code>，<code>right = nums.length - 1</code>，形成一个<code>[left ... right]</code>的左闭右闭区间。你也可以使用其他的边界类似 <code>right = nums.length</code>等，<strong>最重要的是</strong>你要知道你所定义的这些变量，在运行过程中代表什么，如何变化。</li>
<li>确定循环终止条件，考虑跳出循环的时候，<code>left</code> 和 <code>right</code> 的关系，返回时的处理。</li>
<li>通过中间位置的数 <code>nums[mid]</code> 与 <code>target</code> 的大小关系，修改边界，缩小区间，达到<strong>减治</strong>的目的。这里介绍下 <code>mid</code> 的几种求法。</li>
</ol>
<div class="note info"><p><code>int mid = (left + right) / 2</code>：当<code>left</code> 和 <code>right</code> 值太大时，<code>left + right</code> 会溢出，导致结果不正确</p>
<p><code>int mid = left + (right - left) / 2</code>：通常使用这种。</p>
<p><code>int mid = left + (right - left) &gt;&gt; 1</code> ：有一种说法是位运算比四则运算更快，但是其实优秀的编译器会帮我们做这步优化，因此使用第二种即可。</p>
<p><code>int mid = (left + right) &gt;&gt;&gt; 1</code>：即使产生溢出，无符号右移也可以返回正确的结果。但是不够直观，影响代码的可读性。</p></div>

<h3 id="🧾-代码"><a href="#🧾-代码" class="headerlink" title="🧾 代码"></a>🧾 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//循环终止条件left&gt;right,区间长度&lt;0,表示不存在target</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//±1 -- 因为mid已经被排除</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/posts/a8a97330.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="👊暴力解法"><a href="#👊暴力解法" class="headerlink" title="👊暴力解法"></a>👊暴力解法</h3><p>从数组的第一个位置开始遍历，如果当前位置的值等于目标值，返回其索引值。否则继续向后查找直到第一个大于目标值的元素，返回其索引值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✍️二分查找"><a href="#✍️二分查找" class="headerlink" title="✍️二分查找"></a>✍️二分查找</h3><p>对于有序数组的查找问题，通常可以使用二分来解决。如果你对二分查找并不熟悉，可以先看看Leetcode <a href="/posts/41f30363.html" title="704. 二分查找">704. 二分查找</a> 问题。二分法的整体思路是：根据设定的左边界 <code>left</code> 和右边界 <code>right</code> 计算出中间位置 <code>mid</code> ，然后通过 <code>mid</code> 位置的元素来修改 <code>left</code> 和 <code>right</code> 。</p>
<p>本题中，根据<code>mid</code> 位置元素和目标值 <code>target</code>的大小关系，分为一下三种情况：</p>
<ul>
<li>如果 <code>nums[mid] = target</code>，则直接返回<code>mid</code></li>
<li>如果 <code>nums[mid] &lt; target</code>，则区间<code>[left...mid]</code>都小于 <code>target</code>，因此左边界 <code>left = mid + 1</code></li>
<li>如果 <code>nums[mid] &gt; target</code>，则区间<code>[mid...right]</code>都大于 <code>target</code>，因此右边界 <code>right = mid - 1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//循环结束条件是left&gt; right</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-数组中数字出现的次数 I</title>
    <url>/posts/1f1789a9.html</url>
    <content><![CDATA[<blockquote>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<a id="more"></a>

<h4 id="⛔不符合要求的两种思路"><a href="#⛔不符合要求的两种思路" class="headerlink" title="⛔不符合要求的两种思路"></a>⛔不符合要求的两种思路</h4><ol>
<li><p>数组中的次数问题，我们很容易联想到使用额外的数组记录次数来解决，但这里数组中的元素没有范围，并且由于空间复杂度的要求是O(1)，因此需要考虑其他思路。</p>
</li>
<li><p>首先从数组的特征出发，除两个数字之外，其他每个数字都出现了两次，那么我们可以先排序，然后遍历数组找到只出现一次的两个数字。由于排序的时间复杂度为O(NlogN)，因此也无法满足要求。</p>
</li>
</ol>
<div class="note primary"><p>那么这道题考察什么呢？</p></div>

<p>这是一道非常经典的题目，通过位运算<strong>异或</strong>来解决</p>
<h4 id="☑️正确操作"><a href="#☑️正确操作" class="headerlink" title="☑️正确操作"></a>☑️正确操作</h4><p>先来看看异或的性质</p>
<div class="note default no-icon"><ol>
<li>交换律：p⊕q=q⊕p </li>
<li>结合律：(p⊕q)⊕r = p⊕(q⊕r)</li>
<li>恒等率：p⊕0 = p</li>
<li>归零率：p⊕p = 0</li>
</ol></div>

<p>假设数组中不相同的两个数字是p，q。对数组中的数字进行异或操作，根据交换律，我们让每两个相同的数字异或得到0，最后剩下p，q，因为两个数不同，至少存在一个位不同。异或之后得到的结果肯定存在<strong>某个二进制位为1</strong>。根据这个位，将数组分为两份，由于相同的数字会分到同一组，分别为p和其他相同的数字、q和其他相同的数字。再进行异或，则可以得到p，q。</p>
<div class="note info"><p>举个例子：nums=[1,2,10,4,1,4,3,3]</p>
<ul>
<li>异或和sum = 1⊕2⊕10⊕4⊕1⊕4⊕3⊕3 = 1⊕1⊕3⊕3⊕4⊕4⊕2⊕10 = 2⊕10 = 0010 ⊕ 1010 = 1000</li>
<li>得到二进制为1的位index，sum每次右移一位，当最低位为1<code>sum &amp; 1 == 1</code>，index则为右移次数也即该位在sum中的位置。1000中右移三位0001&amp;1=1，index = 3。<u>此处理论上上使用任何一个为1的位都可以正确得到结果，但是在代码实现上求最右的1是最方便的。</u></li>
<li>根据index划分两组，在划分过程中同时执行异或和计算。对于数组中的所有数字，要么index位为1，要么index位为0 <code>( i &gt;&gt; index ) &amp; 1</code>，如数字1在第三位为0，数字2在第三位为0，数字10在第三位为1，以此划分。</li>
</ul></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	<span class="comment">//1.得到异或和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        sum ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.找到二进制位为1的位</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &amp; <span class="number">1</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        index+=<span class="number">1</span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.分组</span></span><br><span class="line">    <span class="keyword">int</span> p, q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (i &gt;&gt; index) &amp; <span class="number">1</span> == <span class="number">0</span> )&#123;</span><br><span class="line">            p ^= i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p,q&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>当你理解了上述的算法过程之后，如果你知道负数在机器中采用数值的<strong>补码</strong>来表示，那么第二步中的求异或和sum中为1的二进制位就可以使用<code>sum &amp; -sum</code>来得到，补码是原码按位取反+1，-8 使用 8 的补码表示为 1000，那么结果将是1000，接下来第三步操作也相应的有一些小小的改动。</p></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//1.得到异或和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        sum ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.找到二进制位为1的位</span></span><br><span class="line">    sum &amp;= -sum;</span><br><span class="line">	<span class="comment">//3.分组并求和</span></span><br><span class="line">    <span class="keyword">int</span> p, q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sum&amp;i) == <span class="number">0</span>)&#123;</span><br><span class="line">            p^=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            q^=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;p,q&#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题09. 用两个栈实现队列</title>
    <url>/posts/eaced0a1.html</url>
    <content><![CDATA[<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 </p>
</blockquote>
<a id="more"></a>

<p>分析题目，提炼关键信息：队列的特点是<strong>先进先出</strong>，栈的特点是<strong>后进先出</strong>。</p>
<p>我们应当关心的是-：<strong>如何保证出的顺序是先进先出？</strong>注意到-假如栈1入栈顺序为1,2,3,则出栈顺序为3,2,1，那么按栈1出栈顺序将元素放入栈2，则栈2入栈顺序为3,2,1,则出栈顺序为1,2,3。 两个栈一个为进一个为出，这样栈1负责入队，栈2负责出队，就满足队列先进先出的要求。</p>
<p>算法执行过程：</p>
<p>当栈2为空时，将栈1中元素弹出压入到栈2。</p>
<p><img src="https://realmicah.xyz/img/%E5%89%91%E6%8C%87Offer/09/1.jpg" alt="图片"></p>
<p>当栈2不为空时，直接返回栈2栈顶元素即可。</p>
<p>代码如下：</p>
<pre><code>import java.util.Stack;

public class Solution {
    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty())stack2.push(stack1.pop());
        }
        return stack2.isEmpty() ? -1 : stack2.pop();
    }
}</code></pre>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
